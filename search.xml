<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>C语言动态链接库回顾</title>
    <url>/2020/05/03/C_dynamic%20linkc/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/05/09/YMO4bV.jpg" alt="C language"></p>
<h2 id="动态链接库和静态链接库"><a href="#动态链接库和静态链接库" class="headerlink" title="动态链接库和静态链接库"></a>动态链接库和静态链接库</h2><p><strong>静态链接库</strong>会在编译时包含到可执行文件中，这样的程序虽然没有依赖问题，但是可执行文件体积较大，包含相同的公共代码，非常浪费内存。<br>动态链接库的好处就是节省内存空间，还有将一些程序升级变得简单。用户只需要升级动态链接库，而无需重新编译链接其他原有的代码就可以完成整个程序的升级。<br>在windows下动态链接库是以<code>.dll</code>后缀的文件，静态链接库是以<code>.lib</code>的文件<br>而在Linux中，动态链接库是以<code>.so</code>作后缀的文件，静态链接库是以<code>.a</code>（archive的缩写）的文件。<br>本文中，我们的链接库来自于<a href="https://nbpfaus.net/~pfau/ftplib/" target="_blank" rel="noopener">ftplib</a>，这是一个用C语言实现的跨平台FTP库，我们将会用它生成的动态链接库写个简单的程序（连接ftp服务器，然后查询当前目录）。</p>
<a id="more"></a>

<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS 还有 Windows 10专业版</li>
<li>ftplib：V4.0-1</li>
<li>gcc： 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)</li>
</ul>
<h2 id="Linux下"><a href="#Linux下" class="headerlink" title="Linux下"></a>Linux下</h2><p>在Linux中，标准库的大部分函数通常放在文件 libc.a 中（这是<strong>静态链接库</strong>），或者放在用于共享的动态链接文件 libc.so 中（文件名后缀.so代表“share object”，译为“共享对象”，这是<strong>动态链接库</strong>）。这些链接库一般位于 /lib/ 或 /usr/lib/，或者位于 GCC 默认搜索的其他目录（默认搜索目录有<code>/lib</code> <code>/usr/lib</code> <code>/usr/local/lib</code>）。<br>观察一下<strong>ftplib</strong>的<code>Makefile</code></p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line"></span><br><span class="line">install : all</span><br><span class="line">	install qftp /usr/local/bin</span><br><span class="line">	install -m 644 libftp.so.<span class="variable">$(SOVERSION)</span> /usr/local/lib</span><br><span class="line">	install -m 644 ftplib.h /usr/local/<span class="keyword">include</span></span><br><span class="line">	(cd /usr/local/lib &amp;&amp; \</span><br><span class="line">	 ln -sf libftp.so.<span class="variable">$(SOVERSION)</span> libftp.so.<span class="variable">$(SONAME)</span> &amp;&amp; \</span><br><span class="line">	 ln -sf libftp.so.<span class="variable">$(SONAME)</span> libftp.so)</span><br><span class="line">	-(cd /usr/local/bin &amp;&amp; \</span><br><span class="line">	  for f in ftpdir ftpget ftplist ftprm ftpsend; \</span><br><span class="line">	  do ln -s qftp $$f; done)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>make install</code>的时候会把<code>ftplib.h</code>放到<code>/usr/local/include</code>，把<code>libftp.so</code>放到<code>/usr/local/lib</code>，一个是gcc默认的头文件搜索目录，一个是gcc默认的库文件搜索目录。 </p>
<h2 id="安装动态链接库"><a href="#安装动态链接库" class="headerlink" title="安装动态链接库"></a>安装动态链接库</h2><p>在ftplib的src目录中执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make</span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure>

<p>以上操作会把动态链接库放入到我们的系统中。  </p>
<h3 id="程序引用"><a href="#程序引用" class="headerlink" title="程序引用"></a>程序引用</h3><p>然后我们写一个简单的程序</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"ftplib.h"</span></span></span><br><span class="line"></span><br><span class="line">netbuf *con = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">char</span> host[] = <span class="string">"192.168.1.175:2121"</span>; <span class="comment">// 小米手机的ftp服务</span></span><br><span class="line"><span class="keyword">char</span> username[] = <span class="string">"**********"</span>;</span><br><span class="line"><span class="keyword">char</span> password[] = <span class="string">"********"</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!FtpConnect(host, &amp;con))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"connect failed!!\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 登录</span></span><br><span class="line">    <span class="keyword">if</span>(!FtpLogin(username, password, con))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"login failed!\n"</span>);</span><br><span class="line">        FtpQuit(con);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Login successfully!\n"</span>);</span><br><span class="line">    <span class="keyword">char</span> currentDir[<span class="number">20</span>];</span><br><span class="line">    FtpPwd(currentDir, <span class="number">10</span>, con);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Current Directory is %s\n"</span>, currentDir);</span><br><span class="line">    FtpQuit(con);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，现在我们可以用gcc编译它了，因为这里引用了<code>ftplib</code>库，所以我们需要手动添加链接库</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main /usr/local/lib/libftp.so</span><br></pre></td></tr></table></figure>

<p>上面使用了链接库的完整路径，其实我们可以用<code>-l</code>选项，因为生成的链接库命名是规范的（<code>-lXX</code>会去找<code>libxx.so</code>这样的文件，自动加<code>lib</code>前缀）而且也在gcc的默认搜索目录中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main -lftp</span><br></pre></td></tr></table></figure>

<p>另外说一句，有时候我们想增加一个自定义的搜索目录，可以使用<code>-L</code>选项，例如</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc main.c -o main.out -L/usr/lib -lhello</span><br></pre></td></tr></table></figure>

<p>另外也可以使用环境变量<code>LD_LIBRARY_PATH</code>指定搜索目录（在程序执行之前定义这个量就行），路径之间用冒号”:”分隔。<br>我们可以用<code>ldd</code>命令查看程序用到的链接库：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ldd main</span><br><span class="line">        linux-vdso.so.1 (0x00007fff7a7fa000)</span><br><span class="line">        libftp.so.4 =&gt; /usr/local/lib/libftp.so.4 (0x00007f7b5215a000)</span><br><span class="line">        libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x00007f7b51d69000)</span><br><span class="line">        /lib64/ld-linux-x86-64.so.2 (0x00007f7b52563000)</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://www.cprogramming.com/tutorial/shared-libraries-linux-gcc.html" target="_blank" rel="noopener">Shared libraries with GCC on Linux</a></li>
</ul>
]]></content>
      <categories>
        <category>C</category>
      </categories>
      <tags>
        <tag>C</tag>
      </tags>
  </entry>
  <entry>
    <title>一步步自己做个Docker之Cgroups</title>
    <url>/2020/04/06/Docker_Cgroups/</url>
    <content><![CDATA[<p><img src="/images/docker-logo.png" alt="docker logo"></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>Golang版本：1.12.13</li>
</ul>
<h2 id="什么是Linux-Cgroups"><a href="#什么是Linux-Cgroups" class="headerlink" title="什么是Linux Cgroups"></a>什么是Linux Cgroups</h2><p><strong>Linux Cgroups</strong>（Control Groups）提供了对一组进程及将来的子进程的资源限制、控制和统计的能力，这些资源包括CPU、内存、存储、网络等。本质上来说，<strong>Cgroups</strong> 是内核附加在程序上的一系列钩子(hook)，通过程序运行时对资源的调度触发相应的钩子以达到资源追踪和限制的目的。  </p>
<a id="more"></a>



























<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/sparkdev/p/8296063.html" target="_blank" rel="noopener">linux cgroups 简介</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Cgroups</tag>
      </tags>
  </entry>
  <entry>
    <title>CefSharp浅尝辄止</title>
    <url>/2019/11/16/CefSharp_summary/</url>
    <content><![CDATA[<p><img src="/images/CefSharp-logo.png" alt="docker logo"></p>
<h2 id="CefSharp"><a href="#CefSharp" class="headerlink" title="CefSharp"></a>CefSharp</h2><p><a href="https://github.com/chromiumembedded/cef" target="_blank" rel="noopener">CEF</a>全称：<strong>Chromium Embedded Framework</strong>。<br>CefSharp是什么？<a href="http://cefsharp.github.io/" target="_blank" rel="noopener">官网</a>上它是这么写的：CefSharp是在C#或VB.NET应用程序中嵌入全功能标准兼容web浏览器的最简单方法。CefSharp有WinForms和WPF应用程序的浏览器控件，也有自动化项目的无标题（屏幕外）版本。CefSharp基于Chromium嵌入式框架，这是Google Chrome的开源版本。<br>说白了，就是基于C#或VB语言的<strong>可编程浏览器</strong>（当然CEF也有其他语言的，如<a href="https://bitbucket.org/chromiumembedded/java-cef" target="_blank" rel="noopener">Java</a>，<a href="https://github.com/cztomczak/cef2go" target="_blank" rel="noopener">Go</a>）。</p>
<a id="more"></a>

<p>本文环境：</p>
<ul>
<li>CefSharp版本：75.1.143</li>
<li>VS版本：2015</li>
<li>操作系统：Windows 10专业版</li>
</ul>
<h2 id="WPF引入CefSharp"><a href="#WPF引入CefSharp" class="headerlink" title="WPF引入CefSharp"></a>WPF引入CefSharp</h2><p>CefSharp有现成的NuGet包，先引入到项目中，然后在XAML中添加响应控件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;cefSharp:ChromiumWebBrowser Name=&quot;myChrome&quot; Loaded=&quot;myChrome_Loaded&quot;/&gt;</span><br></pre></td></tr></table></figure>

<p>添加<code>cefSharp</code>命名空间：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">xmlns:cefSharp=&quot;clr-namespace:CefSharp.Wpf;assembly=CefSharp.Wpf&quot;</span><br></pre></td></tr></table></figure>

<p>在<code>myChrome_Loaded</code>事件中，我们让浏览器打开百度首页：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void myChrome_Loaded(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    String url = &quot;https://www.baidu.com&quot;;</span><br><span class="line">    myChrome.Load(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，我们就可以看到百度首页了。</p>
<h2 id="截断请求"><a href="#截断请求" class="headerlink" title="截断请求"></a>截断请求</h2><p>根据<a href="http://cefsharp.github.io/api/75.1.x/html/T_CefSharp_Handler_RequestHandler.htm" target="_blank" rel="noopener">文档</a>，我们可以看到<code>RequestHandler</code>类中的方法<code>GetResourceRequestHandler</code>会在每次发请求前被调用：</p>
<blockquote>
<p>GetResourceRequestHandler<br>Called on the CEF IO thread before a resource request is initiated.</p>
</blockquote>
<p><code>RequestHandler</code>类是<a href="http://cefsharp.github.io/api/75.1.x/html/T_CefSharp_IRequestHandler.htm" target="_blank" rel="noopener"><code>IRequestHandler</code></a>接口的默认实现，我们自定义请求可以继承这个类：</p>
<blockquote>
<p>Default implementation of IRequestHandler.<br>This class provides default implementations of the methods from IRequestHandler, therefore providing a convenience base class for any custom request handler.</p>
</blockquote>
<p>所以我们可以创建一个继承<code>RequestHandler</code>的类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">class CustomRequestHandler : RequestHandler</span><br><span class="line">&#123;</span><br><span class="line">    protected override IResourceRequestHandler GetResourceRequestHandler(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, bool isNavigation, bool isDownload, string requestInitiator, ref bool disableDefaultHandling)</span><br><span class="line">    &#123;</span><br><span class="line">        return new CustomResourceRequestHandler();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>GetResourceRequestHandler</code>是我们要重点关注的方法，里头我们返回了一个类实例，在这个类中我们就可以<strong>自定义请求</strong>。<br>新版的CefSharp（75版本之后）把<code>OnBeforeResourceLoad</code>方法移动到了<code>IResourceRequestHandler</code>接口里（<a href="http://cefsharp.github.io/api/75.1.x/html/T_CefSharp_IResourceRequestHandler.htm" target="_blank" rel="noopener">文档</a>），同样的CefSharp也提供了这个接口的默认实现：<code>ResourceRequestHandler</code>，所以我们还需要一个继承<code>ResourceRequestHandler</code>的类（也就是上面代码中的<code>CustomResourceRequestHandler</code>类）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CustomResourceRequestHandler : ResourceRequestHandler</span><br><span class="line">&#123;</span><br><span class="line">    protected override CefReturnValue OnBeforeResourceLoad(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, IRequestCallback callback)</span><br><span class="line">    &#123;</span><br><span class="line">        var headers = request.Headers;</span><br><span class="line">        headers[&quot;Custom-Header&quot;] = &quot;My Custom Header&quot;;</span><br><span class="line">        request.Headers = headers;</span><br><span class="line"></span><br><span class="line">        return CefReturnValue.Continue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最后，把自定义请求类设置到CefSharp实例中</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myChrome.RequestHandler = new CustomRequestHandler();</span><br></pre></td></tr></table></figure>

<p>通过Fiddler这样的抓包工具，我们就会发现，自定义的<code>Custom-Header</code>头已经加上了</p>
<p><img src="https://s2.ax1x.com/2019/11/16/MBE5Dg.png" alt="detail"></p>
<h3 id="添加自定义查询参数"><a href="#添加自定义查询参数" class="headerlink" title="添加自定义查询参数"></a>添加自定义查询参数</h3><p>上面的例子中，我们添加了自定义的header，如果我们想改写<code>URL</code>添加一些自定义的查询参数呢，譬如<code>name=foo</code>？这里有个坑，如果我们简单地把<code>request.Url += &quot;?name=foo&quot;</code>，这样会导致无限重定向（因为改了Url就会重定向）。解决方法也很简单，就是判断一下我们想要的查询参数是否已经在<code>Url</code>里了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected override CefReturnValue OnBeforeResourceLoad(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, IRequestCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    var headers = request.Headers;</span><br><span class="line">    headers[&quot;Custom-Header&quot;] = &quot;My Custom Header&quot;;</span><br><span class="line">    request.Headers = headers;</span><br><span class="line"></span><br><span class="line">    if (!request.Url.Contains(&quot;name=foo&quot;))</span><br><span class="line">    &#123;</span><br><span class="line">        request.Url += &quot;?&quot; + &quot;name=foo&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return CefReturnValue.Continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="添加自定义Body"><a href="#添加自定义Body" class="headerlink" title="添加自定义Body"></a>添加自定义Body</h3><p>根据<a href="http://cefsharp.github.io/api/75.1.x/html/T_CefSharp_IRequest.htm" target="_blank" rel="noopener">IRequest</a>的文档，我们可以利用<code>PostData</code>属性：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">protected override CefReturnValue OnBeforeResourceLoad(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, IRequestCallback callback)</span><br><span class="line">&#123;</span><br><span class="line">    var headers = request.Headers;</span><br><span class="line">    headers[&quot;Custom-Header&quot;] = &quot;My Custom Header&quot;;</span><br><span class="line">    request.Headers = headers;</span><br><span class="line"></span><br><span class="line">    string body = &quot;name=foo&quot;;</span><br><span class="line">    byte[] byteArray = System.Text.Encoding.UTF8.GetBytes(body);</span><br><span class="line"></span><br><span class="line">    request.InitializePostData();</span><br><span class="line">    var element = request.PostData.CreatePostDataElement();</span><br><span class="line">    element.Bytes = byteArray;</span><br><span class="line">    request.PostData.AddElement(element);</span><br><span class="line"></span><br><span class="line">    return CefReturnValue.Continue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>通过Fiddler这样的抓包工具，我们就会发现，POST 数据已经加上了：</p>
<p><img src="https://s2.ax1x.com/2019/11/30/QVjqp9.png" alt="detail"></p>
<h2 id="加载本地HTML字符串"><a href="#加载本地HTML字符串" class="headerlink" title="加载本地HTML字符串"></a>加载本地HTML字符串</h2><p>有时候，我们可能需要渲染一个内存中的HTML字符串，CefSharp也提供这样的接口，代码很简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void myChrome_Loaded(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    string html = @&quot;&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">    &lt;head&gt;</span><br><span class="line">        &lt;title&gt;这是个标题&lt;/title&gt;</span><br><span class="line">        &lt;meta charset=&apos;utf-8&apos; /&gt;</span><br><span class="line">        &lt;meta name = &apos;viewport&apos; content = &apos;width=device-width, initial-scale=1&apos; /&gt;</span><br><span class="line">     &lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        &lt;h1&gt;这是一个一个简单的HTML&lt;/h1&gt;</span><br><span class="line">        &lt;p&gt;Hello World！&lt;/p &gt;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;&quot;;</span><br><span class="line">    String url = &quot;https://www.baidu.com&quot;;</span><br><span class="line">    myChrome.LoadHtml(html, url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="截断响应"><a href="#截断响应" class="headerlink" title="截断响应"></a>截断响应</h2><p>这里的关键在于<code>GetResourceResponseFilter</code>方法，它的签名如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">IResponseFilter GetResourceResponseFilter(</span><br><span class="line">	IWebBrowser chromiumWebBrowser,</span><br><span class="line">	IBrowser browser,</span><br><span class="line">	IFrame frame,</span><br><span class="line">	IRequest request,</span><br><span class="line">	IResponse response</span><br><span class="line">)</span><br></pre></td></tr></table></figure>

<p>它返回了一个<code>IResponseFilter</code>接口，在这个接口中，我们可以截取到请求响应的内容。在CefSharp最新版本中，<code>GetResourceResponseFilter</code>已经被放入到<code>IResourceRequestHandler</code>接口中，<a href="http://cefsharp.github.io/api/75.1.x/html/M_CefSharp_IResourceRequestHandler_GetResourceResponseFilter.htm" target="_blank" rel="noopener">最新文档</a>。<br>下面我放了一个截断网页XHR请求的例子：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class TestJsonFilter : IResponseFilter</span><br><span class="line">&#123;</span><br><span class="line">    public List&lt;byte&gt; DataAll = new List&lt;byte&gt;();</span><br><span class="line"></span><br><span class="line">    public FilterStatus Filter(System.IO.Stream dataIn, out long dataInRead, System.IO.Stream dataOut, out long dataOutWritten)</span><br><span class="line">    &#123;</span><br><span class="line">        try</span><br><span class="line">        &#123;</span><br><span class="line">            if (dataIn == null || dataIn.Length == 0)</span><br><span class="line">            &#123;</span><br><span class="line">                dataInRead = 0;</span><br><span class="line">                dataOutWritten = 0;</span><br><span class="line"></span><br><span class="line">                return FilterStatus.Done;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            dataInRead = dataIn.Length;</span><br><span class="line">            dataOutWritten = Math.Min(dataInRead, dataOut.Length);</span><br><span class="line"></span><br><span class="line">            dataIn.CopyTo(dataOut);</span><br><span class="line">            dataIn.Seek(0, SeekOrigin.Begin);</span><br><span class="line">            byte[] bs = new byte[dataIn.Length];</span><br><span class="line">            dataIn.Read(bs, 0, bs.Length);</span><br><span class="line">            DataAll.AddRange(bs);</span><br><span class="line"></span><br><span class="line">            dataInRead = dataIn.Length;</span><br><span class="line">            dataOutWritten = dataIn.Length;</span><br><span class="line"></span><br><span class="line">            return FilterStatus.NeedMoreData;</span><br><span class="line">        &#125;</span><br><span class="line">        catch (Exception ex)</span><br><span class="line">        &#123;</span><br><span class="line">            dataInRead = dataIn.Length;</span><br><span class="line">            dataOutWritten = dataIn.Length;</span><br><span class="line"></span><br><span class="line">            return FilterStatus.Done;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public bool InitFilter()</span><br><span class="line">    &#123;</span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class FilterManager</span><br><span class="line">&#123;</span><br><span class="line">    private static Dictionary&lt;string, IResponseFilter&gt; dataList = new Dictionary&lt;string, IResponseFilter&gt;();</span><br><span class="line"></span><br><span class="line">    public static IResponseFilter CreateFilter(string guid)</span><br><span class="line">    &#123;</span><br><span class="line">        lock (dataList)</span><br><span class="line">        &#123;</span><br><span class="line">            var filter = new TestJsonFilter();</span><br><span class="line">            dataList.Add(guid, filter);</span><br><span class="line"></span><br><span class="line">            return filter;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static IResponseFilter GetFileter(string guid)</span><br><span class="line">    &#123;</span><br><span class="line">        lock (dataList)</span><br><span class="line">        &#123;</span><br><span class="line">        </span><br><span class="line">            if (dataList.ContainsKey(guid))  // 这里要检测key存在，不然会报异常，会导致ContextSwitchDeadlock</span><br><span class="line">            &#123;</span><br><span class="line">                return dataList[guid];</span><br><span class="line">            &#125;</span><br><span class="line">            else</span><br><span class="line">            &#123;</span><br><span class="line">                return null;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class CustomResourceRequestHandler : ResourceRequestHandler</span><br><span class="line">&#123;</span><br><span class="line">    protected override CefReturnValue OnBeforeResourceLoad(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, IRequestCallback callback)</span><br><span class="line">    &#123;</span><br><span class="line">        // 截断请求的代码...</span><br><span class="line">        return CefReturnValue.Continue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    protected override IResponseFilter GetResourceResponseFilter(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, IResponse response)</span><br><span class="line">    &#123;</span><br><span class="line">        if (!(request.ResourceType == ResourceType.Xhr))  // 不是XHR类型就不去过滤</span><br><span class="line">        &#123;</span><br><span class="line">            return null;</span><br><span class="line">        &#125;</span><br><span class="line">        var filer = FilterManager.CreateFilter(request.Identifier.ToString());</span><br><span class="line">        return filer;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    protected override void OnResourceLoadComplete(IWebBrowser chromiumWebBrowser, IBrowser browser, IFrame frame, IRequest request, IResponse response, UrlRequestStatus status, long receivedContentLength)</span><br><span class="line">    &#123;</span><br><span class="line">        var filer = FilterManager.GetFileter(request.Identifier.ToString()) as TestJsonFilter;</span><br><span class="line">        if (filer != null)</span><br><span class="line">        &#123;</span><br><span class="line">            Console.WriteLine(ASCIIEncoding.UTF8.GetString(filer.DataAll.ToArray()));  // 打印body内容</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">private void myChrome_Loaded(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    String url = &quot;https://github.com/salamander-mh&quot;;  // github首页上有ajax请求，可以看效果</span><br><span class="line">    myChrome.Load(url);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，在<code>输出</code>视图就可以看到Ajax请求的body数据。</p>
<h2 id="截取cookie"><a href="#截取cookie" class="headerlink" title="截取cookie"></a>截取cookie</h2><p>建立Cookie读取对象，继承接口 ICookieVisitor</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class CookieVisitor : CefSharp.ICookieVisitor</span><br><span class="line">&#123;</span><br><span class="line">    public event Action&lt;CefSharp.Cookie&gt; SendCookie;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    public bool Visit(Cookie cookie, int count, int total, ref bool deleteCookie)</span><br><span class="line">    &#123;</span><br><span class="line">        deleteCookie = false;</span><br><span class="line">        if (SendCookie != null)</span><br><span class="line">        &#123;</span><br><span class="line">            SendCookie(cookie);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return true;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Dispose()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在browser事件中进行处理</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void browser_FrameLoadEnd(object sender, CefSharp.FrameLoadEndEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    var cookieManager = myChrome.GetCookieManager();</span><br><span class="line"></span><br><span class="line">    CookieVisitor visitor = new CookieVisitor();</span><br><span class="line">    visitor.SendCookie += visitor_SendCookie;</span><br><span class="line">    cookieManager.VisitAllCookies(visitor);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>回调事件</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void visitor_SendCookie(CefSharp.Cookie obj)</span><br><span class="line">&#123;</span><br><span class="line">    Console.WriteLine(&quot;获取cookie：&quot; + obj.Domain.TrimStart(&apos;.&apos;) + &quot;^&quot; + obj.Name + &quot;^&quot; + obj.Value + &quot;$&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设置CefSharp实例事件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">private void myChrome_Loaded(object sender, RoutedEventArgs e)</span><br><span class="line">&#123;</span><br><span class="line">    String url = &quot;https://www.baidu.com&quot;;</span><br><span class="line">    myChrome.Load(url);</span><br><span class="line">    myChrome.FrameLoadEnd += browser_FrameLoadEnd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，在<code>输出</code>视图就可以看到<strong>cookie</strong>数据了。</p>
<h2 id="Javascript交互"><a href="#Javascript交互" class="headerlink" title="Javascript交互"></a>Javascript交互</h2><h3 id="C-执行js方法"><a href="#C-执行js方法" class="headerlink" title="C#执行js方法"></a>C#执行js方法</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">myChrome.GetBrowser().MainFrame.ExecuteJavaScriptAsync(&quot;document.getElementById(&apos;testid&apos;).click();&quot;);</span><br></pre></td></tr></table></figure>

<p>以上代码就会触发id为<code>testid</code>的元素的<code>click</code>事件。<br>注意：<strong>脚本是在 Frame 级别执行</strong>，页面永远至少有一个Frame（ MainFrame ）。</p>
<h3 id="获取Javascript方法结果"><a href="#获取Javascript方法结果" class="headerlink" title="获取Javascript方法结果"></a>获取Javascript方法结果</h3><p>这里需要使用<code>Task&lt;JavascriptResponse&gt; EvaluateScriptAsync(string script, TimeSpan? timeout)</code>方法。 JavaScript代码是异步执行的，因此使用.NET Task 类返回一个响应，其中包含错误消息，结果和一个成功（bool）标志。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// Get Document Height  </span><br><span class="line">var task = frame.EvaluateScriptAsync(&quot;(function() &#123; var body = document.body, html = document.documentElement; return  Math.max( body.scrollHeight, body.offsetHeight, html.clientHeight, html.scrollHeight, html.offsetHeight ); &#125;)();&quot;, null);</span><br><span class="line">  </span><br><span class="line">task.ContinueWith(t =&gt;  </span><br><span class="line">&#123;  </span><br><span class="line">    if (!t.IsFaulted)  </span><br><span class="line">    &#123;  </span><br><span class="line">        var response = t.Result;  </span><br><span class="line">        EvaluateJavaScriptResult = response.Success ? (response.Result ?? &quot;null&quot;) : response.Message;  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;, TaskScheduler.FromCurrentSynchronizationContext());</span><br></pre></td></tr></table></figure>

<h2 id="资源清理"><a href="#资源清理" class="headerlink" title="资源清理"></a>资源清理</h2><p>关闭应用，发现<code>CefSharp.BrowserSubprocess.exe</code>进程会发现没有结束，其实在退出事件中，我们需要调用<code>Cef.Shutdown()</code>方法</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">try  </span><br><span class="line">&#123;  </span><br><span class="line">    if (browser != null)  </span><br><span class="line">    &#123;  </span><br><span class="line">        browser.Dispose();  </span><br><span class="line">        Cef.Shutdown();  </span><br><span class="line">    &#125;  </span><br><span class="line">&#125;  </span><br><span class="line">catch &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>示例代码<a href="http://file.51lucy.com/BroswerTest.rar" target="_blank" rel="noopener">下载</a></p>
<p>参考：</p>
<ul>
<li><a href="https://stackoverflow.com/questions/31250797/chromium-send-custom-header-info-on-initial-page-load-c-sharp" target="_blank" rel="noopener">StackOverflow</a></li>
<li><a href="https://stackoverflow.com/questions/40944056/how-to-read-the-json-response-content-from-a-xmlhttprequest/43652932#43652932" target="_blank" rel="noopener">How to read the JSON response content from a XMLHttpRequest?</a></li>
<li><a href="https://github.com/cefsharp/CefSharp/wiki/CefSharp%E4%B8%AD%E6%96%87%E5%B8%AE%E5%8A%A9%E6%96%87%E6%A1%A3" target="_blank" rel="noopener"><strong>CefSharp中文帮助文档</strong></a></li>
</ul>
]]></content>
      <categories>
        <category>C#</category>
      </categories>
      <tags>
        <tag>C#</tag>
        <tag>CefSharp</tag>
        <tag>WPF</tag>
      </tags>
  </entry>
  <entry>
    <title>Elasticsearch简单使用</title>
    <url>/2020/04/21/Elasticsearch_to_know/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/04/23/Jd4MOf.png" alt></p>
<h2 id="Elasticsearch"><a href="#Elasticsearch" class="headerlink" title="Elasticsearch"></a>Elasticsearch</h2><p><code>Elasticsearch</code>是一个基于Lucene的搜索服务器（Lucene可以被认为是迄今为止最先进、性能最好的、功能最全的搜索引擎库）。Elasticsearch使用Java编写并使用Lucene来建立索引并实现搜索功能，但是它的目的是通过简单连贯的<code>RESTful API</code>让全文搜索变得简单并隐藏Lucene的复杂性。 </p>
<a id="more"></a>


<h2 id="安装单节点Elasticsearch"><a href="#安装单节点Elasticsearch" class="headerlink" title="安装单节点Elasticsearch"></a>安装单节点Elasticsearch</h2><p><code>Elasticsearch</code>是用Java语言开发的，所以你需要安装Java环境，但为了方便起见，我这里选用了<code>Docker</code>安装ES（其实ES官网也有用Docker安装的<a href="https://www.elastic.co/guide/en/elasticsearch/reference/7.5/docker.html#docker" target="_blank" rel="noopener">例子</a>，这里我就把它写成了docker-compose服务）。<br>docker-compose.yml</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;2.2&apos;</span><br><span class="line">services:</span><br><span class="line">  es:</span><br><span class="line">    image: elasticsearch:6.7.0</span><br><span class="line">    container_name: es0</span><br><span class="line">    environment:</span><br><span class="line">      - node.name=es0</span><br><span class="line">      - &quot;discovery.type=single-node&quot;</span><br><span class="line">      - node.data=true</span><br><span class="line">      - bootstrap.memory_lock=true</span><br><span class="line">      - network.host=0.0.0.0</span><br><span class="line">      - &quot;ES_JAVA_OPTS=-Xms1g -Xmx1g&quot;</span><br><span class="line">    ulimits:</span><br><span class="line">      memlock:</span><br><span class="line">        soft: -1</span><br><span class="line">        hard: -1</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data:/usr/share/elasticsearch/data</span><br><span class="line">    ports:</span><br><span class="line">      - 9200:9200</span><br><span class="line">      - 9300:9300</span><br></pre></td></tr></table></figure>

<p>Elasticsearch 启动后，启动了两个端口 9200 和 9300：</p>
<ul>
<li>9200 端口：HTTP RESTful 接口的通讯端口</li>
<li>9300 端口：TCP 通讯端口，用于集群间节点通信和与 Java 客户端通信的端口</li>
</ul>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">- bootstrap.memory_lock=true</span><br><span class="line">...</span><br><span class="line">ulimits:</span><br><span class="line">  memlock:</span><br><span class="line">    soft: -1</span><br><span class="line">    hard: -1</span><br></pre></td></tr></table></figure>

<p>这两部分是为了禁止使用swap内存，因为当jvm开始swapping时ES的效率会降低。  </p>
<p><code>-Xms1g -Xmx1g</code>是设置了JVM的初始堆大小和最大堆大小（具体参数含义可以参考<a href="https://www.cnblogs.com/redcreen/archive/2011/05/04/2037057.html" target="_blank" rel="noopener">这里</a>）。 </p>
<p>启动之前还是需要调高JVM线程数限制数量，不然启动会报错</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">vim /etc/sysctl.conf</span><br><span class="line"># 添加这个</span><br><span class="line">vm.max_map_count=262144 </span><br><span class="line"># 保存后执行这个命令</span><br><span class="line">sysctl -p</span><br></pre></td></tr></table></figure>

<h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><p>在进一步使用 Elasticsearch 之前，让我们先了解几个关键概念。</p>
<p>在逻辑层面：  </p>
<ul>
<li>Index (索引)和Type (类型)：这里的 Index 是名词，在之前开始的时候，我们把<strong>索引（index）和类型（type）</strong>类比于SQL数据库中的 database 和 table，但是这样类比是不合适的。刚开始的ES版本一个索引可以有多个类型，在ES6之后每个索引只能有一个类型，所以他们现在都可以当做一张数据表了。</li>
<li>Document (文档)：Elasticsearch 使用 JSON 文档来表示一个对象，就像是关系数据库中一个 Table 中的一行数据</li>
<li>Field (字段)：每个文档包含多个字段，类似关系数据库中一个 Table 的列</li>
</ul>
<blockquote>
<blockquote>
<blockquote>
</blockquote>
<p>为什么要移除映射类型<br>开始的时候，我们把<strong>索引（index）和类型（type）</strong>类比于SQL数据库中的 database 和 table，但是这样类比是不合适的。在SQL数据库中，表之间是相互独立的。一个表中的各列并不会影响到其它表中的同名的列。而在映射类型（mapping type）中却不是这样的。<br>在同一个 Elasticsearch 索引中，其中不同映射类型中的同名字段在内部是由同一个 Lucene 字段来支持的。换句话说，使用上面的例子，user 类型中的 user_name 字段与 tweet 类型中的 user_name 字段是完全一样的，并且两个 user_name 字段在两个类型中必须具有相同的映射（定义）。<br>这会在某些情况下导致一些混乱，比如，在同一个索引中，当你想在其中的一个类型中将 deleted 字段作为 date 类型，而在另一个类型中将其作为 boolean 字段。<br>在此之上需要考虑一点，如果同一个索引中存储的各个实体如果只有很少或者根本没有同样的字段，这种情况会导致稀疏数据，并且会影响到Lucene的高效压缩数据的能力</p>
</blockquote>
</blockquote>
<p>在物理层面：  </p>
<ul>
<li>Node (节点)：node 是一个运行着的 Elasticsearch 实例，一个 node 就是一个单独的 server</li>
<li>Cluster (集群)：cluster 是多个 node 的集合</li>
<li>Shard (分片)：数据分片，一个 index 可能会存在于多个 shard</li>
</ul>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>下面，我们将创建一个存储电影信息的 Document：</p>
<ul>
<li>Index 的名称为 movie</li>
<li>Type 为 adventure</li>
<li>Document 有两个字段：name 和 actors</li>
</ul>
<p>我们使用 Elasticsearch 提供的 RESTful API 来执行上述操作，如图所示：  </p>
<p><img src="https://s1.ax1x.com/2020/04/23/Jw9Ov6.png" alt></p>
<ul>
<li>用 url 表示一个资源，比如 /movie/adventure/1 就表示一个 index 为 movie，type 为 adventure，id 为 1 的 document</li>
<li>用 http 方法操作资源，如使用 GET 获取资源，使用 POST、PUT 新增或更新资源，使用 DELETE 删除资源等</li>
</ul>
<p>用<code>curl</code>命令实现上述操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">curl -i -X PUT &quot;localhost:9200/movie/adventure/1&quot; -H &apos;Content-Type: application/json&apos; -d &apos;&#123;&quot;name&quot;: &quot;Life of Pi&quot;, &quot;actors&quot;: [&quot;Suraj&quot;, &quot;Irrfan&quot;]&#125;&apos;</span><br></pre></td></tr></table></figure>

<p>ES6之后需要加上head<code>Content-Type: application/json</code></p>
<p>上述命令返回：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP/1.1 201 Created</span><br><span class="line">Location: /movie/adventure/1</span><br><span class="line">content-type: application/json; charset=UTF-8</span><br><span class="line">content-length: 158</span><br><span class="line"></span><br><span class="line">&#123;&quot;_index&quot;:&quot;movie&quot;,&quot;_type&quot;:&quot;adventure&quot;,&quot;_id&quot;:&quot;4&quot;,&quot;_version&quot;:1,&quot;result&quot;:&quot;created&quot;,&quot;_shards&quot;:&#123;&quot;total&quot;:2,&quot;successful&quot;:1,&quot;failed&quot;:0&#125;,&quot;_seq_no&quot;:1,&quot;_primary_term&quot;:1&#125;</span><br></pre></td></tr></table></figure>

<h2 id="elasticsearch-yml配置说明"><a href="#elasticsearch-yml配置说明" class="headerlink" title="elasticsearch.yml配置说明"></a>elasticsearch.yml配置说明</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#集群的名称</span><br><span class="line">cluster.name: es6.2</span><br><span class="line">#节点名称,其余两个节点分别为node-2 和node-3</span><br><span class="line">node.name: node-1</span><br><span class="line">#指定该节点是否有资格被选举成为master节点，默认是true，es是默认集群中的第一台机器为master，如果这台机挂了就会重新选举master</span><br><span class="line">node.master: true</span><br><span class="line">#允许该节点存储数据(默认开启)</span><br><span class="line">node.data: true</span><br><span class="line">#索引数据的存储路径</span><br><span class="line">path.data: /usr/local/elk/elasticsearch/data</span><br><span class="line">#日志文件的存储路径</span><br><span class="line">path.logs: /usr/local/elk/elasticsearch/logs</span><br><span class="line">#设置为true来锁住内存。因为内存交换到磁盘对服务器性能来说是致命的，当jvm开始swapping时es的效率会降低，所以要保证它不swap</span><br><span class="line">bootstrap.memory_lock: true</span><br><span class="line">#绑定的ip地址</span><br><span class="line">network.host: 0.0.0.0</span><br><span class="line">#设置对外服务的http端口，默认为9200</span><br><span class="line">http.port: 9200</span><br><span class="line"># 设置节点间交互的tcp端口,默认是9300 </span><br><span class="line">transport.tcp.port: 9300</span><br><span class="line">#Elasticsearch将绑定到可用的环回地址，并将扫描端口9300到9305以尝试连接到运行在同一台服务器上的其他节点。</span><br><span class="line">#这提供了自动集群体验，而无需进行任何配置。数组设置或逗号分隔的设置。每个值的形式应该是host:port或host</span><br><span class="line">#（如果没有设置，port默认设置会transport.profiles.default.port 回落到transport.tcp.port）。</span><br><span class="line">#请注意，IPv6主机必须放在括号内。默认为127.0.0.1, [::1]</span><br><span class="line">discovery.zen.ping.unicast.hosts: [&quot;192.168.8.101:9300&quot;, &quot;192.168.8.103:9300&quot;, &quot;192.168.8.104:9300&quot;]</span><br><span class="line">#如果没有这种设置,遭受网络故障的集群就有可能将集群分成两个独立的集群 - 分裂的大脑 - 这将导致数据丢失</span><br><span class="line">discovery.zen.minimum_master_nodes: 3</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/qq_34021712/article/details/79330028" target="_blank" rel="noopener">Elasticsearch6.2集群搭建</a></li>
<li><a href="https://www.cnblogs.com/sunsky303/p/9438737.html" target="_blank" rel="noopener">Elasticsearch入门，这一篇就够了</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Elasticsearch</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之GC</title>
    <url>/2020/04/01/Java_GC/</url>
    <content><![CDATA[<p><img src="/images/gc-java.png" alt="upload successful">  </p>
<h2 id="GC"><a href="#GC" class="headerlink" title="GC"></a>GC</h2><p>GC就是垃圾回收（<code>Garbage Collection</code>），如果你写过C++或者C程序的，你就会知道<code>new</code>一个数据后，就需要<code>delete</code>它的内存，这就是手动管理内存，但这样如果你粗心点的话，就容易造成内存泄露，所以就有了自动垃圾回收，也就我们这里所讨论的GC。Java的GC会对JVM（Java Virtual Machine）中的内存进行标记，并确定哪些内存需要回收，根据一定的回收策略，自动的回收内存，永不停息（Nerver Stop）的保证JVM中的内存空间，防止出现内存泄露和溢出问题。<br>其实GC很早就有了，1960年诞生于MIT的<strong>Lisp</strong>是第一门真正使用内存动态分配和垃圾收集技术的语言。</p>
<a id="more"></a>


<h2 id="内存布局"><a href="#内存布局" class="headerlink" title="内存布局"></a>内存布局</h2><p><img src="/images/java-memory-layout.png" alt="upload successful">  </p>
<p>JVM 在执行 Java 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。有的区域依赖线程的启动和结束而建立和销毁，这样的区域可看作是线程私有的区域（Per-Thread Data Area）；其他的区域则随着虚拟机进程的启动而存在，可以看做是线程间共享的区域。  </p>
<p>具体而言，JVM 的运行时数据区域包括如下：  </p>
<ul>
<li><strong>程序计数器</strong>（Program Counter Register）：线程私有的数据区域，保存当前正在执行的虚拟机指令的地址；</li>
<li><strong>Java 虚拟机栈</strong>（Java Virtual Machine Stack）：线程私有的数据区域，每个栈帧中存放当前执行方法的本地变量及返回地址；</li>
<li><strong>Java 堆（Heap）</strong>：线程共享的数据区域，对象及数组的分配空间；</li>
<li><strong>方法区</strong>（Method Area）：线程共享的数据区域，存放由类加载器加载的类型信息、常量及静态变量；</li>
<li><strong>本地方法栈（Native Method Stack）</strong>：用于 Native 方法的方法栈  </li>
</ul>
<p><strong>运行时常量池</strong>（Runtime Constant Pool）是方法区的一部分，用于存储编译器生成的常量和引用。一般来说，常量的分配在编译时就能确定，但也不全是，也可以存储在运行时期产生的常量。比如String类的intern（）方法，作用是String类维护了一个常量池，如果调用的字符”hello”已经在常量池中，则直接返回常量池中的地址，否则新建一个常量加入池中，并返回地址。</p>
<h2 id="GC大致过程"><a href="#GC大致过程" class="headerlink" title="GC大致过程"></a>GC大致过程</h2><p><img src="/images/pasted-3.png" alt="upload successful"> </p>
<p>在JVM的堆内存中，被分为了年轻代（Young Generation）和老年代（Old Generation、持久代（Permanent Generation）。其中年轻代又被分为Eden区和survivor区，而survivor区又被分为大小相等的2个区，分别称为S1区和S2区。持久代在<strong>Sun Hotpot虚拟机</strong>中就是指方法区（有些JVM根本就没有持久代这一说法）</p>
<p>当程序需要在堆上分配内存时，会首先在eden区进行分配。</p>
<p>当eden区内存已满无法再分配对象时，会触发第一次minor gc，将eden区存活的对象拷贝到其中一个survivor区，比如S1，并把eden区的内存清空，以备使用。</p>
<p>当eden区的内存再次被使用完时，会触发第二次minor gc，将eden区和S1区中存活的对象拷贝到S2区，并将eden区和S1区的内存清空以备使用。在有的书中会提到from区和to区，其实from区和to区是相对而言的，当把S1区的内容拷贝到S2区时，S1为from区，S2为to区。而将S2区的内容拷贝到S1时，S2为from区，S1为to区。</p>
<p>当eden区的内存再次被用完时，会触发第三次minor gc，将eden区和S2区存活的对象拷贝到S1区，并清空eden区和S2区的内存，以备使用。</p>
<p>上述过程循环往复。</p>
<p>当某个对象经历了一次minor gc并且存活下来，没有被清理掉，则说这个对象长大了一岁。当某个对象的年龄大于一定阈值，通常是15岁时，该对象在下次minor gc时会被放到老年代中。</p>
<p>当老年代中的内存不够用时，会触发full gc。</p>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>GC</tag>
      </tags>
  </entry>
  <entry>
    <title>一步步自己做个Docker之Go调用Namespace</title>
    <url>/2020/03/26/Docker_Go_Namespace/</url>
    <content><![CDATA[<p><img src="/images/docker-logo.png" alt="docker logo"></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>Golang版本：1.12.13</li>
</ul>
<h2 id="Golang"><a href="#Golang" class="headerlink" title="Golang"></a>Golang</h2><p>Go语言是Google开发的一种静态类型、编译型的高级语言，它设计的蛮简单的，学过C的话，其实上手Go很快的，当然相比于C的话，Go有垃圾回收和并发支持，所以写起来心智负担更低一点。<br>对于Go的安装和配置，我以前写过一篇文章——<a href="https://segmentfault.com/a/1190000008487280" target="_blank" rel="noopener">go语言基本配置</a>，我这里就不在赘述了。Go1.11增加了<code>go modules</code>，使用它的话，就没必要一定要把代码放到<code>GOPATH</code>下面啦<del>(≧▽≦)/</del>。 <code>go modules</code>详细<br>使用请参考<a href="https://juejin.im/post/5c8e503a6fb9a070d878184a" target="_blank" rel="noopener">go mod 使用</a>。  </p>
<a id="more"></a>

<h2 id="Go调用Namespace"><a href="#Go调用Namespace" class="headerlink" title="Go调用Namespace"></a>Go调用Namespace</h2><p>其实对于Namespace这种系统调用，使用C语言描述是最好的（<a href="/2019/11/28/docker-Linux-Namespace-intro/">上一篇文章</a>就是用C写的示例），但是C比较难，而且Docker也是用Go是实现的，所以我后面的文章都会用Go来写示例代码。<br>这里我先写了一个<code>UTS Namespace</code>的例子，<code>UTS Namespace</code>主要用来隔离<code>nodename</code>和<code>domainname</code>这两个系统标识：   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;os/exec&quot;</span><br><span class="line">	&quot;syscall&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;sh&quot;)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags: syscall.CLONE_NEWUTS,</span><br><span class="line">	&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	if err := cmd.Run(); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>exec.Command(&quot;sh&quot;)</code>是指定了fork出来的新进程内的初始命令，<code>cmd.SysProcAttr</code>这行就是设置了系统调用函数，Go帮我们封装了<a href="http://man7.org/linux/man-pages/man2/clone.2.html" target="_blank" rel="noopener">clone()</a>函数，<code>syscall.CLONE_NEWUTS</code>这个标识符标明创建一个<code>UTS Namespace</code>。<br><code>go build .</code>编译代码后，执行程序时我们会遇到错误<strong>fork/exec /bin/sh: operation not permitted</strong>，这是因为<code>clone()</code>函数需要<code>CAP_SYS_ADMIN</code>权限（这个<a href="https://www.v2ex.com/t/618961" target="_blank" rel="noopener">问题</a>我在v站上问过），解决方法是添加设置 <code>uid</code> 映射： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;os/exec&quot;</span><br><span class="line">	&quot;syscall&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;sh&quot;)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags:</span><br><span class="line">			syscall.CLONE_NEWUTS |</span><br><span class="line">			syscall.CLONE_NEWUSER,</span><br><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getuid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getgid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// set identify for this demo</span><br><span class="line">	cmd.Env = []string&#123;&quot;PS1=-[namespace-process]-# &quot;&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	if err := cmd.Run(); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我增加了<code>CLONE_NEWUSER</code>标识，让新进程在<code>User Namespace</code>中变成root用户。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./uts-easy </span><br><span class="line">-[namespace-process]-# id</span><br><span class="line">uid=0(root) gid=0(root) groups=0(root),65534(nogroup)</span><br><span class="line">-[namespace-process]-# hostname -b bird</span><br><span class="line">-[namespace-process]-# hostname</span><br><span class="line">bird</span><br></pre></td></tr></table></figure>

<p>启动另一个shell，查看宿主机上<code>hostname</code>:   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ hostname</span><br><span class="line">salamander-PC</span><br></pre></td></tr></table></figure>

<p>可以看到，外部的<code>hostname</code>并没有被内部的修改所影响，这里我们大致感受了下<code>UTS Namespace</code>的作用。</p>
<h2 id="增加IPC-Namespace"><a href="#增加IPC-Namespace" class="headerlink" title="增加IPC Namespace"></a>增加IPC Namespace</h2><p><code>IPC Namespace</code>用来隔离<strong>System V IPC和POSIX message queues</strong>。每一个<code>IPC Namespace</code>都有自己的<strong>System V IPC</strong>和<strong>POSIX message queues</strong>。我们稍微改动一下上面的代码。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;os/exec&quot;</span><br><span class="line">	&quot;syscall&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;sh&quot;)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags:</span><br><span class="line">			syscall.CLONE_NEWUTS |</span><br><span class="line">			syscall.CLONE_NEWUSER |</span><br><span class="line">			syscall.CLONE_NEWIPC,   // 增加IPC Namespace</span><br><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getuid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getgid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// set identify for this demo</span><br><span class="line">	cmd.Env = []string&#123;&quot;PS1=-[namespace-process]-# &quot;&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	if err := cmd.Run(); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>新开一个shell，在宿主机上创建一个message queue:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ipcs -q</span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息      </span><br><span class="line"></span><br><span class="line">$ ipcmk -Q</span><br><span class="line">消息队列 id：0</span><br><span class="line">$ ipcs -q</span><br><span class="line"></span><br><span class="line">--------- 消息队列 -----------</span><br><span class="line">键        msqid      拥有者  权限     已用字节数 消息      </span><br><span class="line">0xc59399dd 0          salamander 644        0            0</span><br></pre></td></tr></table></figure>

<p>运行我们自己的程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ./uts-easy </span><br><span class="line">-[namespace-process]-# ipcs -q</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br></pre></td></tr></table></figure>

<p>可以看到，在新的Namespace中，看不到宿主机上创建的<code>message queue</code>,说明IPC是隔离的。</p>
<h2 id="增加PID-Namespace"><a href="#增加PID-Namespace" class="headerlink" title="增加PID Namespace"></a>增加PID Namespace</h2><p><strong>PID Namespace</strong>是用来隔离进程ID的。我们自己进入Docker 容器的时候，就会发现里面的前台进程的PID为1，但是在容器外PID却不是1，这就是通过<strong>PID Namespace</strong>做到的。修改上述的代码，增加<code>CLONE_NEWPID</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;os/exec&quot;</span><br><span class="line">	&quot;syscall&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;sh&quot;)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags:</span><br><span class="line">			syscall.CLONE_NEWUTS |</span><br><span class="line">			syscall.CLONE_NEWUSER |</span><br><span class="line">			syscall.CLONE_NEWIPC |</span><br><span class="line">			syscall.CLONE_NEWPID, // 增加PID Namespace</span><br><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getuid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getgid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// set identify for this demo</span><br><span class="line">	cmd.Env = []string&#123;&quot;PS1=-[namespace-process]-# &quot;&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	if err := cmd.Run(); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行我们的程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> ./uts-easy </span><br><span class="line">-[namespace-process]-# echo $$</span><br><span class="line">1</span><br></pre></td></tr></table></figure>

<p>可以看到在新的<code>PID Namespace</code>中进程ID为1。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ pstree -pl | grep easy</span><br><span class="line">           |               |                       |-bash(10739)---uts-easy(10768)-+-sh(10773)</span><br><span class="line">           |               |                       |                               |-&#123;uts-easy&#125;(10769)</span><br><span class="line">           |               |                       |                               |-&#123;uts-easy&#125;(10770)</span><br><span class="line">           |               |                       |                               |-&#123;uts-easy&#125;(10771)</span><br><span class="line">           |               |                       |                               `-&#123;uts-easy&#125;(10772)</span><br></pre></td></tr></table></figure>

<p>而我们在宿主机上可以看到它实际的PID（<code>uts-easy</code>这个进程）为<strong>10768</strong>。<br>如果细心点，我们会发现，在我们的程序中使用<code>ps</code>，<code>top</code>这些命令出来的结果跟宿主机上是一样的，这是因为这些命令其实是去使用<strong>/proc</strong>这个文件夹的内容，这个就需要下面的<code>Mount Namespace</code>了。</p>
<h2 id="增加Mount-Namespace"><a href="#增加Mount-Namespace" class="headerlink" title="增加Mount Namespace"></a>增加Mount Namespace</h2><p><strong>Mount Namespace</strong>用来隔离各个进程看到的挂载点视图。在不同Namespace的进程中，看到的文件系统层次是不一样的。在<strong>Mount Namespace</strong>中调用<code>mount()</code>和<code>unmount()</code>只会影响当前Namespace内的文件系统，而对全局的文件系统是没有影响的。<br>看到这里，也许会想到<code>chroot()</code>。它也能将某一个子目录变为根节点。但是，<strong>Mount Namespace</strong>不仅能实现这个功能，而且能以更加灵活和安全的方式实现。<br>现在继续修改上述代码，增加<code>CLONE_NEWNS</code>（Mount Namespace是Linux实现的第一个Namespace类型，因为，它的系统调用参数是<strong>NEWNS</strong>，NS是New Namespace的缩写。当时人们没有意识到，以后还会有很多类型的Namespace加入Linux大家庭）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;os&quot;</span><br><span class="line">	&quot;os/exec&quot;</span><br><span class="line">	&quot;syscall&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	cmd := exec.Command(&quot;sh&quot;)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags:</span><br><span class="line">			syscall.CLONE_NEWUTS |</span><br><span class="line">			syscall.CLONE_NEWUSER |</span><br><span class="line">			syscall.CLONE_NEWIPC |</span><br><span class="line">			syscall.CLONE_NEWPID|</span><br><span class="line">			syscall.CLONE_NEWNS,  // 增加Mount Namespace</span><br><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getuid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: 0,</span><br><span class="line">				HostID:      os.Getgid(),</span><br><span class="line">				Size:        1,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	// set identify for this demo</span><br><span class="line">	cmd.Env = []string&#123;&quot;PS1=-[namespace-process]-# &quot;&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	if err := cmd.Run(); err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行程序，查看/proc的文件内容。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-[namespace-process]-# ls /proc</span><br><span class="line">1     1537  198   212   2487  2818  29    3131  329   3363  3422  3557  3793  4250  492   5273  595  62    6519  72    80    87   919        crypto       kmsg          schedstat          vmstat</span><br><span class="line">10    16    1983  213   2501  2841  2902  3139  3297  3367  3425  3571  38    430   493   53    598  6220  654   7221  8042  88   922        devices      kpagecgroup   scsi               zoneinfo</span><br><span class="line">1025  17    2     2133  2506  2846  2913  3156 ....</span><br></pre></td></tr></table></figure>

<p>这里输出的结果很多，因为<strong>/proc</strong>还是宿主机的，下面将<strong>/proc</strong> mount到我们自己的Namespace下面来：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-[namespace-process]-# mount -t proc proc /proc</span><br><span class="line">-[namespace-process]-# ls /proc</span><br><span class="line">1       buddyinfo  consoles  diskstats    fb           iomem     kcore      kpagecgroup  locks    modules  pagetypeinfo  schedstat  softirqs  sysrq-trigger  tty                vmallocinfo</span><br><span class="line">4       bus        cpuinfo   dma          filesystems  ioports   key-users  kpagecount   mdstat   mounts   partitions    scsi       stat      sysvipc        uptime             vmstat</span><br><span class="line">acpi    cgroups    crypto    driver       fs           irq       keys       kpageflags   meminfo  mtrr     pressure      self       swaps     thread-self    version            zoneinfo</span><br><span class="line">asound  cmdline    devices   execdomains  interrupts   kallsyms  kmsg       loadavg      misc     net      sched_debug   slabinfo   sys       timer_list     version_signature</span><br></pre></td></tr></table></figure>

<p>结果一下子少了很多，这里我们就可以用<strong>ps</strong>来查看系统的进程了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-[namespace-process]-# ps -ef</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">root         1     0  0 17:07 pts/1    00:00:00 sh</span><br><span class="line">root         5     1  0 17:11 pts/1    00:00:00 ps -ef</span><br></pre></td></tr></table></figure>

<p>可以看到，当前的Namespace中，sh进程是PID为1的进程。  </p>
<h2 id="增加Network-Namespace"><a href="#增加Network-Namespace" class="headerlink" title="增加Network Namespace"></a>增加Network Namespace</h2><p><strong>Network Namespace</strong>是用来隔离网络设备、IP地址端口等网络栈的Namespace。Network Namespace可以让每个容器拥有自己独立（虚拟的）网络设备，而且容器内的应用可以绑定到自己的端口，每个Namespace内的端口都不会互相冲突。在宿主机上搭建网桥后，就能很方便地实现容器之间通讯，而且不同容器上的应用可以使用相同的端口。<br>继续上述代码，加入<code>CLONE_NEWNET</code>：</p>
<figure class="highlight golang"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">	<span class="string">"log"</span></span><br><span class="line">	<span class="string">"os"</span></span><br><span class="line">	<span class="string">"os/exec"</span></span><br><span class="line">	<span class="string">"syscall"</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">	cmd := exec.Command(<span class="string">"sh"</span>)</span><br><span class="line">	cmd.SysProcAttr = &amp;syscall.SysProcAttr&#123;</span><br><span class="line">		Cloneflags:</span><br><span class="line">			syscall.CLONE_NEWUTS |</span><br><span class="line">			syscall.CLONE_NEWUSER |</span><br><span class="line">			syscall.CLONE_NEWIPC |</span><br><span class="line">			syscall.CLONE_NEWPID|</span><br><span class="line">			syscall.CLONE_NEWNS |</span><br><span class="line">			syscall.CLONE_NEWNET, <span class="comment">// 增加Network Namespace</span></span><br><span class="line">		UidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: <span class="number">0</span>,</span><br><span class="line">				HostID:      os.Getuid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">		GidMappings: []syscall.SysProcIDMap&#123;</span><br><span class="line">			&#123;</span><br><span class="line">				ContainerID: <span class="number">0</span>,</span><br><span class="line">				HostID:      os.Getgid(),</span><br><span class="line">				Size:        <span class="number">1</span>,</span><br><span class="line">			&#125;,</span><br><span class="line">		&#125;,</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set identify for this demo</span></span><br><span class="line">	cmd.Env = []<span class="keyword">string</span>&#123;<span class="string">"PS1=-[namespace-process]-# "</span>&#125;</span><br><span class="line">	cmd.Stdin = os.Stdin</span><br><span class="line">	cmd.Stdout = os.Stdout</span><br><span class="line">	cmd.Stderr = os.Stderr</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> err := cmd.Run(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>运行我们的程序，查看网络设备，发现为空</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-[namespace-process]-# ifconfig</span><br><span class="line">-[namespace-process]-#</span><br></pre></td></tr></table></figure>

<p>在宿主机上查看网络设备，发现有lo, enp7s0这些网络设备。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">enp7s0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        ether 98:fa:9b:f0:85:c2  txqueuelen 1000  (以太网)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (本地环回)</span><br><span class="line">        RX packets 16381  bytes 23729834 (23.7 MB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 16381  bytes 23729834 (23.7 MB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line">....</span><br></pre></td></tr></table></figure>

<p>从上面的结果我们可以看出Network是隔离了。</p>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Golang</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Java经典回顾之Java Web</title>
    <url>/2020/04/09/Java_lookback_Java-Web/</url>
    <content><![CDATA[<img src="/images/java-web-develop.jpg" width="800px">

<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>Java版本：1.8.0_221</li>
</ul>
<h2 id="Java-Web"><a href="#Java-Web" class="headerlink" title="Java Web"></a>Java Web</h2><p>虽然我们现在会用<code>SpringBoot</code>快速创建一个Web Demo，但是基础不能忘（<code>SpringBoot</code>或者<code>SpringMVC</code>都是封装后的产物），下面就让我们回顾一下一个最基本的Java Web项目。</p>
<a id="more"></a>

<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><p>这里我们使用<strong>IDEA</strong>来创建项目，点击菜单<code>File</code>=&gt;<code>New</code>=&gt;<code>Project</code>，选择<code>Java Enterprise</code>，在<strong>Additional Libraries and Framework</strong>中，选择<code>Web Application</code>（我这里是4.0，旧版本的<code>IDEA</code>可能其他的），<code>Application Server</code>就是Java Web项目编译打包后运行所需要的Web服务器（你需要自己配置一下）。</p>
<p><img src="/images/idea_java_web.png" alt="upload successful"></p>
<p>点击<code>Next</code>后，填写项目名称就好了，这里我创建了一个<code>simplejavaweb</code>的项目。<br>我们来看一下<strong>项目结构</strong>  </p>
<p><img src="/images/pasted-4.png" alt="upload successful">   </p>
<ul>
<li><strong>src</strong>就是我们写Java代码的地方</li>
<li><strong>web</strong>目录是web应用部署根目录</li>
<li>web中的<strong>WEB_INF</strong>是Java的web应用的安全目录。所谓安全就是客户端无法访问，只有服务端可以访问的目录。如果想在页面中直接访问其中的文件，必须通过web.xml文件对要访问的文件进行相应映射才能访问。  </li>
<li>WEB_INF中的<strong>web.xml</strong>是Java web 项目最主要的构成部分之一，它是Web应用程序配置文件，描述了 <code>servlet</code> 和其他的应用组件配置及命名规则。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>Java Web</tag>
      </tags>
  </entry>
  <entry>
    <title>Jenkins在Docker中运行中的坑</title>
    <url>/2019/11/07/Jenkin_and_docker/</url>
    <content><![CDATA[<h2 id="jenkins是什么？"><a href="#jenkins是什么？" class="headerlink" title="jenkins是什么？"></a>jenkins是什么？</h2><p>  Jenkins是一个开源的、提供友好操作界面的持续集成(CI)工具，起源于Hudson（Hudson是商用的），主要用于持续、自动的构建/测试软件项目、监控外部任务的运行。Jenkins用Java语言编写，可在Tomcat等流行的servlet容器中运行，也可独立运行。通常与版本管理工具(SCM)、构建工具结合使用。常用的版本控制工具有SVN、GIT，构建工具有Maven、Ant、Gradle。<br>上面的介绍是抄的（逃，简单讲，就是Jenkins能帮我们<strong>自动编译，测试，发布软件</strong>。</p>
<a id="more"></a>


<h2 id="安装运行"><a href="#安装运行" class="headerlink" title="安装运行"></a>安装运行</h2><p>Jenkins有单独的war包，通过<code>java -jar jenkins.war</code>直接就可以运行（<a href="https://jenkins.io/zh/download/" target="_blank" rel="noopener">官网下载</a>，选择<code>Generic Java package (.war)</code>，或者<a href="http://mirrors.jenkins.io/" target="_blank" rel="noopener">官方镜像</a>），选择LTS Releases    中的<code>war-stable</code>），但是jre环境，当然对于熟悉Java的人来说，这个是配置一下即可。本文介绍在Docker中运行Jenkins以及会遇到的一些问题。  </p>
<ul>
<li>操作系统：Ubuntu 18.04.3 LTS</li>
<li>docker版本：19.03.4</li>
<li>jdk版本：java version “1.8.0_221”</li>
</ul>
<p>在<code>vim</code>中打开中文有时候会乱码，可以通过下面命令解决：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo locale-gen zh_CN.UTF-8</span><br></pre></td></tr></table></figure>

<p>好了，让我们开始安装<code>Jenkins</code>。<br>首先，编写一份自定义的<code>Dockerfile</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM jenkins/jenkins:lts</span><br><span class="line"></span><br><span class="line">USER root</span><br><span class="line"></span><br><span class="line">RUN echo &apos; \n\</span><br><span class="line">deb http://mirrors.aliyun.com/debian stretch main contrib non-free \n\</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian stretch main contrib non-free \n\</span><br><span class="line">deb http://mirrors.aliyun.com/debian stretch-updates main contrib non-free \n\</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian stretch-updates main contrib non-free \n\</span><br><span class="line">deb http://mirrors.aliyun.com/debian-security stretch/updates main contrib non-free \n\</span><br><span class="line">deb-src http://mirrors.aliyun.com/debian-security stretch/updates main contrib non-free &apos; &gt; /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">RUN cat /etc/apt/sources.list</span><br><span class="line"></span><br><span class="line">#更新源并安装缺少的包</span><br><span class="line">RUN apt-get update &amp;&amp; apt-get install -y gcc g++ make openssl pkg-config</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">USER jenkins</span><br></pre></td></tr></table></figure>

<p>基础镜像是<code>jenkins/jenkins:lts</code>，观察一下这个镜像<br><img src="https://s2.ax1x.com/2019/11/07/MAz11g.png" alt><br>发现它是基于<code>FROM openjdk:8-jdk-stretch</code>，这是带有jdk的debian 9镜像。所以我在<code>Dockerfile</code>中修改了apt源，这里使用了阿里云的apt源（<code>\n\</code>是换行加上续行符）。</p>
<p>再配合<code>docker-compose.yml</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;3&apos;</span><br><span class="line">services:</span><br><span class="line">  jenkins:</span><br><span class="line">    build: .</span><br><span class="line">    volumes:</span><br><span class="line">      - ./data:/var/jenkins_home</span><br><span class="line">    environment:</span><br><span class="line">      - &quot;JAVA_OPTS=-Duser.timezone=Asia/Shanghai -Xms1g -Xmx1g&quot;</span><br><span class="line">    ports: </span><br><span class="line">      - 127.0.0.1:8080:8080</span><br><span class="line">      - 50000:50000</span><br></pre></td></tr></table></figure>

<p>现在我们就可以启动Jenkins了，打开终端，键入命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker-compose up</span><br></pre></td></tr></table></figure>

<p>这时候，我们会遇到错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jenkins_1  | touch: cannot touch &apos;/var/jenkins_home/copy_reference_file.log&apos;: Permission denied</span><br><span class="line">jenkins_1  | Can not write to /var/jenkins_home/copy_reference_file.log. Wrong volume permissions?</span><br></pre></td></tr></table></figure>

<p>看描述是<strong>权限问题</strong>，观察一下目录下的<code>data</code>文件夹：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x  2 root       root       4096 11月 17 20:47 data</span><br></pre></td></tr></table></figure>

<p>发现目录的属主是<code>root</code>用户，这是什么原因呢？</p>
<h2 id="原因探究"><a href="#原因探究" class="headerlink" title="原因探究"></a>原因探究</h2><p>查看<code>Jenkins</code>容器的当前用户和目录<code>/var/jenkins_home</code>属主，我们发现当前用户是<code>Jenkins</code>，<code>/var/jenkins_home</code>属主用户是<code>jenkins</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -ti --rm --entrypoint=&quot;/bin/bash&quot;  jenkins/jenkins:lts  -c &quot;whoami &amp;&amp; id&quot;</span><br><span class="line">jenkins</span><br><span class="line">uid=1000(jenkins) gid=1000(jenkins) groups=1000(jenkins)</span><br><span class="line"></span><br><span class="line">docker run -ti --rm --entrypoint=&quot;/bin/bash&quot; jenkins/jenkins:lts -c &quot;ls -la /var&quot;</span><br><span class="line">drwxr-xr-x 1 root    root    4096 Oct 17 08:29 cache</span><br><span class="line">drwxr-xr-x 2 jenkins jenkins 4096 Nov 17 14:05 jenkins_home</span><br></pre></td></tr></table></figure>

<p>上述命令中，<code>--rm</code>选项是让容器退出时自动清除，<code>--entrypoint</code>是覆盖镜像中的<code>ENTRYPOINT</code>。<br>现在我们知道了，因为<code>/var/jenkins_home</code>映射到本地数据卷时，目录的拥有者变成了root用户，所以出现了<code>Permission denied</code>的问题。<br>发现问题之后，相应的解决方法也很简单：把当前目录的拥有者赋值给uid 1000，再启动”jenkins”容器就一切正常了。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo chown -R 1000:1000 data</span><br></pre></td></tr></table></figure>

<p>这时利用浏览器访问 “<a href="http://localhost:8080/&quot;" target="_blank" rel="noopener">http://localhost:8080/&quot;</a> 就可以看到Jenkins的经典Web界面了。</p>
<p>参考：</p>
<ul>
<li><a href="https://yq.aliyun.com/articles/53990" target="_blank" rel="noopener">谈谈 Docker Volume 之权限管理（一）</a></li>
</ul>
]]></content>
      <categories>
        <category>ci</category>
      </categories>
      <tags>
        <tag>jenkins</tag>
        <tag>ci</tag>
        <tag>docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络虚拟化技术之Veth和Bridge</title>
    <url>/2020/01/14/Linu_Veth_and_Bridge/</url>
    <content><![CDATA[<h2 id="Veth"><a href="#Veth" class="headerlink" title="Veth"></a>Veth</h2><p>Veth缩写是Virtual ETHernet。veth设备是在linux内核中是成对出现（所以也叫<code>veth-pair</code>），两个设备彼此相连，一个设备从协议栈读取数据后，会将数据发送到另一个设备上去。这个设备其实是专门为<code>container</code>所建的，作用就是把一个<strong>network namespace</strong>发出的数据包转发到另一个<strong>namespace</strong>（通常就是宿主机）。<br><img src="https://s2.ax1x.com/2020/01/14/lbBga9.png" alt>  </p>
<a id="more"></a>


<h3 id="添加Veth设备"><a href="#添加Veth设备" class="headerlink" title="添加Veth设备"></a>添加Veth设备</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo ip netns add net0</span><br><span class="line">$ sudo ip netns add net1</span><br><span class="line">$ sudo ip link add veth0 netns net0 type veth peer name veth1 netns net1 #添加 veth 设备对</span><br></pre></td></tr></table></figure>

<p>上面的命令将创建两个命名空间net0和net1，以及一对veth设备，并将veth1分配给命名空间net0，将veth2分配给命名空间net1。这两个名称空间与此VETH对相连。分配一对IP地址，你就可以ping通两者之间的通讯。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ ip netns ls  # 查看创建的network namespace</span><br><span class="line">net1</span><br><span class="line">net0</span><br><span class="line">$ sudo ip netns exec net0 ip addr # 查看net0下的网络设备</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: veth0@if2: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether d6:6e:4f:fb:6b:76 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line"></span><br><span class="line">$ sudo ip netns exec net1 ip addr</span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">2: veth1@if2: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether 92:05:82:e6:da:73 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure>

<p>我们给这对 veth pair 配置上 ip 地址，并启用它们以及 lo 接口:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ip netns exec net0 ip link set veth0 up</span><br><span class="line">sudo ip netns exec net0 ip addr add 10.0.1.1/24 dev veth0</span><br><span class="line">sudo ip netns exec net0 ip link set lo up</span><br><span class="line">sudo ip netns exec net0 ip route</span><br><span class="line">10.0.1.0/24 dev veth0 proto kernel scope link src 10.0.1.1 linkdown </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">sudo ip netns exec net1 ip link set veth1 up</span><br><span class="line">sudo ip netns exec net1 ip addr add 10.0.1.2/24 dev veth1</span><br><span class="line">sudo ip netns exec net1 ip link set lo up</span><br><span class="line">sudo ip netns exec net1 ip route</span><br><span class="line">10.0.1.0/24 dev veth1 proto kernel scope link src 10.0.1.2</span><br></pre></td></tr></table></figure>

<p>可以看到，在每个 namespace 中，在配置了 ip 之后，还自动生成了对应的<br>路由表信息，网络 10.0.1.0/24 数据报文都会通过 vethpair 进行传输。下面使用 ping 命令 可以验证它们的连通性，并在 veth0 和 veth1 上抓包：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ip netns exec net0 ping -c 3 10.0.1.2</span><br></pre></td></tr></table></figure>

<p><img src="https://s2.ax1x.com/2020/01/14/lb4nOA.png" alt></p>
<h2 id="Bridge"><a href="#Bridge" class="headerlink" title="Bridge"></a>Bridge</h2><p>Bridge（桥）是 Linux 上用来做 TCP/IP 二层协议交换的设备，与现实世界中的交换机功能相似。Bridge 设备实例可以和 Linux 上其他网络设备实例连接，既 attach 一个从设备，类似于在现实世界中的交换机和一个用户终端之间连接一根网线。当有数据到达时，Bridge 会根据报文中的 MAC 信息进行广播、转发、丢弃处理。</p>
<p><img src="https://s2.ax1x.com/2020/01/14/lb48fS.png" alt></p>
<p>使用Bridge前，需要安装<code>bridge-utils</code>包</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt install bridge-utils</span><br></pre></td></tr></table></figure>

<h3 id="查看bridge"><a href="#查看bridge" class="headerlink" title="查看bridge"></a>查看bridge</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line"></span><br><span class="line">bridge name	bridge id		STP enabled	interfaces</span><br><span class="line">br-1f7059361887		8000.0242740c4703	no		veth35716a0</span><br><span class="line">							vethc51a0aa</span><br><span class="line">							vethd17adab</span><br><span class="line">br-4646ac4e576a		8000.02421afdd01b	no		</span><br><span class="line">br-4b05476c9f71		8000.024240053946	no		</span><br><span class="line">br-5282ac3290df		8000.0242ad5bae1e	no		</span><br><span class="line">br-638972aaac40		8000.024278b6d203	no		</span><br><span class="line">br-67973b91b458		8000.024279f6c039	no		</span><br><span class="line">br-96dbd98373e7		8000.0242f23b4758	no		veth13b0e48</span><br><span class="line">							veth3af358a</span><br><span class="line">							veth52b951a</span><br><span class="line">							veth5adc514</span><br><span class="line">							veth6e141f8</span><br><span class="line">							veth6fcb89b</span><br><span class="line">							veth710d968</span><br><span class="line">							vethc9477cd</span><br><span class="line">							vethcf35aff</span><br><span class="line">docker0		8000.0242fee4c327	no</span><br></pre></td></tr></table></figure>

<p>上面这个是<code>docker0</code>的是Docker给你创建的bridge（如果你设备上装有docker的话 就可以看到）。  </p>
<h3 id="创建一个bridge"><a href="#创建一个bridge" class="headerlink" title="创建一个bridge"></a>创建一个bridge</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brctl addbr br66</span><br></pre></td></tr></table></figure>

<p>上面命令创建一个名为br66的桥。<br>接下来我们可以把已有的网络设备绑定到这个桥上，在这之前可以看看我们有有哪些网卡接口，可以用</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br></pre></td></tr></table></figure>

<p>假设上面查出来，有eth0和eth1两个网卡接口，下面我们把他们用命令绑定到一起</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">brctl addif br0 eth0 eth1 # eth0和eth1的顺序不重要，不影响结果</span><br></pre></td></tr></table></figure>

<p>再来查看绑定关系</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ brctl show</span><br><span class="line">bridge name     bridge id               STP enabled     interfaces</span><br><span class="line">br66             8000.001ec952d26b       yes             eth0</span><br><span class="line">                                                        eth1</span><br></pre></td></tr></table></figure>

<p>就是说eth0和eth1绑定到了br0这个桥上了。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a href="https://www.ibm.com/developerworks/cn/linux/1310_xiawc_networkdevice/index.html" target="_blank" rel="noopener">Linux 上的基础网络设备详解</a></p>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux之iptables</title>
    <url>/2020/04/26/Linux_iptables/</url>
    <content><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>管理网络流量是系统管理员必需处理的最棘手工作之一，我们必需规定连接系统的用户满足防火墙的传入和传出要求，以最大限度保证系统免受攻击。<code>iptables</code>正是这样的工具。</p>
<p>其实不是真正的防火墙，我们可以把它理解成一个客户端代理，用户通过iptables这个代理，将用户的安全设定执行到对应的”安全框架”中，这个”安全框架”才是真正的防火墙，这个框架的名字叫<strong>netfilter</strong>。</p>
<a id="more"></a>

<h2 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h2><p>iptables有5个链:PREROUTING,INPUT,FORWARD,OUTPUT,POSTROUTING,4个表:filter,nat,mangle,raw。（4表5链）<br>4个表的优先级由高到低的顺序为:raw–&gt;mangle–&gt;nat–&gt;filter  </p>
<p><img src="/images/iptables_process.png" alt="upload successful"></p>
<ul>
<li>filter：一般的过滤功能</li>
<li>nat:用于nat功能（端口映射，地址映射等）</li>
<li>mangle:用于对特定数据包的修改</li>
<li>raw:优先级最高，设置raw时一般是为了不再让iptables做数据包的链接跟踪处理，提高性能</li>
</ul>
<p>图片中，<strong>PREROUTING</strong>会有个分叉，系统是根据IP数据包中的<code>destination ip address</code>中的IP地址对数据包进行分发。<br>如果destination ip adress是<strong>本机地址</strong>，数据将会被转交给INPUT链。如果不是本机地址，则交给FORWARD链检测。</p>
<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="启动、停止和重启iptables"><a href="#启动、停止和重启iptables" class="headerlink" title="启动、停止和重启iptables"></a>启动、停止和重启iptables</h3><p>虽然 iptables 并不是一项服务，但在 Linux 中还是可以像服务一样对其状态进行管理。</p>
<p>基于SystemD的系统</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">systemctl start iptables</span><br><span class="line">systemctl stop iptables</span><br><span class="line">systemctl restart iptables</span><br></pre></td></tr></table></figure>

<h3 id="查看规则"><a href="#查看规则" class="headerlink" title="查看规则"></a>查看规则</h3><p>查看iptables防火墙策略</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo iptables -vL</span><br></pre></td></tr></table></figure>

<p>或者带上序号</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo iptables -vL  --line-number //--line-number可以显示规则序号，在删除的时候比较方便</span><br></pre></td></tr></table></figure>

<p>以上命令是查看默认的 FILTER 表，如果你只希望查看特定的表，可以在 -t 参数后跟上要单独查看的表名。例如只查看 NAT 表中的规则，可以使用如下命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo iptables -vL -t nat</span><br></pre></td></tr></table></figure>

<h3 id="添加规则"><a href="#添加规则" class="headerlink" title="添加规则"></a>添加规则</h3><p>命令格式为：”iptables [-t 表名] 选项 [链名] [条件] [-j 控制动作]”。<br>此处列出一些常用的动作：  </p>
<ul>
<li>ACCEPT：允许数据包通过。</li>
<li>DROP：直接丢弃数据包，不给任何回应信息，这时候客户端会感觉自己的请求泥牛入海了，过了超时时间才会有反应。</li>
<li>REJECT：拒绝数据包通过，必要时会给数据发送端一个响应的信息，客户端刚请求就会收到拒绝的信息。</li>
<li>SNAT：源地址转换，解决内网用户用同一个公网地址上网的问题。</li>
<li>MASQUERADE：是SNAT的一种特殊形式，适用于动态的、临时会变的ip上。</li>
<li>DNAT：目标地址转换。</li>
<li>REDIRECT：在本机做端口映射。</li>
<li>LOG：在/var/log/messages文件中记录日志信息，然后将数据包传递给下一条规则，也就是说除了记录以外不对数据包做任何其他操作，仍然让下一条规则去匹配。</li>
</ul>
<p>拒绝转发来自<code>192.168.1.10</code>主机的数据，允许转发来自<code>192.168.0.0/24</code>网段的数据</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -s 192.168.1.11 -j REJECT </span><br><span class="line">iptables -A FORWARD -s 192.168.0.0/24 -j ACCEPT</span><br><span class="line">说明：注意要把拒绝的放在前面不然就不起作用了啊。</span><br></pre></td></tr></table></figure>

<p>允许本机开放从TCP端口20-1024提供的应用服务。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A INPUT -p tcp --dport 20:1024 -j ACCEPT </span><br><span class="line">iptables -A OUTPUT -p tcp --sport 20:1024 -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>允许转发来自192.168.0.0/24局域网段的DNS解析请求数据包。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -A FORWARD -s 192.168.0.0/24 -p udp --dport 53 -j ACCEPT </span><br><span class="line">iptables -A FORWARD -d 192.168.0.0/24 -p udp --sport 53 -j ACCEPT</span><br></pre></td></tr></table></figure>

<h3 id="DNAT和SNAT"><a href="#DNAT和SNAT" class="headerlink" title="DNAT和SNAT"></a>DNAT和SNAT</h3><p>我们要做的DNAT要在进入这个菱形转发区域之前，也就是在<strong>PREROUTING链</strong>中做，例如要把访问<code>202.103.96.112</code>的访问转发到<code>192.168.0.112</code>上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A PREROUTING -d 202.103.96.112 -j DNAT --to-destination 192.168.0.112</span><br></pre></td></tr></table></figure>

<p>而SNAT自然是要在数据包流出这台机器之前的最后一个链也就是<strong>POSTROUTING链</strong>来进行操作</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -j SNAT --to-source 58.20.51.66</span><br></pre></td></tr></table></figure>

<p>假如当前系统用的是ADSL/3G/4G动态拨号方式，那么每次拨号，出口IP都会改变，SNAT就会有局限性。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -t nat -A POSTROUTING -s 192.168.0.0/24 -o eth0 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p>重点在那个『 MASQUERADE 』！这个设定值就是『IP伪装成为封包出去(-o)的那块装置上的IP』！</p>
<p>不管现在eth0的出口获得了怎样的动态ip，MASQUERADE会自动读取eth0现在的ip地址然后做SNAT出去，这样就实现了很好的动态SNAT地址转换。</p>
<h3 id="删除iptables规则"><a href="#删除iptables规则" class="headerlink" title="删除iptables规则"></a>删除iptables规则</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables -D INPUT 3  //删除input的第3条规则  </span><br><span class="line">  </span><br><span class="line">iptables -t nat -D POSTROUTING 1  //删除nat表中postrouting的第一条规则  </span><br><span class="line">  </span><br><span class="line">iptables -F INPUT   //清空 filter表INPUT所有规则  </span><br><span class="line"></span><br><span class="line">iptables -F    //清空所有规则  </span><br><span class="line"></span><br><span class="line">iptables -t nat -F POSTROUTING   //清空nat表POSTROUTING所有规则</span><br></pre></td></tr></table></figure>

<h3 id="保存和恢复"><a href="#保存和恢复" class="headerlink" title="保存和恢复"></a>保存和恢复</h3><p>iptables 命令修改后规则只存在于内存中，但是我们保存当前规则用来恢复</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">iptables-save &gt; /etc/sysconfig/iptables.20180606</span><br><span class="line"></span><br><span class="line">iptables-restore &lt; /etc/sysconfig/iptables.20180606</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://blog.51cto.com/linuxcgi/1965296" target="_blank" rel="noopener">iptables之FORWARD转发链</a></li>
<li><a href="https://www.cnblogs.com/liuhongru/p/11422460.html" target="_blank" rel="noopener">iptables中DNAT、SNAT和MASQUERADE</a></li>
<li><a href="https://www.jianshu.com/p/196e57a99a9a" target="_blank" rel="noopener">iptables介绍</a></li>
<li><a href="https://www.cnblogs.com/whych/p/9147900.html" target="_blank" rel="noopener">Linux iptables用法与NAT</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>iptables</tag>
      </tags>
  </entry>
  <entry>
    <title>Java之synchronized的实现原理</title>
    <url>/2020/02/25/Java_synchronized_underlying/</url>
    <content><![CDATA[<h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><p>在Java多线程编程中，我们最先碰到的也是最简单的方法就利用<code>synchronized</code>关键字。用它的方式有三种：</p>
<ul>
<li>修饰实例方法，锁是当前实例对象</li>
<li>修饰静态方法，锁是当前类的class对象（每个类都有一个Class对象）</li>
<li>修饰代码块，锁定括号里的对象</li>
</ul>
<p>加上<code>synchronized</code>之后，我们的代码就变成了同步代码，神奇又强大，但有的时候也不禁会思考下：Java底层是怎么实现<code>synchronized</code>关键字的？<br>在阅读了一些文章之后，我在这里做了一些归纳和总结。</p>
<a id="more"></a>

<p>首先，看一段简单的Java代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class SyncTest &#123;</span><br><span class="line">    public synchronized void test1()&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void test2()&#123;</span><br><span class="line">        synchronized (this)&#123;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先用<code>javac SyncTest.java</code>编译出class文件，再利用<code>javap -v -c SyncTest.class</code>查看<code>synchronized</code>的实现。<code>javap</code>是jdk自带的反解析工具。它的作用就是根据class字节码文件，反解析出当前类对应的code区（汇编指令）、本地变量表、异常表和代码行偏移量映射表、常量池等等信息。<br>反解析结果为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">&#123;</span><br><span class="line">  public synchronized void test1();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC, ACC_SYNCHRONIZED</span><br><span class="line">    Code:</span><br><span class="line">      stack=0, locals=1, args_size=1</span><br><span class="line">         0: return</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 4: 0</span><br><span class="line"></span><br><span class="line">  public void test2();</span><br><span class="line">    descriptor: ()V</span><br><span class="line">    flags: ACC_PUBLIC</span><br><span class="line">    Code:</span><br><span class="line">      stack=2, locals=3, args_size=1</span><br><span class="line">         0: aload_0</span><br><span class="line">         1: dup</span><br><span class="line">         2: astore_1</span><br><span class="line">         3: monitorenter          // 监视器进入，获取锁</span><br><span class="line">         4: aload_1</span><br><span class="line">         5: monitorexit           // 监视器退出，释放锁</span><br><span class="line">         6: goto          14</span><br><span class="line">         9: astore_2</span><br><span class="line">        10: aload_1</span><br><span class="line">        11: monitorexit</span><br><span class="line">        12: aload_2</span><br><span class="line">        13: athrow</span><br><span class="line">        14: return</span><br><span class="line">      Exception table:</span><br><span class="line">         from    to  target type</span><br><span class="line">             4     6     9   any</span><br><span class="line">             9    12     9   any</span><br><span class="line">      LineNumberTable:</span><br><span class="line">        line 7: 0</span><br><span class="line">        line 9: 4</span><br><span class="line">        line 10: 14</span><br><span class="line">      StackMapTable: number_of_entries = 2</span><br><span class="line">        frame_type = 255 /* full_frame */</span><br><span class="line">          offset_delta = 9</span><br><span class="line">          locals = [ class SyncTest, class java/lang/Object ]</span><br><span class="line">          stack = [ class java/lang/Throwable ]</span><br><span class="line">        frame_type = 250 /* chop */</span><br><span class="line">          offset_delta = 4</span><br><span class="line">&#125;</span><br><span class="line">SourceFile: &quot;SyncTest.java&quot;</span><br></pre></td></tr></table></figure>

<p>从上面可以看出，同步代码块是使用monitorenter和monitorexit指令实现的，同步方法（在这看不出来需要看JVM底层实现）依靠的是方法修饰符上的<code>ACC_SYNCHRONIZED实现</code>。</p>
<h2 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h2><p>Java对象头和monitor是实现synchronized的基础。<br>HotSpot虚拟机中，对象在内存中存储的布局可以分为三块区域：对象头（Header）、实例数据（Instance Data）和对齐填充（Padding）。  </p>
<p><img src="https://s2.ax1x.com/2020/03/01/3gzdxg.png" alt><br>普通对象的对象头包括两部分：Mark Word 和 Class Metadata Address （类型指针）（如上图所示），如果是数组对象还包括一个额外的Array length数组长度部分（这里我没给出图片）。  </p>
<p>在32位虚拟机中，一字宽等于四字节，即32bit。<br>HotSpot虚拟机的对象头(Object Header)包括两部分信息，第一部分用于存储对象自身的运行时数据， 如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等等，这部分数据的长度在32位和64位的虚拟机（暂不考虑开启压缩指针的场景）中分别为32个和64个Bits，官方称它为“Mark Word”（标记字段）。  </p>
<p>对象需要存储的运行时数据很多，其实已经超出了32、64位Bitmap结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额 外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如在32位的HotSpot虚拟机 中对象未被锁定的状态下，Mark Word的32个Bits空间中的25Bits用于存储对象哈希码（HashCode），4Bits用于存储对象分代年龄，2Bits用于存储锁标志 位，1Bit固定为0，在其他状态（轻量级锁定、重量级锁定、GC标记、可偏向）下对象的存储内容如下表所示：  </p>
<p><img src="https://s2.ax1x.com/2020/03/01/32ClfP.jpg" alt></p>
<p>注意偏向锁、轻量级锁、重量级锁等都是jdk 1.6以后引入的。<br><img src="https://s2.ax1x.com/2020/03/01/32iYIs.png" alt></p>
<h2 id="monitor对象"><a href="#monitor对象" class="headerlink" title="monitor对象"></a>monitor对象</h2><p>轻量级锁和偏向锁是Java 6 对 synchronized 锁进行优化后新增加的，稍后我们会简要分析。这里我们主要分析一下重量级锁也就是通常说<code>synchronized</code>的对象锁，锁标识位为10，其中指针指向的是monitor对象（也称为管程或监视器锁）的起始地址。每个对象都存在着一个 monitor 与之关联，对象与其 monitor 之间的关系有存在多种实现方式，如monitor可以与对象一起创建销毁或当线程试图获取对象锁时自动生成，但当一个 monitor 被某个线程持有后，它便处于锁定状态。在Java虚拟机(HotSpot)中，monitor是由ObjectMonitor实现的，其主要数据结构如下（位于HotSpot虚拟机源码ObjectMonitor.hpp文件，C++实现的）：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ObjectMonitor() &#123;</span><br><span class="line">    _header       = NULL;</span><br><span class="line">    _count        = 0; //记录个数</span><br><span class="line">    _waiters      = 0,</span><br><span class="line">    _recursions   = 0;</span><br><span class="line">    _object       = NULL;</span><br><span class="line">    _owner        = NULL;</span><br><span class="line">    _WaitSet      = NULL; //处于wait状态的线程，会被加入到_WaitSet</span><br><span class="line">    _WaitSetLock  = 0 ;</span><br><span class="line">    _Responsible  = NULL ;</span><br><span class="line">    _succ         = NULL ;</span><br><span class="line">    _cxq          = NULL ;</span><br><span class="line">    FreeNext      = NULL ;</span><br><span class="line">    _EntryList    = NULL ; //处于等待锁block状态的线程，会被加入到该列表</span><br><span class="line">    _SpinFreq     = 0 ;</span><br><span class="line">    _SpinClock    = 0 ;</span><br><span class="line">    OwnerIsThread = 0 ;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<p>ObjectMonitor中有两个队列，_WaitSet和_EntryList，用来保存ObjectWaiter对象列表(每个等待锁的线程都会被封装成ObjectWaiter对象)，_owner指向持有ObjectMonitor对象的线程，当多个线程同时访问一段同步代码时，首先会进入 _EntryList 集合，当线程获取到对象的monitor 后进入 _Owner 区域并把monitor中的owner变量设置为当前线程同时monitor中的计数器count加1，若线程调用wait()方法，将释放当前持有的monitor，owner变量恢复为null，count自减1，同时该线程进入WaitSet集合中等待被唤醒。若当前线程执行完毕也将释放monitor(锁)并复位变量的值，以便其他线程进入获取monitor(锁)。如下图所示：  </p>
<p><img src="https://s2.ax1x.com/2020/03/06/3qfHBQ.gif" alt></p>
<h2 id="锁优化"><a href="#锁优化" class="headerlink" title="锁优化"></a>锁优化</h2><p>从上一节看出，<code>synchronized</code>的实现依赖于与某个对象向关联的monitor（监视器）实现，而monitor是基于底层操作系统的<a href="https://en.cppreference.com/w/cpp/thread/mutex" target="_blank" rel="noopener">Mutex Lock</a>实现的，而基于Mutex Lock实现的同步必须经历从用户态到核心态的转换，这个开销特别大，成本非常高。所以频繁的通过Synchronized实现同步会严重影响到程序效率，而这种依赖于<code>Mutex Lock</code>实现的锁机制也被称为“重量级锁”，为了减少重量级锁带来的性能开销，JDK对<code>synchronized</code>进行了种种优化。  </p>
<p>Java SE1.6为了减少获得锁和释放锁所带来的性能消耗，引入了“偏向锁”和“轻量级锁”，所以在Java SE1.6里锁一共有四种状态，无锁状态，偏向锁状态，轻量级锁状态和重量级锁状态，它会随着竞争情况逐渐升级。锁可以升级但不能降级，意味着偏向锁升级成轻量级锁后不能降级成偏向锁。  </p>
<h3 id="偏向锁"><a href="#偏向锁" class="headerlink" title="偏向锁"></a>偏向锁</h3><p>Hotspot的作者经过以往的研究发现大多数情况下锁不仅不存在多线程竞争，而且总是由同一线程多次获得，为了让线程获得锁的代价更低而引入了偏向锁。<br><img src="https://s1.ax1x.com/2020/03/19/8sdygH.png" alt></p>
<p><strong>获取锁：</strong>  </p>
<ol>
<li>检测Mark Word是否为可偏向状态，即是否为偏向锁1，锁标识位为01；</li>
<li>若为可偏向状态，则测试线程ID是否为当前线程ID，如果是，则执行步骤（5），否则执行步骤（3）；</li>
<li>如果线程ID不为当前线程ID，则通过CAS操作竞争锁，竞争成功，则将Mark Word的线程ID替换为当前线程ID，否则执行线程（4）；</li>
<li>通过CAS竞争锁失败，证明当前存在多线程竞争情况，当到达全局安全点，获得偏向锁的线程被挂起，偏向锁升级为轻量级锁，然后被阻塞在安全点的线程继续往下执行同步代码块；</li>
<li>执行同步代码块  </li>
</ol>
<p><strong>释放锁：</strong><br>偏向锁的释放采用了一种只有竞争才会释放锁的机制，线程是不会主动去释放偏向锁，需要等待其他线程来竞争。偏向锁的撤销需要等待全局安全点（这个时间点是上没有正在执行的代码）。其步骤如下：  </p>
<ul>
<li>暂停拥有偏向锁的线程，判断锁对象石是否还处于被锁定状态；</li>
<li>撤销偏向苏，恢复到无锁状态（01）或者轻量级锁的状态；</li>
</ul>
<h3 id="轻量级锁"><a href="#轻量级锁" class="headerlink" title="轻量级锁"></a>轻量级锁</h3><p>引入轻量级锁的主要目的是在多没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。 当关闭偏向锁功能或者多个线程竞争偏向锁导致偏向锁升级为轻量级锁，则会尝试获取轻量级锁，其步骤如下：<br><img src="https://s1.ax1x.com/2020/03/19/8saew6.png" alt>  </p>
<p><strong>获取锁：</strong></p>
<ol>
<li>判断当前对象是否处于无锁状态（hashcode、0、01），若是，则JVM首先将在当前线程的栈帧中建立一个名为锁记录（Lock Record）的空间，用于存储锁对象目前的Mark Word的拷贝（官方把这份拷贝加了一个Displaced前缀，即Displaced Mark Word）；否则执行步骤（3）；</li>
<li>JVM利用CAS操作尝试将对象的Mark Word更新为指向Lock Record的指正，如果成功表示竞争到锁，则将锁标志位变成00（表示此对象处于轻量级锁状态），执行同步操作；如果失败则执行步骤（3）；</li>
<li>判断当前对象的Mark Word是否指向当前线程的栈帧，如果是则表示当前线程已经持有当前对象的锁，则直接执行同步代码块；否则只能说明该锁对象已经被其他线程抢占了，这时轻量级锁需要膨胀为重量级锁，锁标志位变成10，后面等待的线程将会进入阻塞状态；  </li>
</ol>
<p><strong>释放锁：</strong><br>轻量级锁的释放也是通过CAS操作来进行的，主要步骤如下：</p>
<ol>
<li>取出在获取轻量级锁保存在Displaced Mark Word中的数据；</li>
<li>用CAS操作将取出的数据替换当前对象的Mark Word中，如果成功，则说明释放锁成功，否则执行（3）；</li>
<li>如果CAS操作替换失败，说明有其他线程尝试获取该锁，则需要在释放锁的同时需要唤醒被挂起的线程。</li>
</ol>
<p>轻量级锁状态时，位置被锁指针占用，那hashCode等信息要存到哪里？这里的问题就比较简单了，因为有拷贝的mark word，所以Displaced Mark Word中存在所需要的信息。</p>
<h3 id="重量级锁"><a href="#重量级锁" class="headerlink" title="重量级锁"></a>重量级锁</h3><p>重量级锁通过对象内部的监视器（monitor）实现，其中monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，切换成本非常高。</p>
<h3 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h3><p>轻量级锁失败后，虚拟机为了避免线程真实地在操作系统层面挂起，还会进行一项称为自旋锁的优化手段。这是基于在大多数情况下，线程持有锁的时间都不会太长，如果直接挂起操作系统层面的线程可能会得不偿失，毕竟操作系统实现线程之间的切换时需要从用户态转换到核心态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高，因此自旋锁会假设在不久将来，当前的线程可以获得锁，因此虚拟机会让当前想要获取锁的线程做几个空循环(这也是称为自旋的原因)，一般不会太久，可能是50个循环或100循环，在经过若干次循环后，如果得到锁，就顺利进入临界区。如果还不能获得锁，那就会将线程在操作系统层面挂起，这就是自旋锁的优化方式，这种方式确实也是可以提升效率的。最后没办法也就只能升级为重量级锁了。自旋是把双刃剑，如果旋的时间过长会影响整体性能，时间过短又达不到延迟阻塞的目的。显然，自旋的周期选择显得非常重要，但这与操作系统、硬件体系、系统的负载等诸多场景相关，很难选择，如果选择不当，不但性能得不到提高，可能还会下降。</p>
<h3 id="适应自旋锁"><a href="#适应自旋锁" class="headerlink" title="适应自旋锁"></a>适应自旋锁</h3><p>JDK 1.6引入了更加聪明的自旋锁，即自适应自旋锁。所谓自适应就意味着自旋的次数不再是固定的，它是由前一次在同一个锁上的自旋时间及锁的拥有者的状态来决定。它怎么做呢？线程如果自旋成功了，那么下次自旋的次数会更加多，因为虚拟机认为既然上次成功了，那么此次自旋也很有可能会再次成功，那么它就会允许自旋等待持续的次数更多。反之，如果对于某个锁，很少有自旋能够成功的，那么在以后要或者这个锁的时候自旋的次数会减少甚至省略掉自旋过程，以免浪费处理器资源。</p>
<h3 id="锁消除"><a href="#锁消除" class="headerlink" title="锁消除"></a>锁消除</h3><p>为了保证数据的完整性，我们在进行操作时需要对这部分操作进行同步控制，但是在有些情况下，JVM检测到不可能存在共享数据竞争，这是JVM会对这些同步锁进行锁消除。锁消除的依据是逃逸分析的数据支持。<br>如果不存在竞争，为什么还需要加锁呢？所以锁消除可以节省毫无意义的请求锁的时间。变量是否逃逸，对于虚拟机来说需要使用数据流分析来确定，但是对于我们程序员来说这还不清楚么？我们会在明明知道不存在数据竞争的代码块前加上同步吗？但是有时候程序并不是我们所想的那样？我们虽然没有显示使用锁，但是我们在使用一些JDK的内置API时，如StringBuffer、Vector、HashTable等，这个时候会存在隐形的加锁操作。比如<code>StringBuffer</code>的append()方法，<code>Vector</code>的add()方法。</p>
<h3 id="锁的膨胀流程"><a href="#锁的膨胀流程" class="headerlink" title="锁的膨胀流程"></a>锁的膨胀流程</h3><p>在前面偏向锁和轻量级锁的小节中已经大概了解的锁的膨胀流程：<br>偏向锁-&gt;轻量级锁-&gt;重量级锁  </p>
<p>偏向所锁，轻量级锁都是乐观锁，重量级锁是悲观锁。 </p>
<p>一个对象刚开始实例化的时候，没有任何线程来访问它的时候。它是可偏向的，意味着，它现在认为只可能有一个线程来访问它，所以当第一个线程来访问它的时候，它会偏向这个线程，此时，对象持有偏向锁。 </p>
<p>偏向第一个线程，这个线程在修改对象头成为偏向锁的时候使用CAS操作，并将对象头中的ThreadID改成自己的ID，之后再次访问这个对象时，只需要对比ID，不需要再使用CAS在进行操作。  </p>
<p>一旦有第二个线程访问这个对象，因为偏向锁不会主动释放，所以第二个线程可以看到对象是偏向状态，这时表明在这个对象上已经存在竞争了，检查原来持有该对象锁的线程是否依然存活，如果挂了，则可以将对象变为无锁状态，然后重新偏向新的线程，如果原来的线程依然存活，则马上执行那个线程的操作栈，检查该对象的使用情况，如果仍然需要持有偏向锁，则偏向锁升级为轻量级锁，（偏向锁就是这个时候升级为轻量级锁的）。如果不存在使用了，则可以将对象回复成无锁状态，然后重新偏向。   </p>
<p>轻量级锁认为竞争存在，但是竞争的程度很轻，一般两个线程对于同一个锁的操作都会错开，或者说稍微等待一下（自旋），另一个线程就会释放锁。 但是当自旋超过一定的次数，或者一个线程在持有锁，一个在自旋，又有第三个来访时，轻量级锁膨胀为重量级锁，重量级锁使除了拥有锁的线程以外的线程都阻塞，防止CPU空转。</p>
<p>参考：</p>
<ul>
<li><a href="https://blog.csdn.net/chenssy/article/details/54883355" target="_blank" rel="noopener">【死磕Java并发】—–深入分析synchronized的实现原理
</a></li>
<li><a href="https://www.cnblogs.com/duanxz/p/4967042.html" target="_blank" rel="noopener">java对象在内存中的结构（HotSpot虚拟机）
</a></li>
<li><a href="https://howtodoinjava.com/java/multi-threading/multithreading-difference-between-lock-and-monitor/" target="_blank" rel="noopener">Difference between lock and monitor – Java Concurrency
</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>synchronized</tag>
        <tag>java</tag>
      </tags>
  </entry>
  <entry>
    <title>Python曲线拟合</title>
    <url>/2020/04/12/Python_curve_fit/</url>
    <content><![CDATA[<h2 id="Python曲线拟合"><a href="#Python曲线拟合" class="headerlink" title="Python曲线拟合"></a>Python曲线拟合</h2><p><img src="https://s1.ax1x.com/2020/04/16/JkSI7F.png" alt></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>Python版本：3.6.9</li>
</ul>
<h2 id="曲线拟合"><a href="#曲线拟合" class="headerlink" title="曲线拟合"></a>曲线拟合</h2><p>现在我们有一组数据，表达的含义是在不同的时间点的充值金额，反映在坐标上就是一系列的散点，我们希望选择适当的曲线类型（如<code>y = a*x^2 + b</code>）“最佳”地逼近或拟合已知数据，这便是<strong>曲线拟合</strong>（curve fitting）。当然，变量间未必都是线性关系，我们可能会用到指数函数、对数函数、幂函数等。</p>
<a id="more"></a>

<h2 id="Python拟合库"><a href="#Python拟合库" class="headerlink" title="Python拟合库"></a>Python拟合库</h2><p><img src="https://s1.ax1x.com/2020/04/16/Jkp7b8.png" alt><br>Python的<a href="https://www.scipy.org/" target="_blank" rel="noopener"><strong>SciPy</strong></a>库是一个用于数学、科学、工程领域的常用软件包，可以处理插值、积分、优化、图像处理、常微分方程数值解的求解、信号处理等问题。SciPy是基于<strong>NumPy</strong>，所以你也需要安装NumPy，另外用了<strong>Matplotlib</strong>库来绘制图表，所以也需要安装<code>Matplotlib</code>。（Python在科学计算领域，numpy、Scipy、Matplotlib是非常受欢迎的三个库）  </p>
<h2 id="使用案例"><a href="#使用案例" class="headerlink" title="使用案例"></a>使用案例</h2><p>首先安装所需依赖（<code>pip</code>使用豆瓣镜像）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">pip  install  -i  https://pypi.doubanio.com/simple/  numpy scipy matplotlib</span><br></pre></td></tr></table></figure>

<h3 id="多项式拟合"><a href="#多项式拟合" class="headerlink" title="多项式拟合"></a>多项式拟合</h3><p>第一种是进行多项式拟合，数学上可以证明，任意函数都可以表示为多项式形式。用的函数是<code>numpy</code>的<code>polyfit</code>函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import numpy as np</span><br><span class="line">import matplotlib.pyplot as plt</span><br><span class="line"></span><br><span class="line"># 定义x、y散点坐标</span><br><span class="line">x = [10, 20, 30, 40, 50, 60, 70, 80]</span><br><span class="line">y = [174, 236, 305, 334, 349, 351, 342, 323]</span><br><span class="line"></span><br><span class="line"># 转化为numpy的数组</span><br><span class="line">x = np.array(x)</span><br><span class="line">y = np.array(y)</span><br><span class="line"></span><br><span class="line"># 这里的3表示最高幂，也就是函数形式为y = a* x^3 + b * x^2 + c * x + d</span><br><span class="line">parameter = np.polyfit(x, y, 3)</span><br><span class="line">print(&apos;函数系数为:\n&apos;, parameter)</span><br><span class="line"></span><br><span class="line">func1 = np.poly1d(parameter)</span><br><span class="line">print(&apos;函数为 :\n&apos;, func1)</span><br><span class="line"></span><br><span class="line"># 也可使用newY=np.polyval(func1, x)</span><br><span class="line">newY = func1(x)  # 拟合y值</span><br><span class="line"></span><br><span class="line"># 绘图</span><br><span class="line">plot1 = plt.plot(x, y, &apos;s&apos;, label=&apos;original values&apos;)</span><br><span class="line">plot2 = plt.plot(x, newY, &apos;r&apos;, label=&apos;polyfit values&apos;)</span><br><span class="line">plt.xlabel(&apos;x&apos;)</span><br><span class="line">plt.ylabel(&apos;y&apos;)</span><br><span class="line">plt.legend(loc=4)  # 指定legend的位置右下角</span><br><span class="line">plt.title(&apos;polyfitting&apos;)</span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure>

<p>拟合结果:<br><img src="https://s1.ax1x.com/2020/04/16/JktOn1.png" alt></p>
<h3 id="给定函数形式拟合"><a href="#给定函数形式拟合" class="headerlink" title="给定函数形式拟合"></a>给定函数形式拟合</h3><p>scipy模块的子模块optimize中提供了一个专门用于曲线拟合的函数<code>curve_fit()</code><br>下面通过示例来说明一下如何使用curve_fit()进行直线和曲线的拟合与绘制。  </p>
<figure class="highlight python"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt</span><br><span class="line"><span class="keyword">from</span> scipy <span class="keyword">import</span> optimize</span><br><span class="line"> </span><br><span class="line"><span class="comment">#直线方程函数</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_1</span><span class="params">(x, A, B)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> A*x + B</span><br><span class="line"> </span><br><span class="line"><span class="comment">#二次曲线方程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_2</span><span class="params">(x, A, B, C)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> A*x*x + B*x + C</span><br><span class="line"> </span><br><span class="line"><span class="comment">#三次曲线方程</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">f_3</span><span class="params">(x, A, B, C, D)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> A*x*x*x + B*x*x + C*x + D</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">plot_test</span><span class="params">()</span>:</span></span><br><span class="line"> </span><br><span class="line">    plt.figure()</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#拟合点</span></span><br><span class="line">    x0 = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">    y0 = [<span class="number">1</span>, <span class="number">3</span>, <span class="number">8</span>, <span class="number">18</span>, <span class="number">36</span>]</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#绘制散点</span></span><br><span class="line">    plt.scatter(x0[:], y0[:], <span class="number">25</span>, <span class="string">"red"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#直线拟合与绘制</span></span><br><span class="line">    A1, B1 = optimize.curve_fit(f_1, x0, y0)[<span class="number">0</span>]</span><br><span class="line">    x1 = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.01</span>)</span><br><span class="line">    y1 = A1*x1 + B1</span><br><span class="line">    plt.plot(x1, y1, <span class="string">"blue"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#二次曲线拟合与绘制</span></span><br><span class="line">    A2, B2, C2 = optimize.curve_fit(f_2, x0, y0)[<span class="number">0</span>]</span><br><span class="line">    x2 = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.01</span>)</span><br><span class="line">    y2 = A2*x2*x2 + B2*x2 + C2 </span><br><span class="line">    plt.plot(x2, y2, <span class="string">"green"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="comment">#三次曲线拟合与绘制</span></span><br><span class="line">    A3, B3, C3, D3= optimize.curve_fit(f_3, x0, y0)[<span class="number">0</span>]</span><br><span class="line">    x3 = np.arange(<span class="number">0</span>, <span class="number">6</span>, <span class="number">0.01</span>)</span><br><span class="line">    y3 = A3*x3*x3*x3 + B3*x3*x3 + C3*x3 + D3 </span><br><span class="line">    plt.plot(x3, y3, <span class="string">"purple"</span>)</span><br><span class="line"> </span><br><span class="line">    plt.title(<span class="string">"test"</span>)</span><br><span class="line">    plt.xlabel(<span class="string">'x'</span>)</span><br><span class="line">    plt.ylabel(<span class="string">'y'</span>)</span><br><span class="line"> </span><br><span class="line">    plt.show()</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span></span><br></pre></td></tr></table></figure>

<p>当然，curve_fit()函数不仅可以用于直线、二次曲线、三次曲线的拟合和绘制，仿照代码中的形式，可以适用于任意形式的曲线的拟合和绘制，只要定义好合适的曲线方程即可。</p>
<p>参考：</p>
<ul>
<li><a href="https://drivingc.com/p/5af5ab892392ec35c23048e2" target="_blank" rel="noopener">np.polyfit()与np.poly1d()将点拟合成曲线</a></li>
<li><a href="https://blog.csdn.net/guduruyu/article/details/70313176" target="_blank" rel="noopener">直线和曲线的拟合与绘制</a></li>
</ul>
]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Matplotlib</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt之初步尝试</title>
    <url>/2020/01/18/Qt_begin/</url>
    <content><![CDATA[<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.3 LTS</li>
<li>Qt版本：5.14.1</li>
<li>Qt Creator版本：4.10.1</li>
</ul>
<h2 id="Qt安装"><a href="#Qt安装" class="headerlink" title="Qt安装"></a>Qt安装</h2><p>首先，我们得明白一些概念。<br><strong>Qt</strong>是一个C++库，或者说是开发框架，里面集成了一些库函数，提高开发效率。<br><strong>Qt Creator</strong>是Qt集成开发环境，你可以在这里编写，编译，运行你的程序。所以最开始写Qt只安装<strong>Qt Creator</strong>这个是不行的，因为还没有相关的Qt库呢，但是新版的<strong>Qt Creator</strong>（5.9开始）已经集成了Qt了，所以入门就方便很多了。<br>关于Qt下载，大家可以打开这里的<a href="http://download.qt.io/archive/qt/" target="_blank" rel="noopener">链接</a>，里面有各版本Qt（<strong>Qt</strong>和<strong>Qt Creator</strong>的集成包），操作简单，最新版本是<strong>5.14</strong>。  </p>
<a id="more"></a>

<p>windows版本只要双击exe就可以安装了，Linux版本需要先添加执行权限然后运行文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ chmod +x qt-opensource-linux-x64-5.13.2.run</span><br><span class="line">$ ./qt-opensource-linux-x64-5.13.2.run</span><br></pre></td></tr></table></figure>

<p>对于Linux系统，需要安装C/C++编译器，以Ubuntu为例，需要执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install -y gcc g++</span><br></pre></td></tr></table></figure>

<p>在用到<code>WebEngine</code>组件的会遇到问题<br><strong>error: GL/gl.h: No such file or directory</strong>，需要</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install mesa-common-dev</span><br></pre></td></tr></table></figure>

<p>Note: Just installing the above-mentioned mesa-common-dev kit is not sufficient for more recent Ubuntu versions. Based on a comment in the Qt forum an additional package needs installation. Execute following command:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get install libglu1-mesa-dev -y</span><br></pre></td></tr></table></figure>

<p>Tested with Qt5.3.1 and Ubuntu 14.04 and it solved the problem with missing <strong>-lGL</strong>.</p>
<p>这一步需要注册一个账号，随便注册一个即可。<br><img src="https://s2.ax1x.com/2020/01/18/1p7NOs.png" alt="install 1"><br>这一步选择你需要的组件（不清楚的话，就像我这样选择好了）<br><img src="https://s2.ax1x.com/2020/01/18/1p7IfO.png" alt="install 2"><br>最后来到Qt Creator的启动界面<br><img src="https://s2.ax1x.com/2020/01/18/1pqSyQ.png" alt></p>
<h2 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h2><p>这一步配置的环境变量在打包Qt程序的时候是需要的。  </p>
<p>编辑<code>vim ~/.bashrc</code>，加入以下变量</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export QTDIR=/home/salamander/Qt5.14.1/5.14.1/gcc_64   #这个路径依据你安装的Qt路径定</span><br><span class="line">export PATH=$QTDIR/bin:$PATH</span><br><span class="line">export MANPATH=$QTDIR/man:$MANPATH</span><br><span class="line">export LD_LIBRARY_PATH=$QTDIR/lib:$LD_LIBRARY_PATH</span><br></pre></td></tr></table></figure>

<p>但是在你执行<code>qmake</code>命令的时候，你会发现错误：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">qmake: could not exec &apos;/usr/lib/x86_64-linux-gnu/qt4/bin/qmake&apos;: no such file or directory</span><br></pre></td></tr></table></figure>

<p>我们发现<code>qmake</code>默认指向了qt4（Ubuntu 18默认装了qt4），其实现在qt官方推荐使用<strong>qtchooser</strong>来管理多个qt版本。</p>
<h3 id="什么是qtchooser"><a href="#什么是qtchooser" class="headerlink" title="什么是qtchooser"></a>什么是qtchooser</h3><p>qtchooser其实和jdk版本管理软件一样,是一个qt版本管理软件.用于设置安装多个qt的系统中默认使用的qt版本.我们知道环境变量有一个缺陷:一次只支持一个版本的qt,有的应用可能只兼容低版本qt,这样又要配置环境变量非常麻烦.使用qtchooser方便快速切换qt版本而又不用每次重新配置环境变量</p>
<p>首先，我们导入自己安装的qt</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo qtchooser -install 5.14.1 /home/salamander/Qt5.14.1/5.14.1/gcc_64/bin/qmake</span><br></pre></td></tr></table></figure>

<p>注意<strong>目录</strong>一定要精确到qmake这个程序,然后用<code>qtchooser -l</code>查看当前系统所有的qt版本,得到如下输出:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">4</span><br><span class="line">5.14.1</span><br><span class="line">5</span><br><span class="line">default</span><br><span class="line">qt4-x86_64-linux-gnu</span><br><span class="line">qt4</span><br><span class="line">qt5-x86_64-linux-gnu</span><br><span class="line">qt5</span><br></pre></td></tr></table></figure>

<p>可以看到我们自己新安装并命名的<strong>5.14.1</strong>已经导入了,接下来就是设定默认qt版本了,按照qtchooser使用提示,可以添加一个名为<code>QT_SELECT</code>的环境变量,来选择默认qt版本:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export QT_SELECT=5.14.1</span><br></pre></td></tr></table></figure>

<p>可以看出这个环境变量后面的值跟的是系统已安装的qt的名称,这些名称可以用<code>qtchooser -l</code>查看.<br>执行<code>qmake -v</code>，发现版本已经是我们自己安装的了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ qmake -v</span><br><span class="line">QMake version 3.1</span><br><span class="line">Using Qt version 5.14.1 in /home/salamander/Qt5.14.1/5.14.1/gcc_64/lib</span><br></pre></td></tr></table></figure>

<p>每次export这个<code>QT_SELECT</code>变量有点麻烦，你可以编辑<code>.bashrc</code>来自动切换qt版本。</p>
<h2 id="写个hello-world"><a href="#写个hello-world" class="headerlink" title="写个hello world"></a>写个hello world</h2><p>点击<strong>文件</strong>菜单，然后新建项目，选择<code>Qt Console Application</code>。<br><img src="https://s2.ax1x.com/2020/01/18/19CDSA.png" alt><br>编辑<code>main.cpp</code>文件，代码为：  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;QCoreApplication&gt;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    QCoreApplication a(argc, argv);</span><br><span class="line"></span><br><span class="line">    qDebug() &lt;&lt; &quot;hello world&quot;;</span><br><span class="line">    return a.exec();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>点击左下角的<code>Run</code>按钮，就可以启动程序。<br><img src="https://s2.ax1x.com/2020/01/18/19PDNF.png" alt></p>
<h2 id="信号和槽"><a href="#信号和槽" class="headerlink" title="信号和槽"></a>信号和槽</h2><p>信号和槽机制是 QT 的<strong>核心机制</strong>，要精通 QT 编程就必须对信号和槽有所了解。不同于传统的函数回调方式。信号和插槽是 Qt 中非常有特色的地方，可以说是Qt编程区别于其它编程的标志。信号和槽是一种高级接口，应用于对象之间的通信，它是 Qt 的核心特性。</p>
<h3 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h3><p>当一个对象中某些可能会有别的对象关心的状态被修改时，将会发出信号。只有定义了信号的类及其子类可以发出信号。</p>
<p>当一个信号被发出时，连接到这个信号的槽立即被调用，就像一个普通的函数调用。当这种情况发生时，信号槽机制独立于任何 GUI 事件循环。emit 语句之后的代码将在所有的槽返回之后被执行。这种情况与使用连接队列略有不同：使用连接队列的时候，emit 语句之后的代码将立即被执行，而槽在之后执行。</p>
<p>如果一个信号连接了多个槽，当信号发出时，这些槽将以连接的顺序一个接一个地被执行（顺序不确定）。</p>
<h3 id="槽（slot）"><a href="#槽（slot）" class="headerlink" title="槽（slot）"></a>槽（slot）</h3><p>当连接到的信号发出时，槽就会被调用。槽是<strong>普通的 C++ 函数</strong>，能够被正常的调用。它们的唯一特点是能够与信号连接。</p>
<p>既然信号就是普通的成员函数，当它们像普通函数一样调用的时候，遵循标准 C++ 的规则。但是，作为槽，它们又能够通过信号槽的连接被任何组件调用，不论这个组件的访问级别。这意味着任意类的实例发出的信号，都可以使得不相关的类的私有槽被调用。  </p>
<p>你也能把槽定义成虚的，这一点在实际应用中非常有用。</p>
<h3 id="信号与槽的关联"><a href="#信号与槽的关联" class="headerlink" title="信号与槽的关联"></a>信号与槽的关联</h3><p>通过调用 <strong>QObject</strong> 对象的 connect 函数来将某个对象的信号与另外一个对象的槽函数相关联，这样当发射者发射信号时，接收者的槽函数将被调用。  </p>
<p>connect()语句的原型类似于：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect(sender, SIGNAL(signal), receiver, SLOT(slot));</span><br></pre></td></tr></table></figure>

<p>这里，sender 和 receiver 都是 <strong>QObject</strong> 类型的，singal 和 slot 都是没有参数名称的函数签名。SINGAL()和SLOT()宏用于把参数转换成字符串。<br>一个信号可以和多个槽相连：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">connect(slider, SIGNAL(valueChanged(int)),</span><br><span class="line">              spinBox, SLOT(setValue(int))); </span><br><span class="line">connect(slider, SIGNAL(valueChanged(int)),</span><br><span class="line">              this, SLOT(updateStatusBarIndicator(int)));</span><br></pre></td></tr></table></figure>

<h2 id="Gui简单例子"><a href="#Gui简单例子" class="headerlink" title="Gui简单例子"></a>Gui简单例子</h2><p>这个例子中，我们用了上面槽的知识，我们在界面上放了一个<code>button</code>，然后添加了<strong>slot</strong>获得了button的click事件发送者的<code>objectName</code>。<br><strong>界面</strong>  </p>
<p><img src="/images/Qt-Gui-Example.png" alt="upload successful">  </p>
<p><strong>mainwindow.h</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#ifndef MAINWINDOW_H</span><br><span class="line">#define MAINWINDOW_H</span><br><span class="line"></span><br><span class="line">#include &lt;QMainWindow&gt;</span><br><span class="line"></span><br><span class="line">QT_BEGIN_NAMESPACE</span><br><span class="line">namespace Ui &#123; class MainWindow; &#125;</span><br><span class="line">QT_END_NAMESPACE</span><br><span class="line"></span><br><span class="line">class MainWindow : public QMainWindow</span><br><span class="line">&#123;</span><br><span class="line">    Q_OBJECT</span><br><span class="line"></span><br><span class="line">public:</span><br><span class="line">    MainWindow(QWidget *parent = nullptr);</span><br><span class="line">    ~MainWindow();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    Ui::MainWindow *ui;</span><br><span class="line">private slots:</span><br><span class="line">    void handleButton();  // 处理函数</span><br><span class="line">&#125;;</span><br><span class="line">#endif // MAINWINDOW_H</span><br></pre></td></tr></table></figure>

<p><strong>mainwindow.cpp</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &quot;mainwindow.h&quot;</span><br><span class="line">#include &quot;ui_mainwindow.h&quot;</span><br><span class="line">#include &lt;QDebug&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">    , ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line">    connect(ui-&gt;myPushButton, SIGNAL(clicked()), this, SLOT(handleButton()));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void MainWindow::handleButton()</span><br><span class="line">&#123;</span><br><span class="line">    QObject *senderObj = sender(); // This will give Sender object</span><br><span class="line">    QString senderObjName = senderObj-&gt;objectName();</span><br><span class="line">    qDebug() &lt;&lt; senderObjName;  // get myPushButton</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">MainWindow::~MainWindow()</span><br><span class="line">&#123;</span><br><span class="line">    delete ui;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul>
<li>油管上VoidRealms的<a href="https://www.youtube.com/watch?v=Id-sPu_m_hE&list=PL2D1942A4688E9D63&index=2" target="_blank" rel="noopener">Qt视频</a></li>
<li><a href="https://wiki.qt.io/Install_Qt_5_on_Ubuntu" target="_blank" rel="noopener">Install Qt5 On Ubuntu</a></li>
<li><a href="https://blog.csdn.net/AAMahone/article/details/86515536" target="_blank" rel="noopener">Ubuntu 18.04安装QtCreator+配置qt环境+qtchooser
</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
        <tag>Qt Creator</tag>
      </tags>
  </entry>
  <entry>
    <title>MyBatis经典入门回顾</title>
    <url>/2020/02/21/MyBatis_getstart_lookback/</url>
    <content><![CDATA[<img src="https://mybatis.org/images/mybatis-logo.png" width="600px">


<p>其实，无论是Mybatis、Hibernate都是ORM的一种实现框架，都是对<strong>JDBC</strong>的一种封装。 </p>
<p>之前我写过一篇<a href="2019/10/27/Spring-Boot集成MyBatis操作MySQL/">Spring Boot集成MyBatis操作MySQL</a>，不过在这里让我们脱离Spring（不过很多代码是一样的,Dao类，Model类，数据库配置），就单独回顾下MyBatis的使用，来了解下MyBatis的使用流程。  </p>
<h2 id="Mybatis工作流程"><a href="#Mybatis工作流程" class="headerlink" title="Mybatis工作流程"></a>Mybatis工作流程</h2><ul>
<li>通过Reader对象读取Mybatis配置文件</li>
<li>通过SqlSessionFactoryBuilder对象创建SqlSessionFactory对象</li>
<li>获取当前线程的SQLSession</li>
<li>事务默认开启</li>
<li>通过SQLSession读取映射文件中的操作编号，从而读取SQL语句</li>
<li>提交事务</li>
<li>关闭资源</li>
</ul>
<a id="more"></a>

<p><strong>SqlSessionFactory</strong>是一个很重要的类，每个基于 MyBatis 的应用都是以一个 SqlSessionFactory 的实例为核心的。SqlSessionFactory 的实例可以通过 SqlSessionFactoryBuilder 获得。而 SqlSessionFactoryBuilder 则可以从 XML 配置文件或一个预先定制的 Configuration 的实例构建出 SqlSessionFactory 的实例。</p>
<h2 id="pom-xml"><a href="#pom-xml" class="headerlink" title="pom.xml"></a>pom.xml</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="line">&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;</span><br><span class="line">         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span><br><span class="line">         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;</span><br><span class="line">    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;</span><br><span class="line"></span><br><span class="line">    &lt;groupId&gt;com.51lucy.test&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-simple&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.0&lt;/version&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;dependencies&gt;</span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;org.mybatis&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mybatis&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;3.5.3&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">        &lt;dependency&gt;</span><br><span class="line">            &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">            &lt;version&gt;5.1.41&lt;/version&gt;</span><br><span class="line">        &lt;/dependency&gt;</span><br><span class="line">    &lt;/dependencies&gt;</span><br><span class="line"></span><br><span class="line">&lt;/project&gt;</span><br></pre></td></tr></table></figure>

<h2 id="数据库配置jdbc-properties"><a href="#数据库配置jdbc-properties" class="headerlink" title="数据库配置jdbc.properties"></a>数据库配置jdbc.properties</h2><p>在<strong>src/main/resources</strong>文件夹下创建<code>jdbc.properties</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">jdbc.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/spring_db</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=***********</span><br></pre></td></tr></table></figure>

<h2 id="mybatis配置文件"><a href="#mybatis配置文件" class="headerlink" title="mybatis配置文件"></a>mybatis配置文件</h2><p>在<strong>src/main/resources</strong>文件夹下创建<code>mybatis-config.xml</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;properties resource=&quot;jdbc.properties&quot;/&gt;</span><br><span class="line"></span><br><span class="line">    &lt;environments default=&quot;development&quot;&gt;</span><br><span class="line">        &lt;!-- 设置一个默认的连接环境信息 --&gt;</span><br><span class="line">        &lt;environment id=&quot;development&quot;&gt;</span><br><span class="line">            &lt;transactionManager type=&quot;JDBC&quot;/&gt;</span><br><span class="line">            &lt;dataSource type=&quot;POOLED&quot;&gt;</span><br><span class="line">                &lt;property name=&quot;driver&quot; value=&quot;$&#123;jdbc.driverClassName&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;url&quot; value=&quot;$&#123;jdbc.url&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;username&quot; value=&quot;$&#123;jdbc.username&#125;&quot;/&gt;</span><br><span class="line">                &lt;property name=&quot;password&quot; value=&quot;$&#123;jdbc.password&#125;&quot;/&gt;</span><br><span class="line">            &lt;/dataSource&gt;</span><br><span class="line">        &lt;/environment&gt;</span><br><span class="line">    &lt;/environments&gt;</span><br><span class="line">    &lt;mappers&gt;</span><br><span class="line">        &lt;mapper resource=&quot;mappers/User.xml&quot;/&gt;</span><br><span class="line">    &lt;/mappers&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<h2 id="添加Dao接口"><a href="#添加Dao接口" class="headerlink" title="添加Dao接口"></a>添加Dao接口</h2><p>UserDao接口（其实就是Mapper接口）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.lucy.test.dao;</span><br><span class="line"></span><br><span class="line">import com.lucy.test.model.User;</span><br><span class="line"></span><br><span class="line">public interface UserDao &#123;</span><br><span class="line">    User findByName(String name);</span><br><span class="line"></span><br><span class="line">    int insertUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="xml映射文件"><a href="#xml映射文件" class="headerlink" title="xml映射文件"></a>xml映射文件</h2><p>在<strong>src/main/resources/mappers</strong>文件夹下创建<code>User.xml</code>文件：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper</span><br><span class="line">        PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span><br><span class="line">        &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line">&lt;!--namespace要写对--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.lucy.test.dao.UserDao&quot;&gt;</span><br><span class="line">    &lt;select id=&quot;findByName&quot; parameterType=&quot;java.lang.String&quot;  resultType=&quot;com.lucy.test.model.User&quot;&gt;</span><br><span class="line">        select  uid, name, age, address, created_time</span><br><span class="line">        from  user</span><br><span class="line">        where name = #&#123;name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line"></span><br><span class="line">    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.lucy.test.model.User&quot;&gt;</span><br><span class="line">        insert into user(name, age, address, created_time) VALUES (</span><br><span class="line">        #&#123;name&#125;, #&#123;age&#125;, #&#123;address&#125;, #&#123;createdDatetime&#125;</span><br><span class="line">        )</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><p>让我们写个测试类看看效果：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.lucy.test;</span><br><span class="line"></span><br><span class="line">import com.lucy.test.dao.UserDao;</span><br><span class="line">import com.lucy.test.model.User;</span><br><span class="line">import org.apache.ibatis.io.Resources;</span><br><span class="line">import org.apache.ibatis.session.SqlSession;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactory;</span><br><span class="line">import org.apache.ibatis.session.SqlSessionFactoryBuilder;</span><br><span class="line"></span><br><span class="line">import java.io.IOException;</span><br><span class="line">import java.io.InputStream;</span><br><span class="line"></span><br><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) throws IOException &#123;</span><br><span class="line">        String resource = &quot;mybatis-config.xml&quot;;</span><br><span class="line">        InputStream inputStream = Resources.getResourceAsStream(resource);</span><br><span class="line">        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(inputStream);</span><br><span class="line"></span><br><span class="line">        SqlSession sqlSession = sqlSessionFactory.openSession();</span><br><span class="line">        try &#123;</span><br><span class="line">            UserDao userMapper = sqlSession.getMapper(UserDao.class);</span><br><span class="line">            User user = userMapper.findByName(&quot;meng&quot;);</span><br><span class="line">            System.out.println(user.toString());</span><br><span class="line">            sqlSession.commit();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125; finally &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://www.javacodegeeks.com/2012/11/mybatis-tutorial-crud-operations-and-mapping-relationships-part-1.html" target="_blank" rel="noopener">MyBatis Tutorial – CRUD Operations and Mapping Relationships – Part 1
</a></li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
      </tags>
  </entry>
  <entry>
    <title>Qt之布局管理</title>
    <url>/2020/02/12/Qt%E4%B9%8B%E5%B8%83%E5%B1%80%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.3 LTS</li>
<li>Qt版本：5.14.1</li>
<li>Qt Creator版本：4.10.1</li>
</ul>
<h2 id="布局器概览"><a href="#布局器概览" class="headerlink" title="布局器概览"></a>布局器概览</h2><p>我们以下图的 Qt 设计师界面来说明布局功能，QtCreator 设计模式的布局功能与 Qt 设计师是一样的。</p>
<p><img src="/images/pasted-0.png" alt="upload successful">  </p>
<a id="more"></a>

<p>在设计师左边列表，可以看到 Layouts 栏目里有四个布局器：<br>直布局器 QVBoxLayout：将内部的控件按照垂直方向排布，一行一个。<br>◆  水平布局器 QHBoxLayout：将内部的控件按照水平方向排布，一列一个。<br>◆  网格布局器 QGridLayout：按照多行、多列的网格排布内部控件，单个控件可以占一个格子或者占据连续多个格子。<br>◆  表单布局器 QFormLayout：Qt 设计师里把这个布局器称为窗体布局器，窗体布局器这个叫法不准。这个布局器就是对应网页设计的表单，通常用于接收用户输入。该布局器就如它的图标一样，就是固定的两列控 件，第一列通常是标签，第二列是输入控件或含有输入控件的布局器。<br>◆  Qt 另外还有一个堆栈布局器 <strong>QStackedLayout</strong>，通常用于容纳多个子窗口布局，每次只显示其中一个。这个布局器隐含在堆栈部件 QStackedWidget 内部，一般直接用 QStackedWidget 就行了，不需要专门设置堆栈布局器。    </p>
<p>与布局紧密关联的是两个空白条（或叫弹簧条）：<strong>Horizontal Spacer</strong> 水平空白条和 <strong>Vertical Spacer</strong> 垂直空白条，空白条的作用就是填充无用的空隙，如果不希望看到控件拉伸后变丑，就可以塞一个空白条到布局器里面，布局器通常会优先拉伸空白条。两种空白条的类名都是 QSpacerItem，两种空白条只是默认的拉伸方向不一样。</p>
<h2 id="QBoxLayout"><a href="#QBoxLayout" class="headerlink" title="QBoxLayout"></a>QBoxLayout</h2><p>水平布局器 QHBoxLayout 和垂直布局器 QVBoxLayout 的基类都是 QBoxLayout，只是二者排列方向不同。水平和垂直布局器的主要功能函数都位于基类 QBoxLayout 里面，我们这里专门介绍一下这个基类的功能。<br>QBoxLayout 构造函数和 setDirection() 都可以指定布局器的方向：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QBoxLayout(Direction dir, QWidget * parent = 0)</span><br><span class="line">void setDirection(Direction direction)</span><br></pre></td></tr></table></figure>

<p>QBoxLayout 布局器的方向 QBoxLayout::​Direction 枚举不仅可以指定水平和垂直，还能指定反方向排列：  </p>
<table>
<thead>
<tr>
<th>枚举常量</th>
<th>数值</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>QBoxLayout::LeftToRight</td>
<td>0</td>
<td>水平布局，从左到右排列</td>
</tr>
<tr>
<td>QBoxLayout::RightToLeft</td>
<td>1</td>
<td>水平布局，从右到左排列</td>
</tr>
<tr>
<td>QBoxLayout::TopToBottom</td>
<td>2</td>
<td>垂直布局，从上到下排列</td>
</tr>
<tr>
<td>QBoxLayout::BottomToTop</td>
<td>3</td>
<td>垂直布局，从下到上排列</td>
</tr>
</tbody></table>
<p>水平布局器 QHBoxLayout 和垂直布局器 QVBoxLayout 默认是其中的两种：<strong>QBoxLayout::LeftToRight</strong> 和 <strong>QBoxLayout::TopToBottom</strong> 。  </p>
<p>布局器是一定要往里面添加控件才有用，添加控件的函数如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">void addWidget(QWidget * widget, int stretch = 0, Qt::Alignment alignment = 0)</span><br><span class="line">void insertWidget(int index, QWidget * widget, int stretch = 0, Qt::Alignment alignment = 0)</span><br></pre></td></tr></table></figure>

<p>widget 就是要添加的控件指针，<strong>stretch</strong> 是伸展因子，伸展因子越大，窗口变大时拉伸越 多，<strong>alignment</strong> 一般不需要指定，用默认的即可。<br>第一个 <strong>addWidget()</strong> 是将控件添加到布局里面的控件列表末尾，第二个 <strong>insertWidget()</strong> 是将控件插入到布局里控件列表序号为 index 的位置。</p>
<p>下面看个例子，我在垂直布局器中添加了5个Label，它们高度按不同的比例分配<br><strong>mainwwindow.cpp</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MainWindow::MainWindow(QWidget *parent)</span><br><span class="line">    : QMainWindow(parent)</span><br><span class="line">    , ui(new Ui::MainWindow)</span><br><span class="line">&#123;</span><br><span class="line">    ui-&gt;setupUi(this);</span><br><span class="line"></span><br><span class="line">    QLabel *label1 = new QLabel(&quot;One&quot;);</span><br><span class="line">    QLabel *label2 = new QLabel(&quot;Two&quot;);</span><br><span class="line">    QLabel *label3 = new QLabel(&quot;Three&quot;);</span><br><span class="line">    QLabel *label4 = new QLabel(&quot;Four&quot;);</span><br><span class="line">    QLabel *label5 = new QLabel(&quot;Five&quot;);</span><br><span class="line"></span><br><span class="line">    label1-&gt;setStyleSheet(&quot;background-color: red&quot;);</span><br><span class="line">    label2-&gt;setStyleSheet(&quot;background-color: yellow&quot;);</span><br><span class="line">    label3-&gt;setStyleSheet(&quot;background-color: green&quot;);</span><br><span class="line">    label4-&gt;setStyleSheet(&quot;background-color: black&quot;);</span><br><span class="line">    label5-&gt;setStyleSheet(&quot;background-color: orange&quot;);</span><br><span class="line"></span><br><span class="line">    QVBoxLayout *layout = new QVBoxLayout;</span><br><span class="line">    layout-&gt;addWidget(label1);</span><br><span class="line">    layout-&gt;addWidget(label2, 2);</span><br><span class="line">    layout-&gt;addWidget(label3, 3);</span><br><span class="line">    layout-&gt;addWidget(label4, 4);</span><br><span class="line">    layout-&gt;addWidget(label5, 5);</span><br><span class="line"></span><br><span class="line">    auto central = new QWidget;</span><br><span class="line">    central-&gt;setLayout(layout);</span><br><span class="line"></span><br><span class="line">    this-&gt;setCentralWidget(central);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终呈现的效果是：<br><img src="https://s2.ax1x.com/2020/02/12/1b3US0.png" alt><br>然后，我再添加一个水品布局器，在里头放入3个label  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">QHBoxLayout *layoutH = new QHBoxLayout;</span><br><span class="line">layout-&gt;addLayout(layoutH, 4);  // stretch比例为4</span><br><span class="line">QLabel *label6 = new QLabel(&quot;Six&quot;);</span><br><span class="line">QLabel *label7 = new QLabel(&quot;seven&quot;);</span><br><span class="line">QLabel *label8 = new QLabel(&quot;eight&quot;);</span><br><span class="line"></span><br><span class="line">label6-&gt;setStyleSheet(&quot;background-color: #7B72E9&quot;);</span><br><span class="line">label7-&gt;setStyleSheet(&quot;background-color: #1B9AF7&quot;);</span><br><span class="line">label8-&gt;setStyleSheet(&quot;background-color: #FF4351&quot;);</span><br><span class="line"></span><br><span class="line">layoutH-&gt;addWidget(label6);</span><br><span class="line">layoutH-&gt;addWidget(label7);</span><br><span class="line">layoutH-&gt;addWidget(label8);</span><br></pre></td></tr></table></figure>

<p>最终效果为：  </p>
<p><img src="/images/pasted-1.png" alt="upload successful"></p>
<p>参考：  </p>
<ul>
<li><a href="https://qtguide.ustclug.org/ch06-02.htm" target="_blank" rel="noopener">6.2 水平和垂直布局器</a></li>
</ul>
]]></content>
      <categories>
        <category>C++</category>
        <category>Qt</category>
      </categories>
      <tags>
        <tag>Qt</tag>
      </tags>
  </entry>
  <entry>
    <title>Spring Boot集成MyBatis操作MySQL</title>
    <url>/2019/10/27/Spring-Boot%E9%9B%86%E6%88%90MyBatis%E6%93%8D%E4%BD%9CMySQL/</url>
    <content><![CDATA[<p>最近学习了一下Spring Boot，它确实做到了简单快速创建Java Web应用。这是一篇简单的笔记，记录了Spring Boot集成MyBatis，实现基本的CURD。</p>
<h2 id="MyBatis集成方式"><a href="#MyBatis集成方式" class="headerlink" title="MyBatis集成方式"></a>MyBatis集成方式</h2><ul>
<li>注解版集成</li>
<li>XML版本集成</li>
</ul>
<p>XML版本为老式的配置集成方式，重度集成XML文件，SQL语句也是全部写在XML中的，我以前配SSM（Spring+SpringMVC+MyBatis）用的就是这种方式；注解版版本，相对来说比较简约，不需要XML配置，只需要使用注解和代码来操作数据，本文这里不作介绍（其实挺好学的，^_^）。 </p>
<a id="more"></a>

<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>启动MySQL服务<br>创建数据库<code>spring_db</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">CREATE DATABASE spring_db CHARACTER SET utf8mb4 COLLATE utf8mb4_unicode_ci;</span><br></pre></td></tr></table></figure>

<p>创建<code>user</code>表</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">create table user</span><br><span class="line">(</span><br><span class="line">	uid int(11) unsigned auto_increment comment &apos;主键Id&apos;</span><br><span class="line">		primary key,</span><br><span class="line">	name varchar(255) null comment &apos;名称&apos;,</span><br><span class="line">	age int null comment &apos;年龄&apos;,</span><br><span class="line">	address varchar(255) null comment &apos;地址&apos;,</span><br><span class="line">	created_time datetime null comment &apos;创建时间&apos;,</span><br><span class="line">	updated_time datetime null comment &apos;更新时间&apos;</span><br><span class="line">)</span><br><span class="line">comment &apos;用户表&apos; collate=utf8_general_ci;</span><br></pre></td></tr></table></figure>

<h2 id="添加依赖"><a href="#添加依赖" class="headerlink" title="添加依赖"></a>添加依赖</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;mysql&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;5.1.41&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br><span class="line"></span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;org.mybatis.spring.boot&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;mybatis-spring-boot-starter&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.25&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure>

<h2 id="配置数据库连接"><a href="#配置数据库连接" class="headerlink" title="配置数据库连接"></a>配置数据库连接</h2><p>设置application.properties文件，添加如下配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">spring.datasource.url=jdbc:mysql://127.0.0.1:3306/spring_db?useUnicode=true&amp;characterEncoding=UTF-8</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=2LCqvSOJ6m0Ut6ui</span><br><span class="line">spring.datasource.driver-class-name=com.mysql.jdbc.Driver</span><br></pre></td></tr></table></figure>

<ul>
<li>spring.datasource.url 数据库连接字符串</li>
<li>spring.datasource.username 数据库用户名</li>
<li>spring.datasource.password 数据库密码</li>
<li>spring.datasource.driver-class-name 驱动类型（注意MySQL 8.0的值是com.mysql.cj.jdbc.Driver和之前不同）</li>
</ul>
<h2 id="设置-MapperScan-包路径"><a href="#设置-MapperScan-包路径" class="headerlink" title="设置 MapperScan 包路径"></a>设置 MapperScan 包路径</h2><p>直接在启动文件SpringbootApplication.java的类上配置@MapperScan，这样就可以省去，单独给每个Mapper（就是我们这里的dao层）上标识@Mapper的麻烦。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@SpringBootApplication</span><br><span class="line">@MapperScan(&quot;com.salamander.springbootdemo.dao&quot;)</span><br><span class="line">public class SpringbootdemoApplication &#123;</span><br><span class="line"></span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SpringApplication.run(SpringbootdemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="添加Entity和Dao层类"><a href="#添加Entity和Dao层类" class="headerlink" title="添加Entity和Dao层类"></a>添加Entity和Dao层类</h2><p><code>com.salamander.springbootdemo.entity</code>下<code>User</code>类（使用了lombok的@Data注解）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Data</span><br><span class="line">public class User implements Serializable &#123;</span><br><span class="line">    private Long id;</span><br><span class="line"></span><br><span class="line">    private String name;</span><br><span class="line"></span><br><span class="line">    private String address;</span><br><span class="line"></span><br><span class="line">    private int age;</span><br><span class="line"></span><br><span class="line">    private Date createdDatetime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>com.salamander.springbootdemo.dao</code>下<code>UserDao</code>接口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public interface UserDao &#123;</span><br><span class="line">    User findByName(String name);</span><br><span class="line">    </span><br><span class="line">    int insertUser(User user);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="XML方式MyBatis-集成"><a href="#XML方式MyBatis-集成" class="headerlink" title="XML方式MyBatis 集成"></a>XML方式MyBatis 集成</h3><p>修改application.properties，添加配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">mybatis.config-locations=classpath:mybatis/mybatis-config.xml</span><br><span class="line">mybatis.mapper-locations=classpath:mybatis/mapper/*.xml</span><br></pre></td></tr></table></figure>

<ul>
<li>mybatis.config-locations 配置MyBatis基础属性</li>
<li>mybatis.mapper-locations 配置Mapper XML文件</li>
</ul>
<h2 id="配置XML文件"><a href="#配置XML文件" class="headerlink" title="配置XML文件"></a>配置XML文件</h2><p>本例创建两个xml文件，在resource/mybatis下的mybatis-config.xml（配置MyBatis基础属性）和在resource/mybatis/mapper下的UserMapper.xml（用户和数据交互的SQL语句）。<br><code>mybatis-config.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE configuration PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;configuration&gt;</span><br><span class="line">    &lt;typeAliases&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;Integer&quot; type=&quot;java.lang.Integer&quot;/&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;Long&quot; type=&quot;java.lang.Long&quot;/&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;HashMap&quot; type=&quot;java.util.HashMap&quot;/&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;LinkedHashMap&quot; type=&quot;java.util.LinkedHashMap&quot;/&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;ArrayList&quot; type=&quot;java.util.ArrayList&quot;/&gt;</span><br><span class="line">        &lt;typeAlias alias=&quot;LinkedList&quot; type=&quot;java.util.LinkedList&quot;/&gt;</span><br><span class="line">    &lt;/typeAliases&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure>

<p><code>UserMapper.xml</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="line">&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot; &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;</span><br><span class="line"></span><br><span class="line">&lt;!--namespace是命名空间，是dao接口的全路径--&gt;</span><br><span class="line">&lt;mapper namespace=&quot;com.salamander.springbootdemo.dao.UserDao&quot;&gt;</span><br><span class="line">    &lt;resultMap id=&quot;userResultMap&quot; type=&quot;com.salamander.springbootdemo.entity.User&quot;&gt;</span><br><span class="line">        &lt;id property=&quot;id&quot; column=&quot;uid&quot;&gt;&lt;/id&gt;</span><br><span class="line">        &lt;result column=&quot;name&quot; property=&quot;name&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;age&quot; property=&quot;age&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;address&quot; property=&quot;address&quot; /&gt;</span><br><span class="line">        &lt;result column=&quot;created_time&quot; property=&quot;createdDatetime&quot; /&gt;</span><br><span class="line">    &lt;/resultMap&gt;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &lt;select id=&quot;findByName&quot; parameterType=&quot;java.lang.String&quot;  resultMap=&quot;userResultMap&quot;&gt;</span><br><span class="line">        select  uid, name, age, address, created_time</span><br><span class="line">        from  user</span><br><span class="line">        where name = #&#123;name&#125;</span><br><span class="line">    &lt;/select&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;com.salamander.springbootdemo.entity.User&quot;&gt;</span><br><span class="line">        insert into user(name, age, address, created_time) VALUES (</span><br><span class="line">        #&#123;name&#125;, #&#123;age&#125;, #&#123;address&#125;, #&#123;createdDatetime&#125;</span><br><span class="line">        )</span><br><span class="line">    &lt;/insert&gt;</span><br><span class="line">&lt;/mapper&gt;</span><br></pre></td></tr></table></figure>

<h2 id="调用Dao类"><a href="#调用Dao类" class="headerlink" title="调用Dao类"></a>调用Dao类</h2><p><code>HomeController.java</code>类</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@RestController</span><br><span class="line">public class HomeController &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/&quot;)</span><br><span class="line">    public String index() &#123;</span><br><span class="line">        return &quot;Hello World!&quot;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @RequestMapping(&quot;/user/&#123;username&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public User getUser(@PathVariable(name = &quot;username&quot;) String name) &#123;</span><br><span class="line">        return userDao.findByName(name);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    @RequestMapping(&quot;/user/add/&#123;username&#125;&quot;)</span><br><span class="line">    @ResponseBody</span><br><span class="line">    public String addUser(@PathVariable(name = &quot;username&quot;) String name) &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(20);</span><br><span class="line">        user.setCreatedDatetime(new Date());</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">        return &quot;insert succesfully&quot;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>好了，访问链接<code>http://localhost:8080/user/wang</code>，就会输出<code>wang</code>这个用户的数据，而访问<code>http://localhost:8080/user/add/zhao</code>,会添加一条name为<code>zhao</code>的数据到数据库。</p>
<h2 id="事务支持"><a href="#事务支持" class="headerlink" title="事务支持"></a>事务支持</h2><p>在SpringBoot中开启事务非常简单，只需在业务层添加事务注解(<code>@Transactional</code>)即可快速开启事务。好的，让我们来尝试一下。<br>在上面的使用中，我们是直接把<code>Dao</code>类在控制层中使用的，但一般情况下，我们是在业务层中使用<code>Dao</code>类的。<br>在<code>com.salamander.springbootdemo</code>下新建<code>Service</code>的package，之后创建<code>接口</code>UserService：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package com.salamander.springbootdemo.service;</span><br><span class="line"></span><br><span class="line">public interface UserService &#123;</span><br><span class="line">    void addUsers(String name) throws Exception;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>之后在<code>impl</code>的子package中添加实现类<code>UserServiceImpl</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">package com.salamander.springbootdemo.service.impl;</span><br><span class="line"></span><br><span class="line">import com.salamander.springbootdemo.dao.UserDao;</span><br><span class="line">import com.salamander.springbootdemo.entity.User;</span><br><span class="line">import com.salamander.springbootdemo.service.UserService;</span><br><span class="line">import org.springframework.stereotype.Service;</span><br><span class="line">import org.springframework.transaction.annotation.Transactional;</span><br><span class="line"></span><br><span class="line">import javax.annotation.Resource;</span><br><span class="line">import java.util.Date;</span><br><span class="line"></span><br><span class="line">@Service</span><br><span class="line">public class UserServiceImpl implements UserService &#123;</span><br><span class="line">    @Resource</span><br><span class="line">    private UserDao userDao;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    @Transactional</span><br><span class="line">    @Override</span><br><span class="line">    public void addUsers(String name) throws Exception &#123;</span><br><span class="line">        int num = 5;</span><br><span class="line">        for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">            User user = getNewUser(name + (i + 1));</span><br><span class="line">            userDao.insertUser(user);</span><br><span class="line">            if (i == 3) &#123;</span><br><span class="line">                throw new Exception(&quot;发生内部错误了&quot;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private User getNewUser(String name) &#123;</span><br><span class="line">        User user = new User();</span><br><span class="line">        user.setName(name);</span><br><span class="line">        user.setAge(20);</span><br><span class="line">        user.setCreatedDatetime(new Date());</span><br><span class="line">        return user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后我们在<code>HomeController</code>中注入<code>UserService</code>，并添加路由</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Resource</span><br><span class="line">private UserService userService;</span><br><span class="line"></span><br><span class="line">@RequestMapping(&quot;/users/add/&#123;username&#125;&quot;)</span><br><span class="line">@ResponseBody</span><br><span class="line">public String addUsers(@PathVariable(name = &quot;username&quot;) String name) &#123;</span><br><span class="line">    try &#123;</span><br><span class="line">        userService.addUsers(name);</span><br><span class="line">        return &quot;batch insert succesfully&quot;;</span><br><span class="line">    &#125; catch (Exception e) &#123;</span><br><span class="line">        return e.getMessage();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到，我们在<code>addUsers</code>方法上添加了<code>@Transactional</code>注解开启了事务，并在插入第4条数据后抛出了异常。好了，让我们访问链接<code>http://localhost:8080/users/add/sun</code>，我们发现数据库多出了四条<code>name</code>为<code>sun</code>的数据，<strong>回滚并没有起效果</strong><br><img src="https://s2.ax1x.com/2019/11/03/KXiGOe.png" alt></p>
<p>这是一个常见的坑点，因为<code>Spring</code>的默认的事务规则是遇到<strong>运行异常</strong>（<code>RuntimeException</code>及其子类）和程序错误（Error）才会进行事务回滚，而<code>Exception</code>是基类就不行了，让我们看下Java的异常类层次图<br><img src="https://s2.ax1x.com/2019/11/03/KXkgGq.jpg" alt><br>如果想针对检测异常进行事务回滚，可以在<code>@Transactional</code>注解里使用<br><code>rollbackFor</code>属性明确指定异常（或者你可以自己定义一个继承<code>RuntimeException</code>的类，然后抛出这个类）。<br>现在<code>addUsers</code>改成这样，就可以正常回滚了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">@Transactional(rollbackFor = Exception.class)</span><br><span class="line">@Override</span><br><span class="line">public void addUsers(String name) throws Exception &#123;</span><br><span class="line">    int num = 5;</span><br><span class="line">    for (int i = 0; i &lt; num; i++) &#123;</span><br><span class="line">        User user = getNewUser(name + (i + 1));</span><br><span class="line">        userDao.insertUser(user);</span><br><span class="line">        if (i == 3) &#123;</span><br><span class="line">            throw new Exception(&quot;发生内部错误了&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>项目代码<a href="http://file.51lucy.com/SpringBootDemo.zip" target="_blank" rel="noopener">下载</a></p>
]]></content>
      <categories>
        <category>Java</category>
        <category>MyBatis</category>
      </categories>
      <tags>
        <tag>MyBatis</tag>
        <tag>Spring</tag>
        <tag>Spring Boot</tag>
      </tags>
  </entry>
  <entry>
    <title>Ubuntu上安装NVIDIA显卡驱动和CUDA和cuDNN库</title>
    <url>/2019/09/18/Ubuntu_CUDA_cuDNN/</url>
    <content><![CDATA[<p><img src="/images/cuda.png" alt="upload successful"></p>
<p>最近需要在用<a href="https://pytorch.org/" target="_blank" rel="noopener">Pytorch</a>做深度学习，为了加快训练速度，需要用到GPU运算，故在此记录一下安装过程。<br>我的本机环境：</p>
<ul>
<li>Ubuntu 18.04.3 LTS</li>
<li>GeForce RTX 2080s</li>
</ul>
<h3 id="检查BIOS启动项"><a href="#检查BIOS启动项" class="headerlink" title="检查BIOS启动项"></a>检查BIOS启动项</h3><ul>
<li>在开机启动项的Security选项中检查UEFI是否开启，如果开启的话请立马关掉它（重要）  </li>
<li>在开机启动项的Boot选项中检查Secure Boot是否开启，如果开启的话请立马关掉它（重要），对于有的BIOS，只要删除<strong>Secure Boot Key</strong>就好了。</li>
</ul>
<a id="more"></a>

<h3 id="禁用-nouveau"><a href="#禁用-nouveau" class="headerlink" title="禁用 nouveau"></a>禁用 nouveau</h3><p>运行命令</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo gedit /etc/modprobe.d/blacklist.conf</span><br></pre></td></tr></table></figure>

<p>将下列代码增加到blacklist.conf文件的末尾：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">blacklist vga16fb</span><br><span class="line"></span><br><span class="line">blacklist nouveau</span><br><span class="line"></span><br><span class="line">blacklist rivafb</span><br><span class="line"></span><br><span class="line">blacklist rivatv</span><br><span class="line"></span><br><span class="line">blacklist nvidiafb</span><br></pre></td></tr></table></figure>

<p>保存，然后在命令行中更新initramfs，运行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo update-initramfs -u</span><br></pre></td></tr></table></figure>

<p>之后，重启主机</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">reboot</span><br></pre></td></tr></table></figure>

<p>在终端运行，运行以下命令，查看是否禁用nouveau成功（无输出则表示禁用成功）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lsmod | grep nouveau</span><br></pre></td></tr></table></figure>

<h3 id="安装显卡驱动"><a href="#安装显卡驱动" class="headerlink" title="安装显卡驱动"></a>安装显卡驱动</h3><p>在NVIDIA官方选择对应驱动，然后<a href="https://www.geforce.com/drivers" target="_blank" rel="noopener">下载</a>：</p>
<p><img src="https://s2.ax1x.com/2019/09/18/n7DK2Q.png" alt="图片"></p>
<p>在安装驱动之前，应该卸载原有的NVIDIA驱动程序</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo apt-get remove --purge nvidia*</span><br></pre></td></tr></table></figure>

<p>把下载的驱动放到用户目录下，我这里下载文件为<code>NVIDIA-Linux-x86_64-430.50.run</code><br>为了安装新的NVIDIA驱动程序，我们需要停止当前的显示服务器。最简单的方法是使用telinit命令更改为运行级别3。执行以下linux命令后，显示服务器将停止，因此请确保在继续之前保存所有当前工作（如果有）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo telinit 3</span><br></pre></td></tr></table></figure>

<p>之后会进入一个新的命令行会话，使用当前的用户名密码登录，然后授予驱动文件可执行权限</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">chmod a+x NVIDIA-Linux-x86_64-430.50.run</span><br></pre></td></tr></table></figure>

<p>然后执行安装：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ./NVIDIA-Linux-x86_64-430.50.run --no-opengl-files</span><br></pre></td></tr></table></figure>

<p>注意，<strong>–no-opengl-files</strong>参数必须加否则会循环登录，也就是loop login<br>参数介绍：</p>
<ul>
<li>–no-opengl-files 只安装驱动文件，不安装OpenGL文件。这个参数最重要</li>
<li>–no-x-check 安装驱动时不检查X服务</li>
<li>–no-nouveau-check 安装驱动时不检查nouveau</li>
</ul>
<p>后面两个参数可不加。  </p>
<p>安装驱动中注意，<strong>pre-install script failed</strong>这个提示没什么关系，之后的warning提示<strong>unable to find a suitable destination to install 32-bit compatibility libraries</strong>也没关系，都选ok，在询问是否修改x-configuration，请选择默认的<strong>no</strong>，选择yes会导致重启后无法进入系统。</p>
<h3 id="使用nvidia-smi命令测试"><a href="#使用nvidia-smi命令测试" class="headerlink" title="使用nvidia-smi命令测试"></a>使用nvidia-smi命令测试</h3><p>英伟达系统管理接口（NVIDIA System Management Interface, 简称 nvidia-smi）是基于NVIDIA Management Library (NVML) 的命令行管理组件,旨在(intened to )帮助管理和监控NVIDIA GPU设备。</p>
<p>驱动安装完成后，启动电脑，之后就能用nvidia-smi命令判断驱动是否安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">nvidia-smi</span><br></pre></td></tr></table></figure>

<p>执行这条命令将会打印出当前系统安装的NVIDIA驱动信息，如下：</p>
<p><img src="https://s2.ax1x.com/2019/09/18/n7y6I0.png" alt="image"></p>
<p>若出现上图中的结果则说明英伟达驱动安装成功。</p>
<h3 id="安装CUDA10-1"><a href="#安装CUDA10-1" class="headerlink" title="安装CUDA10.1"></a>安装CUDA10.1</h3><p>CUDA是什么？  </p>
<blockquote>
<blockquote>
<p>CUDA，Compute Unified Device Architecture的简称，是由NVIDIA公司创立的基于他们公司生产的图形处理器GPUs（Graphics Processing Units,可以通俗的理解为显卡）的一个并行计算平台和编程模型。<br>        通过CUDA，GPUs可以很方便地被用来进行通用计算（有点像在CPU中进行的数值计算等等）。在没有CUDA之前，GPUs一般只用来进行图形渲染（如通过OpenGL，DirectX）。</p>
</blockquote>
</blockquote>
<p>下载<a href="https://developer.nvidia.com/cuda-downloads" target="_blank" rel="noopener">地址</a>，选择对应版本的cuda安装包，我这里选择的是<code>runfile</code>类型的，不要选择使用<code>deb</code>版本，<strong>安装CUDA时一定使用runfile文件，这样可以进行选择不再安装驱动</strong>。</p>
<p><img src="https://s2.ax1x.com/2019/09/18/n76jhV.png" alt="img"></p>
<p>在安装界面，<strong>注意选择不安装显卡驱动</strong>（按enter键取消选择）</p>
<p><img src="https://s2.ax1x.com/2019/09/18/n7gC28.png" alt="img"></p>
<p>。之后，打开/usr/local文件夹，我们会发现多了cuda和cuda10.1这两个文件夹，如下所示：</p>
<p><img src="https://s2.ax1x.com/2019/09/18/n7goZj.png" alt="img"></p>
<h3 id="添加环境变量"><a href="#添加环境变量" class="headerlink" title="添加环境变量"></a>添加环境变量</h3><p>运行<code>sudo vim /etc/profile</code>，末尾加上：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export CUDA_HOME=/usr/local/cuda </span><br><span class="line">export PATH=$PATH:$CUDA_HOME/bin </span><br><span class="line">export LD_LIBRARY_PATH=/usr/local/cuda-10.1/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>之后运行<code>source /etc/profile</code>使变量起效。</p>
<h3 id="判断CUDA安装成功"><a href="#判断CUDA安装成功" class="headerlink" title="判断CUDA安装成功"></a>判断CUDA安装成功</h3><p>运行一下代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd /usr/local/cuda/samples/1_Utilities/deviceQuery </span><br><span class="line">sudo make</span><br><span class="line">./deviceQuery</span><br></pre></td></tr></table></figure>

<p>如果输出如下类似信息，说明CUDA安装成功：</p>
<p><img src="https://s2.ax1x.com/2019/09/18/n72x9P.png" alt="img"></p>
<p>在CUDA安装之后，我们其实已经可以用PyTorch判断是否支持GPU了，进入python控制台：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import torch</span><br><span class="line">print(torch.cuda.is_available())</span><br></pre></td></tr></table></figure>

<h3 id="CUDA与cuDNN的关系"><a href="#CUDA与cuDNN的关系" class="headerlink" title="CUDA与cuDNN的关系"></a>CUDA与cuDNN的关系</h3><p>cuDNN是GPU加速计算深层神经网络的库。把CUDA看作是一个工作台，上面配有很多工具，如锤子、螺丝刀等。cuDNN是基于CUDA的深度学习GPU加速库，有了它才能在GPU上完成深度学习的计算。它就相当于工作的工具，比如它就是个扳手。但是CUDA这个工作台买来的时候，并没有送扳手。想要在CUDA上运行深度神经网络，就要安装cuDNN，就像你想要拧个螺帽就要把扳手买回来。这样才能使GPU进行深度神经网络的工作，工作速度相较CPU快很多。</p>
<h3 id="安装cuDNN"><a href="#安装cuDNN" class="headerlink" title="安装cuDNN"></a>安装cuDNN</h3><p><a href="https://docs.nvidia.com/deeplearning/sdk/cudnn-install/index.html#install-linux" target="_blank" rel="noopener">官方安装cuDNN指南</a><br>从官方安装指南可以看出，只要把<strong>cuDNN文件复制到CUDA的对应文件夹</strong>里就可以，即是所谓插入式设计，把cuDNN数据库添加CUDA里，cuDNN是CUDA的扩展计算库，不会对CUDA造成其他影响。<br><img src="https://s2.ax1x.com/2019/09/20/njMwDK.png" alt="官方安装cuDNN指南"></p>
<p>首先去<a href="https://developer.nvidia.com/rdp/cudnn-archive" target="_blank" rel="noopener">官网</a>下载cuDNN，需要注册一个账号才能下载。注意要选择对应版本的<strong>cuDNN Library for Linux</strong>（与CUDA 10.1对应）： </p>
<p><img src="https://s2.ax1x.com/2019/09/18/n7W98x.png" alt="img"><br>下载后进行解压：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tar -zxvf cudnn-10.1-linux-x64-v7.6.2.24.tgz</span><br></pre></td></tr></table></figure>

<p>进入cudnn 10.1解压之后的include目录，在命令行进行如下操作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd cuda/include</span><br><span class="line">sudo cp cudnn.h /usr/local/cuda/include  #复制头文件</span><br></pre></td></tr></table></figure>

<p>再将进入lib64目录下的动态文件进行复制和链接：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">cd ..</span><br><span class="line">cd lib64</span><br><span class="line">sudo cp libcudnn* /usr/local/cuda/lib64/    #复制动态链接库</span><br><span class="line">cd /usr/local/cuda/lib64/</span><br><span class="line">sudo chmod +r libcudnn.so.7.6.2</span><br><span class="line">sudo ln -sf libcudnn.so.7.6.2 libcudnn.so.7</span><br><span class="line">sudo ln -sf libcudnn.so.7 libcudnn.so</span><br><span class="line">sudo chmod a+r /usr/local/cuda/include/cudnn.h /usr/local/cuda/lib64/libcudnn*</span><br><span class="line">sudo ldconfig</span><br></pre></td></tr></table></figure>

<p>参考文章：</p>
<ul>
<li><a href="https://blog.csdn.net/oTengYue/article/details/79506758" target="_blank" rel="noopener">https://blog.csdn.net/oTengYue/article/details/79506758</a></li>
<li><a href="https://shomy.top/2016/12/29/gpu-tensorflow-install" target="_blank" rel="noopener">https://shomy.top/2016/12/29/gpu-tensorflow-install</a></li>
<li><a href="https://www.jianshu.com/p/622f47f94784" target="_blank" rel="noopener">简书——CUDA与cuDNN</a></li>
</ul>
]]></content>
      <categories>
        <category>机器学习</category>
      </categories>
      <tags>
        <tag>NVI</tag>
        <tag>CUDA</tag>
        <tag>cuDNN</tag>
      </tags>
  </entry>
  <entry>
    <title>Arduino使用DHT11测量温湿度</title>
    <url>/2019/08/30/arduino_DTH11/</url>
    <content><![CDATA[<h2 id="概览"><a href="#概览" class="headerlink" title="概览"></a>概览</h2><p>这篇文章很简单（就是一点电工知识），就是利用<a href="https://baike.baidu.com/item/DHT11/1206271" target="_blank" rel="noopener">DHT11</a>温湿度传感器测量温湿度值，并把结果显示在<a href="https://baike.baidu.com/item/LCD1602/6014393" target="_blank" rel="noopener">1602 LCD</a>显示器上。</p>
<a id="more"></a>

<h2 id="实验元器件列表"><a href="#实验元器件列表" class="headerlink" title="实验元器件列表"></a>实验元器件列表</h2><table>
<thead>
<tr>
<th>元器件</th>
<th>型号</th>
<th>数量</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>主控板</td>
<td>arduino Uno</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>温湿度传感器</td>
<td>DHT11</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>液晶屏</td>
<td>1602 LCD</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>电阻</td>
<td>1K电阻</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>面包板</td>
<td></td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>面包板条线</td>
<td></td>
<td>若个</td>
<td></td>
</tr>
<tr>
<td>数据线</td>
<td>Uno数据线</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
<h2 id="工具和元器件介绍"><a href="#工具和元器件介绍" class="headerlink" title="工具和元器件介绍"></a>工具和元器件介绍</h2><h3 id="DHT11温湿度传感器"><a href="#DHT11温湿度传感器" class="headerlink" title="DHT11温湿度传感器"></a>DHT11温湿度传感器</h3><p><img src="https://s2.ax1x.com/2019/08/29/mLoDuF.png" alt><br>DHT11 传感器接线方法并不复杂，DHT11封装有4个引脚，各个引脚说明如下：</p>
<table>
<thead>
<tr>
<th>Pin</th>
<th>名称</th>
<th>注释</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>VDD</td>
<td>供电 3-5.5 VDC</td>
</tr>
<tr>
<td>2</td>
<td>DATA</td>
<td>串行数据，单总线</td>
</tr>
<tr>
<td>3</td>
<td>NC</td>
<td>空脚</td>
</tr>
<tr>
<td>4</td>
<td>GND</td>
<td>接地，电源负极</td>
</tr>
</tbody></table>
<h3 id="1602-LCD"><a href="#1602-LCD" class="headerlink" title="1602 LCD"></a>1602 LCD</h3><p><img src="https://s2.ax1x.com/2019/09/04/nE8k7R.jpg" alt="1602图片"></p>
<p>1602字符型液晶，是一种专门用来显示字母、数字、符号等的点阵型液晶模块，能够同时显示16x02即32个字符。</p>
<p>1602 LCD分为两种：带背光和不带背光，带背光的要后一些，引脚多2个，为16个引脚，如下：</p>
<p><img src="https://s2.ax1x.com/2019/08/29/mLTcqg.png" alt></p>
<h5 id="引脚说明"><a href="#引脚说明" class="headerlink" title="引脚说明"></a>引脚说明</h5><p>1602 LCD通常有14条引脚或16条引脚，14与16引脚的差别在于16条引脚多了背光电源线VCC(15脚)和地线GND(16脚)，其它引脚与14脚的LCD完全一样，如下：</p>
<table>
<thead>
<tr>
<th>引脚</th>
<th>符号</th>
<th>功能说明</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>VSS</td>
<td>一般接地</td>
</tr>
<tr>
<td>2</td>
<td>VDD</td>
<td>接电源（+5V）</td>
</tr>
<tr>
<td>3</td>
<td>V0</td>
<td>液晶显示器对比度调整端，接正电源时对比度最弱，接地电源时对比度最高（对比度过高时会产生“鬼影”，使用时可以通过一个10K的电位器调整对比度）</td>
</tr>
<tr>
<td>4</td>
<td>RS</td>
<td>RS为寄存器选择，高电平1时选择数据寄存器、低电平0时选择指令寄存器</td>
</tr>
<tr>
<td>5</td>
<td>R/W</td>
<td>R/W为读写信号线，高电平(1)时进行读操作，低电平(0)时进行写操作</td>
</tr>
<tr>
<td>6</td>
<td>E</td>
<td>E(或EN)端为使能(enable)端，写操作时，下降沿使能；读操作时，E高电平有效</td>
</tr>
<tr>
<td>7</td>
<td>DB0</td>
<td>低4位三态、 双向数据总线 0位（最低位）</td>
</tr>
<tr>
<td>8</td>
<td>DB1</td>
<td>高4位三态、 双向数据总线 1位</td>
</tr>
<tr>
<td>9</td>
<td>DB2</td>
<td>高4位三态、 双向数据总线 2位</td>
</tr>
<tr>
<td>10</td>
<td>DB3</td>
<td>高4位三态、 双向数据总线 3位</td>
</tr>
<tr>
<td>11</td>
<td>DB4</td>
<td>高4位三态、 双向数据总线 4位</td>
</tr>
<tr>
<td>12</td>
<td>DB5</td>
<td>高4位三态、 双向数据总线 5位</td>
</tr>
<tr>
<td>13</td>
<td>DB6</td>
<td>高4位三态、 双向数据总线 6位</td>
</tr>
<tr>
<td>14</td>
<td>DB7</td>
<td>高4位三态、 双向数据总线 7位（busy flag）</td>
</tr>
<tr>
<td>15</td>
<td>BLA</td>
<td>背光电源正极</td>
</tr>
<tr>
<td>16</td>
<td>BLK</td>
<td>背光电源负极</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>单片机</category>
      </categories>
      <tags>
        <tag>arduino</tag>
        <tag>传感器</tag>
      </tags>
  </entry>
  <entry>
    <title>Vagrant本地快速启动Kubernetes集群</title>
    <url>/2019/12/16/Vagrant_Kubernetes_cluster/</url>
    <content><![CDATA[<p><img src="https://image-static.segmentfault.com/311/703/311703680-5b80e2877f8c8_articlex" alt="k8s logo"></p>
<p>Kubernetes，简称 <strong>k8s</strong>（k，8 个字符，s——明白了？）或者 “kube”，是一个开源的 Linux 容器自动化运维平台，它消除了容器化应用程序在部署、伸缩时涉及到的许多手动操作。换句话说，你可以将多台主机组合成集群来运行 Linux 容器，而 Kubernetes 可以帮助你简单高效地管理那些集群。构成这些集群的主机还可以跨越公有云、私有云以及混合云。</p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.3 LTS</li>
<li>Vagrant版本：2.2.6</li>
<li>VirtualBox版本：6.0.14 r133895 (Qt5.9.5)</li>
<li>Kubernetes版本：1.16.3</li>
</ul>
<a id="more"></a>

<h2 id="安装Vagrant"><a href="#安装Vagrant" class="headerlink" title="安装Vagrant"></a>安装Vagrant</h2><p>Vagrant是一个基于Ruby的工具，用于创建和部署虚拟化开发环境。它使用Oracle的开源<strong>VirtualBox</strong>（其实也可以用别的）虚拟化系统，使用Chef创建自动化虚拟环境。<br>首先到<a href="https://www.vagrantup.com/downloads.html" target="_blank" rel="noopener">官网</a>下载最新的<code>Vagrant</code>，现在最新的版本是<strong>2.2.6</strong>，当然你也可以通过命令行下载：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://releases.hashicorp.com/vagrant/2.2.6/vagrant_2.2.6_x86_64.deb</span><br></pre></td></tr></table></figure>

<p>验证<code>Vagrant</code>安装成功</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vagrant --version</span><br><span class="line">Vagrant 2.2.6</span><br></pre></td></tr></table></figure>

<h2 id="安装VirtualBox"><a href="#安装VirtualBox" class="headerlink" title="安装VirtualBox"></a>安装VirtualBox</h2><p>Vagrant是基于虚拟机（<code>VirtualBox</code>，<code>VMware</code>这些）的，所以我们还需要安装<code>VirtualBox</code>。在Vagrant官网可以它适配的<code>VirtualBox</code>版本</p>
<blockquote>
<p>Vagrant comes with support out of the box for VirtualBox, a free, cross-platform consumer virtualization product.<br>The VirtualBox provider is compatible with VirtualBox versions 4.0.x, 4.1.x, 4.2.x, 4.3.x, 5.0.x, 5.1.x, 5.2.x, and 6.0.x.</p>
</blockquote>
<p>这里我下载6.0版本的<code>VirtualBox</code>，<a href="https://www.virtualbox.org/wiki/Download_Old_Builds_6_0" target="_blank" rel="noopener">下载地址</a></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">wget https://download.virtualbox.org/virtualbox/6.0.14/virtualbox-6.0_6.0.14-133895~Ubuntu~bionic_amd64.deb</span><br></pre></td></tr></table></figure>

<p><strong>注意：不要通过apt-get安装VirtualBox</strong>，因为5.1.0版本开始，VirtualBox已经不需要<strong>DKMS</strong>，apt官方源中VirtualBox比较老，是会带上<code>DKMS</code>的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">DKMS isn&apos;t required by VirtualBox since 5.1.0. Which means that you downloaded VirtualBox from your Debian &quot;store&quot;. That&apos;s a fork, not supported. You can either ask in their forums for help, or completely remove/uninstall/delete/purge their version and install the official version from the Downloads section of VirtualBox (https://www.virtualbox.org/wiki/Downloads).</span><br></pre></td></tr></table></figure>

<h2 id="启动虚拟机"><a href="#启动虚拟机" class="headerlink" title="启动虚拟机"></a>启动虚拟机</h2><p><code>Vagrant</code>跟docker类似，可以提供一致性环境的，它可以编写<code>Vagrantfile</code>（类似<code>docker-compose.yml</code>）来定义虚拟机中安装什么软件，环境和配置，它使用ruby语法。<code>Vagrant</code>也做了<a href="https://app.vagrantup.com/boxes/search" target="_blank" rel="noopener">box源</a>，类似docker image。<br>下面给出一个小栗子感受下，这里使用<code>ubuntu/xenial64</code>（Ubuntu 16.06 64位）这个box</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- mode: ruby -*-</span><br><span class="line"># vi: set ft=ruby :</span><br><span class="line"></span><br><span class="line"># All Vagrant configuration is done below. The &quot;2&quot; in Vagrant.configure</span><br><span class="line"># configures the configuration version (we support older styles for</span><br><span class="line"># backwards compatibility). Please don&apos;t change it unless you know what</span><br><span class="line"># you&apos;re doing.</span><br><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">  ##### DEFINE VM #####</span><br><span class="line">  # The most common configuration options are documented and commented below.</span><br><span class="line">  # For a complete reference, please see the online documentation at</span><br><span class="line">  # https://docs.vagrantup.com.</span><br><span class="line"></span><br><span class="line">  # Every Vagrant development environment requires a box. You can search for</span><br><span class="line">  # boxes at https://app.vagrantup.com/boxes/search.</span><br><span class="line">  config.vm.box = &quot;ubuntu/xenial64&quot;</span><br><span class="line"></span><br><span class="line">  config.vm.hostname = &quot;ubuntu-01&quot;</span><br><span class="line">  config.vm.box_check_update = false</span><br><span class="line"></span><br><span class="line">  # Create a private network, which allows host-only access to the machine</span><br><span class="line">  # using a specific IP.</span><br><span class="line">  config.vm.network &quot;private_network&quot;, ip: &quot;192.168.10.50&quot;</span><br><span class="line"></span><br><span class="line">  # Create a public network, which generally matched to bridged network.</span><br><span class="line">  # Bridged networks make the machine appear as another physical device on</span><br><span class="line">  # your network.</span><br><span class="line">  # config.vm.network &quot;public_network&quot;</span><br><span class="line"></span><br><span class="line">  # Share an additional folder to the guest VM. The first argument is</span><br><span class="line">  # the path on the host to the actual folder. The second argument is</span><br><span class="line">  # the path on the guest to mount the folder. And the optional third</span><br><span class="line">  # argument is a set of non-required options.</span><br><span class="line">  # config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  # Provider-specific configuration so you can fine-tune various</span><br><span class="line">  # backing providers for Vagrant. These expose provider-specific options.</span><br><span class="line">  # Example for VirtualBox:</span><br><span class="line">  #</span><br><span class="line">  # config.vm.provider &quot;virtualbox&quot; do |vb|</span><br><span class="line">  #   # Display the VirtualBox GUI when booting the machine</span><br><span class="line">  #   vb.gui = true</span><br><span class="line">  #</span><br><span class="line">  #   # Customize the amount of memory on the VM:</span><br><span class="line">  #   vb.memory = &quot;1024&quot;</span><br><span class="line">  # end</span><br><span class="line">  #</span><br><span class="line">  # View the documentation for the provider you are using for more</span><br><span class="line">  # information on available options.</span><br><span class="line">  </span><br><span class="line">  config.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line">    v.name = &quot;ubuntu-for-fun&quot;</span><br><span class="line">    v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, &quot;2048&quot;]</span><br><span class="line">    v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, &quot;2&quot;]</span><br><span class="line">  end</span><br><span class="line"></span><br><span class="line">  # Create a forwarded port mapping which allows access to a specific port</span><br><span class="line">  # within the machine from a port on the host machine. In the example below,</span><br><span class="line">  # accessing &quot;localhost:8080&quot; will access port 80 on the guest machine.</span><br><span class="line">  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>更多虚拟机的配置可以查看<a href="https://www.vagrantup.com/docs/vagrantfile/machine_settings.html" target="_blank" rel="noopener">官方文档</a><br>在Vagrantfile对应的目录下终端键入：<code>vagrant up</code>，然后<code>Vagrant</code>会帮我们下载<code>ubuntu/xenial64</code>这个box，不过在中国下载速度非常慢，在运行<code>vagrant up</code>时我们可以看到这个box的下载url，你可以用<strong>迅雷</strong>这些工具直接下载，然后在本地手动添加box</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ vagrant up</span><br><span class="line">Bringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...</span><br><span class="line">==&gt; default: Box &apos;ubuntu/xenial64&apos; could not be found. Attempting to find and install...</span><br><span class="line">    default: Box Provider: virtualbox</span><br><span class="line">    default: Box Version: &gt;= 0</span><br><span class="line">==&gt; default: Loading metadata for box &apos;ubuntu/xenial64&apos;</span><br><span class="line">    default: URL: https://vagrantcloud.com/ubuntu/xenial64</span><br><span class="line">==&gt; default: Adding box &apos;ubuntu/xenial64&apos; (v20191217.0.0) for provider: virtualbox</span><br><span class="line">    default: Downloading: https://vagrantcloud.com/ubuntu/boxes/xenial64/versions/20191217.0.0/providers/virtualbox.box</span><br><span class="line">==&gt; default: Box download is resuming from prior download progress</span><br><span class="line">    default: Download redirected to host: cloud-images.ubuntu.com</span><br><span class="line">    .........</span><br><span class="line"></span><br><span class="line">$ cd ~/box-add</span><br><span class="line">$ ls</span><br><span class="line">metadata.json  virtualbox.box</span><br><span class="line">$ vagrant box add metadata.json</span><br><span class="line">==&gt; box: Loading metadata for box &apos;metadata.json&apos;</span><br><span class="line">    box: URL: file:///home/lucy/vm-add/metadata.json</span><br><span class="line">==&gt; box: Adding box &apos;ubuntu/xenial64&apos; (v20191217.0.0) for provider: virtualbox</span><br><span class="line">    box: Downloading: ./virtualbox.box</span><br><span class="line">==&gt; box: Successfully added box &apos;ubuntu/xenial64&apos; (v20191217.0.0) for &apos;virtualbox&apos;!</span><br><span class="line">$ vagrant box list</span><br><span class="line">ubuntu/xenial64 (virtualbox, 20191217.0.0)</span><br></pre></td></tr></table></figure>

<p>下载box的URL是<code>https://vagrantcloud.com/ubuntu/boxes/xenial64/versions/20191217.0.0/providers/virtualbox.box</code>，可以看到下载的版本是<strong>20191217.0.0</strong>，另外注意一下这里添加box的是使用一个<code>metadata.json</code>文件，使用这样的方式可以定义box版本号，它的内容是：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;name&quot;: &quot;ubuntu/xenial64&quot;,</span><br><span class="line">    &quot;versions&quot;: [&#123;</span><br><span class="line">        &quot;version&quot;: &quot;20191217.0.0&quot;,</span><br><span class="line">        &quot;providers&quot;: [&#123;</span><br><span class="line">            &quot;name&quot;: &quot;virtualbox&quot;,</span><br><span class="line">            &quot;url&quot;: &quot;./virtualbox.box&quot;</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>启动虚拟机你可能会遇到下面的错误：</p>
<p><img src="/images/virtualbox-error.png" alt="upload successful"></p>
<p>解决方法是在<strong>BIOS</strong>中将<strong>Intel Virtualization Technology</strong>改为Enable。<br>启动虚拟机后，你可以通过<code>vagrant ssh</code>进入虚拟机。</p>
<h2 id="启动Kubernetes集群"><a href="#启动Kubernetes集群" class="headerlink" title="启动Kubernetes集群"></a>启动Kubernetes集群</h2><p>这里我编写了一个<code>Vagrantfile</code>，一键启动集群：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># -*- mode: ruby -*-</span><br><span class="line"># vi: set ft=ruby :</span><br><span class="line"></span><br><span class="line">k8sVersion = &apos;1.16.3&apos;</span><br><span class="line">servers = [</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; &quot;k8s-head&quot;,</span><br><span class="line">        :type =&gt; &quot;master&quot;,</span><br><span class="line">        :box =&gt; &quot;ubuntu/xenial64&quot;,</span><br><span class="line">        :box_version =&gt; &quot;20191217.0.0&quot;,</span><br><span class="line">        :eth1 =&gt; &quot;192.168.205.10&quot;,</span><br><span class="line">        :mem =&gt; &quot;2048&quot;,</span><br><span class="line">        :cpu =&gt; &quot;2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; &quot;k8s-node-1&quot;,</span><br><span class="line">        :type =&gt; &quot;node&quot;,</span><br><span class="line">        :box =&gt; &quot;ubuntu/xenial64&quot;,</span><br><span class="line">        :box_version =&gt; &quot;20191217.0.0&quot;,</span><br><span class="line">        :eth1 =&gt; &quot;192.168.205.11&quot;,</span><br><span class="line">        :mem =&gt; &quot;2048&quot;,</span><br><span class="line">        :cpu =&gt; &quot;2&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;</span><br><span class="line">        :name =&gt; &quot;k8s-node-2&quot;,</span><br><span class="line">        :type =&gt; &quot;node&quot;,</span><br><span class="line">        :box =&gt; &quot;ubuntu/xenial64&quot;,</span><br><span class="line">        :box_version =&gt; &quot;20191217.0.0&quot;,</span><br><span class="line">        :eth1 =&gt; &quot;192.168.205.12&quot;,</span><br><span class="line">        :mem =&gt; &quot;2048&quot;,</span><br><span class="line">        :cpu =&gt; &quot;2&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line"># This script to install k8s using kubeadm will get executed after a box is provisioned</span><br><span class="line">$configureBox = &lt;&lt;-SCRIPT</span><br><span class="line">    cp /etc/apt/sources.list /etc/apt/sources.list.bak</span><br><span class="line">    # use Aliyun apt source</span><br><span class="line">    cat &gt; /etc/apt/sources.list&lt;&lt;EOF</span><br><span class="line"># 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-updates main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-backports main restricted universe multiverse</span><br><span class="line">deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line"># deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ xenial-security main restricted universe multiverse</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">    export DEBIAN_FRONTEND=noninteractive</span><br><span class="line"></span><br><span class="line">    # install docker v17.03</span><br><span class="line">    # reason for not using docker provision is that it always installs latest version of the docker, but kubeadm requires 17.03 or older</span><br><span class="line">    apt-get update</span><br><span class="line">    # step 1: 安装必要的一些系统工具</span><br><span class="line">    apt-get install -y apt-transport-https ca-certificates curl software-properties-common</span><br><span class="line">    # step 2: 安装GPG证书</span><br><span class="line">    curl -fsSL http://mirrors.aliyun.com/docker-ce/linux/ubuntu/gpg | sudo apt-key add -</span><br><span class="line">    add-apt-repository &quot;deb [arch=amd64] http://mirrors.aliyun.com/docker-ce/linux/$(. /etc/os-release; echo &quot;$ID&quot;) $(lsb_release -cs) stable&quot;</span><br><span class="line">    apt-get update &amp;&amp; apt-get install -y docker-ce=$(apt-cache madison docker-ce | grep 17.03 | head -1 | awk &apos;&#123;print $3&#125;&apos;)</span><br><span class="line">    # run docker commands as vagrant user (sudo not required)</span><br><span class="line">    usermod -aG docker vagrant</span><br><span class="line">    # 修改docker配置</span><br><span class="line">    sudo bash -c &apos;cat &gt; /etc/docker/daemon.json &lt;&lt;EOF</span><br><span class="line">&#123;</span><br><span class="line">  &quot;exec-opts&quot;: [&quot;native.cgroupdriver=systemd&quot;],</span><br><span class="line">  &quot;log-driver&quot;: &quot;json-file&quot;,</span><br><span class="line">  &quot;log-opts&quot;: &#123;</span><br><span class="line">    &quot;max-size&quot;: &quot;100m&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;storage-driver&quot;: &quot;overlay2&quot;</span><br><span class="line">&#125;</span><br><span class="line">EOF&apos;</span><br><span class="line">    sudo systemctl daemon-reload</span><br><span class="line">    sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">    # install kubeadm</span><br><span class="line">    apt-get install -y apt-transport-https curl</span><br><span class="line">    curl -s https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpg | sudo apt-key add -  # aliyun GPG</span><br><span class="line">    cat &lt;&lt;EOF &gt;/etc/apt/sources.list.d/kubernetes.list</span><br><span class="line">    deb https://mirrors.aliyun.com/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">    apt-get update</span><br><span class="line">    apt-get install -y kubelet=#&#123;k8sVersion&#125;-00 kubeadm=#&#123;k8sVersion&#125;-00 kubectl=#&#123;k8sVersion&#125;-00</span><br><span class="line">    apt-mark hold kubelet kubeadm kubectl</span><br><span class="line">    # kubelet requires swap off</span><br><span class="line">    swapoff -a</span><br><span class="line">    # keep swap off after reboot</span><br><span class="line">    sudo sed -i &apos;/ swap / s/^\(.*\)$/#\1/g&apos; /etc/fstab</span><br><span class="line">    # ip of this box</span><br><span class="line">    IP_ADDR=`ifconfig enp0s8 | grep Mask | awk &apos;&#123;print $2&#125;&apos;| cut -f2 -d:`</span><br><span class="line">    # set node-ip</span><br><span class="line">    sudo sh -c &apos;echo KUBELET_EXTRA_ARGS= &gt;&gt; /etc/default/kubelet&apos;</span><br><span class="line">    sudo sed -i &quot;/^[^#]*KUBELET_EXTRA_ARGS=/c\KUBELET_EXTRA_ARGS=--node-ip=$IP_ADDR&quot; /etc/default/kubelet</span><br><span class="line">    sudo systemctl restart kubelet</span><br><span class="line">SCRIPT</span><br><span class="line"></span><br><span class="line">$configureMaster = &lt;&lt;-SCRIPT</span><br><span class="line">    export DEBIAN_FRONTEND=noninteractive</span><br><span class="line">    echo &quot;This is master&quot;</span><br><span class="line">    # ip of this box</span><br><span class="line">    IP_ADDR=`ifconfig enp0s8 | grep Mask | awk &apos;&#123;print $2&#125;&apos;| cut -f2 -d:`</span><br><span class="line">    # install k8s master</span><br><span class="line">    HOST_NAME=$(hostname -s)</span><br><span class="line">    kubeadm init --image-repository registry.aliyuncs.com/google_containers  --kubernetes-version v#&#123;k8sVersion&#125; \</span><br><span class="line">    --apiserver-advertise-address=$IP_ADDR --apiserver-cert-extra-sans=$IP_ADDR  --node-name $HOST_NAME --pod-network-cidr=172.16.0.0/16</span><br><span class="line">    #copying credentials to regular user - vagrant</span><br><span class="line">    sudo --user=vagrant mkdir -p /home/vagrant/.kube</span><br><span class="line">    cp -i /etc/kubernetes/admin.conf /home/vagrant/.kube/config</span><br><span class="line">    chown $(id -u vagrant):$(id -g vagrant) /home/vagrant/.kube/config</span><br><span class="line"></span><br><span class="line">    # install Calico pod network addon</span><br><span class="line">    export KUBECONFIG=/etc/kubernetes/admin.conf</span><br><span class="line">    wget https://docs.projectcalico.org/v3.10/getting-started/kubernetes/installation/hosted/kubernetes-datastore/calico-networking/1.7/calico.yaml</span><br><span class="line">    # Pod的ip范围</span><br><span class="line">    sed -i &apos;s/192.168.0.0/172.16.0.0/g&apos; calico.yaml</span><br><span class="line">    kubectl apply -f calico.yaml</span><br><span class="line">    kubeadm token create --print-join-command &gt;&gt; /etc/kubeadm_join_cmd.sh</span><br><span class="line">    chmod +x /etc/kubeadm_join_cmd.sh</span><br><span class="line">    # required for setting up password less ssh between guest VMs</span><br><span class="line">    sudo sed -i &quot;/^[^#]*PasswordAuthentication[[:space:]]no/c\PasswordAuthentication yes&quot; /etc/ssh/sshd_config</span><br><span class="line">    sudo service sshd restart</span><br><span class="line">SCRIPT</span><br><span class="line"></span><br><span class="line">$configureNode = &lt;&lt;-SCRIPT</span><br><span class="line">    export DEBIAN_FRONTEND=noninteractive</span><br><span class="line">    echo &quot;This is worker&quot;</span><br><span class="line">    apt-get install -y sshpass</span><br><span class="line">    sshpass -p &quot;vagrant&quot; scp -o StrictHostKeyChecking=no vagrant@192.168.205.10:/etc/kubeadm_join_cmd.sh .</span><br><span class="line">    sh ./kubeadm_join_cmd.sh</span><br><span class="line">SCRIPT</span><br><span class="line"></span><br><span class="line">Vagrant.configure(&quot;2&quot;) do |config|</span><br><span class="line">    </span><br><span class="line">    servers.each do |opts|</span><br><span class="line">        config.vm.define opts[:name] do |config|</span><br><span class="line"></span><br><span class="line">            config.vm.box = opts[:box]</span><br><span class="line">            config.vm.box_version = opts[:box_version]</span><br><span class="line">            config.vm.hostname = opts[:name]</span><br><span class="line">            config.vm.network :private_network, ip: opts[:eth1]</span><br><span class="line"></span><br><span class="line">            config.vm.provider &quot;virtualbox&quot; do |v|</span><br><span class="line"></span><br><span class="line">                v.name = opts[:name]</span><br><span class="line">            	v.customize [&quot;modifyvm&quot;, :id, &quot;--groups&quot;, &quot;/Salamander Development&quot;]</span><br><span class="line">                v.customize [&quot;modifyvm&quot;, :id, &quot;--memory&quot;, opts[:mem]]</span><br><span class="line">                v.customize [&quot;modifyvm&quot;, :id, &quot;--cpus&quot;, opts[:cpu]]</span><br><span class="line">                v.customize [&quot;modifyvm&quot;, :id, &quot;--natdnshostresolver1&quot;, &quot;on&quot;]</span><br><span class="line">                v.customize [&quot;modifyvm&quot;, :id, &quot;--natdnsproxy1&quot;, &quot;on&quot;]</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">            # we cannot use this because we can&apos;t install the docker version we want - https://github.com/hashicorp/vagrant/issues/4871</span><br><span class="line">            #config.vm.provision &quot;docker&quot;</span><br><span class="line"></span><br><span class="line">            config.vm.provision &quot;shell&quot;, inline: $configureBox</span><br><span class="line"></span><br><span class="line">            if opts[:type] == &quot;master&quot;</span><br><span class="line">                config.vm.provision &quot;shell&quot;, inline: $configureMaster</span><br><span class="line">            else</span><br><span class="line">                config.vm.provision &quot;shell&quot;, inline: $configureNode</span><br><span class="line">            end</span><br><span class="line"></span><br><span class="line">        end</span><br><span class="line"></span><br><span class="line">    end</span><br><span class="line">end</span><br></pre></td></tr></table></figure>

<p>启动集群<code>vagrant up</code>，这里需要耐心等待几分钟，因为要启动三个虚拟机、安装一些软件和设置环境。<br>启动集群后，进入<strong>Master节点</strong><code>vagrant ssh k8s-head</code>查看集群状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME         STATUS   ROLES    AGE    VERSION</span><br><span class="line">k8s-head     Ready    master   5h7m   v1.15.7</span><br><span class="line">k8s-node-1   Ready    &lt;none&gt;   5h5m   v1.15.7</span><br><span class="line">k8s-node-2   Ready    &lt;none&gt;   5h2m   v1.15.7</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ kubectl get pods --all-namespaces</span><br><span class="line">NAMESPACE              NAME                                         READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system            calico-node-j5kw8                            2/2     Running   4          5h7m</span><br><span class="line">kube-system            calico-node-kq89s                            2/2     Running   0          5h6m</span><br><span class="line">kube-system            calico-node-twvdl                            2/2     Running   0          5h2m</span><br><span class="line">kube-system            coredns-94d74667-jhjl8                       1/1     Running   2          5h7m</span><br><span class="line">kube-system            coredns-94d74667-qd9qv                       1/1     Running   2          5h7m</span><br><span class="line">kube-system            etcd-k8s-head                                1/1     Running   2          5h6m</span><br><span class="line">kube-system            kube-apiserver-k8s-head                      1/1     Running   2          5h6m</span><br><span class="line">kube-system            kube-controller-manager-k8s-head             1/1     Running   2          5h6m</span><br><span class="line">kube-system            kube-proxy-7d8wj                             1/1     Running   0          5h2m</span><br><span class="line">kube-system            kube-proxy-hn89g                             1/1     Running   0          5h6m</span><br><span class="line">kube-system            kube-proxy-t8qf9                             1/1     Running   2          5h7m</span><br><span class="line">kube-system            kube-scheduler-k8s-head                      1/1     Running   2          5h6m</span><br><span class="line"></span><br><span class="line">$ kubectl cluster-info</span><br><span class="line">Kubernetes master is running at https://192.168.205.10:6443</span><br><span class="line">KubeDNS is running at https://192.168.205.10:6443/api/v1/namespaces/kube-system/services/kube-dns:dns/proxy</span><br><span class="line"></span><br><span class="line">$ kubectl get componentstatuses</span><br><span class="line">NAME                 STATUS    MESSAGE             ERROR</span><br><span class="line">scheduler            Healthy   ok                  </span><br><span class="line">controller-manager   Healthy   ok                  </span><br><span class="line">etcd-0               Healthy   &#123;&quot;health&quot;:&quot;true&quot;&#125;</span><br></pre></td></tr></table></figure>

<p>节点都是<strong>Ready</strong>和pods都是<strong>Running</strong>说明集群成功启动了，<code>kubectl cluster-info</code>可以查看集群信息，<code>kubectl get componentstatuses</code>可以查看各组件信息。</p>
<h2 id="安装官方Dashboard"><a href="#安装官方Dashboard" class="headerlink" title="安装官方Dashboard"></a>安装官方Dashboard</h2><p><a href="https://github.com/kubernetes/dashboard" target="_blank" rel="noopener">Dashboard</a>是Kubernetes的一个插件，代码单独放在Github的一个仓库里。<br>按照<a href="https://kubernetes.io/docs/tasks/access-application-cluster/web-ui-dashboard/" target="_blank" rel="noopener">官方文档</a>，步骤也蛮简单的，首先执行命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl apply -f https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml</span><br></pre></td></tr></table></figure>

<p>查看一下Dashboard的服务：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">$ kubectl  get pod,deploy,svc -n kubernetes-dashboard</span><br><span class="line">NAME                                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">pod/dashboard-metrics-scraper-6c554969c6-jqhjx   1/1     Running   0          5h5m</span><br><span class="line">pod/kubernetes-dashboard-56c5f95c6b-jrj58        1/1     Running   5          5h5m</span><br><span class="line"></span><br><span class="line">NAME                                              READY   UP-TO-DATE   AVAILABLE   AGE</span><br><span class="line">deployment.extensions/dashboard-metrics-scraper   1/1     1            1           5h5m</span><br><span class="line">deployment.extensions/kubernetes-dashboard        1/1     1            1           5h5m</span><br><span class="line"></span><br><span class="line">NAME                                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)    AGE</span><br><span class="line">service/dashboard-metrics-scraper   ClusterIP   10.106.117.224   &lt;none&gt;        8000/TCP   5h5m</span><br><span class="line">service/kubernetes-dashboard        ClusterIP   10.98.23.78      &lt;none&gt;        443/TCP    5h5m</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"># 我们可以看到官方的dashboard帮我们启动了web-ui，并且帮我们启动了一个Metric服务</span><br><span class="line"># 但是dashboard默认使用的https的443端口</span><br><span class="line"></span><br><span class="line"># 测试下Dashboard是否正常</span><br><span class="line">$ curl https://10.98.23.78:443 -k -I</span><br><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: no-store</span><br><span class="line">Content-Length: 1262</span><br><span class="line">Content-Type: text/html; charset=utf-8</span><br><span class="line">Last-Modified: Fri, 06 Dec 2019 15:14:02 GMT</span><br><span class="line">Date: Tue, 31 Dec 2019 06:35:55 GMT</span><br></pre></td></tr></table></figure>

<h3 id="访问Dashboard"><a href="#访问Dashboard" class="headerlink" title="访问Dashboard"></a>访问Dashboard</h3><p>访问Dashboard有好几种方式</p>
<ul>
<li>将kubernetes-dashboard Service暴露 NodePort，使用 <a href="http://NodeIP:nodePort" target="_blank" rel="noopener">http://NodeIP:nodePort</a> 地址访问 dashboard</li>
<li>使用Ingress之类的入口服务进行代理访问</li>
<li>通过 API server 访问 dashboard（https 6443端口和http 8080端口方式）</li>
<li>通过 kubectl proxy 访问 dashboard</li>
</ul>
<h4 id="kubectl-proxy"><a href="#kubectl-proxy" class="headerlink" title="kubectl proxy"></a>kubectl proxy</h4><p>首先这里我们通过<code>kubectl proxy</code>，在<strong>k8s-head</strong>节点执行：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl proxy --address=&apos;0.0.0.0&apos; --accept-hosts=&apos;^*$&apos;</span><br></pre></td></tr></table></figure>

<p>在访问之前，我们需要先创建一个<strong>User</strong>（一个<strong>ServiceAccount</strong>，k8s内概念），创建dashboard-adminuser.yaml文件，写入</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">apiVersion: v1</span><br><span class="line">kind: ServiceAccount</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line"></span><br><span class="line">apiVersion: rbac.authorization.k8s.io/v1</span><br><span class="line">kind: ClusterRoleBinding</span><br><span class="line">metadata:</span><br><span class="line">  name: admin-user</span><br><span class="line">roleRef:</span><br><span class="line">  apiGroup: rbac.authorization.k8s.io</span><br><span class="line">  kind: ClusterRole</span><br><span class="line">  name: cluster-admin</span><br><span class="line">subjects:</span><br><span class="line">- kind: ServiceAccount</span><br><span class="line">  name: admin-user</span><br><span class="line">  namespace: kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>执行<code>kubectl apply -f dashboard-adminuser.yaml</code>。<br>查看用户token（之后在浏览器中输入）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk &apos;&#123;print $1&#125;&apos;)</span><br><span class="line">Name:         admin-user-token-mxmtr</span><br><span class="line">Namespace:    kubernetes-dashboard</span><br><span class="line">Labels:       &lt;none&gt;</span><br><span class="line">Annotations:  kubernetes.io/service-account.name: admin-user</span><br><span class="line">              kubernetes.io/service-account.uid: 54ddc041-f3af-41fa-a824-6a3e29f0ffa3</span><br><span class="line"></span><br><span class="line">Type:  kubernetes.io/service-account-token</span><br><span class="line"></span><br><span class="line">Data</span><br><span class="line">====</span><br><span class="line">ca.crt:     1025 bytes</span><br><span class="line">namespace:  20 bytes</span><br><span class="line">token:      eyJhbGciOiJSUzI1NiIsImtpZCI6IiJ9.eyJpc3MiOiJrdWJlcm5ldGVzL3NlcnZpY2VhY2NvdW50Iiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9uYW1lc3BhY2UiOiJrdWJlcm5ldGVzLWRhc2hib2FyZCIsImt1YmVybmV0ZXMuaW8vc2VydmljZWFjY291bnQvc2VjcmV0Lm5hbWUiOiJhZG1pbi11c2VyLXRva2VuLW14bXRyIiwia3ViZXJuZXRlcy5pby9zZXJ2aWNlYWNjb3VudC9zZXJ2aWNlLWFjY291bnQubmFtZSI6ImFkbWluLXVzZXIiLCJrdWJlcm5ldGVzLmlvL3NlcnZpY2VhY2NvdW50L3NlcnZpY2UtYWNjb3VudC51aWQiOiI1NGRkYzA0MS1mM2FmLTQxZmEtYTgyNC02YTNlMjlmMGZmYTMiLCJzdWIiOiJzeXN0ZW06c2VydmljZWFjY291bnQ6a3ViZXJuZXRlcy1kYXNoYm9hcmQ6YWRtaW4tdXNlciJ9.osyqbUwS4pLDEhZ0iL0aAu2f5me82bGTEfXEW8ycS5-JRar4iYcWkqhJZ9FhZV47P0WKLT9UWiLcDw1rVPZbMSHrRnFZcRHmLO35tVBaijjvgsgm2X5856G-HS1VNMgQBSZXiQXr1Lt3Dj9JHHksbiLGg-3wRy7HqD-I8JcR1pHZ_ViOqQ1j6WIbvhfEE3FpTuuSPAcjwVNutXAfur6oJktjYAcwMjWTQ4-yMQ2NRSWM7AcJtjp_7p3WwnHmO6fH6LtrGQzmXwHh5ICmei2LrAE2cxwN251aMVnrPGt00Ff4ij2-yLyI4VZOgAsNuPegctm-GuCOTGNX9Ew-o1si_Q</span><br></pre></td></tr></table></figure>

<p>为了在宿主机上能访问，我们需要用VirutalBox管理界面添加一个端口映射：  </p>
<p><img src="https://s2.ax1x.com/2019/12/31/l1FsQP.png" alt="upload successful"></p>
<p>好了，现在我们可以访问Dashboard了，浏览内输入<code>http://localhost:31694/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/.</code>，可以看到<br><img src="/images/k8s-dashboard.png" alt></p>
<h4 id="NodePort"><a href="#NodePort" class="headerlink" title="NodePort"></a>NodePort</h4><p>这个过程比<code>kubectl proxy</code>简单，再安装Dashboard之前，把<code>Service</code>类型改成<code>NodePort</code>即可：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.0.0-beta8/aio/deploy/recommended.yaml  #下载yaml</span><br><span class="line">$ vim recommended.yaml</span><br></pre></td></tr></table></figure>

<p>找到Service部分，改成NodePort</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">kind: Service</span><br><span class="line">apiVersion: v1</span><br><span class="line">metadata:</span><br><span class="line">  labels:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br><span class="line">  name: kubernetes-dashboard</span><br><span class="line">  namespace: kubernetes-dashboard</span><br><span class="line">spec:</span><br><span class="line">  type: NodePort  # 这个是新增部分</span><br><span class="line">  ports:</span><br><span class="line">    - port: 443</span><br><span class="line">      targetPort: 8443</span><br><span class="line">  selector:</span><br><span class="line">    k8s-app: kubernetes-dashboard</span><br></pre></td></tr></table></figure>

<p>查看，Service的随机端口：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ kubectl get pods,svc --all-namespaces</span><br><span class="line"></span><br><span class="line">NAMESPACE              NAME                                             READY   STATUS    RESTARTS   AGE</span><br><span class="line">kube-system            pod/calico-node-ffn9k                            2/2     Running   10         32d</span><br><span class="line">kube-system            pod/calico-node-fz8v6                            2/2     Running   12         32d</span><br><span class="line">kube-system            pod/calico-node-gvjft                            2/2     Running   8          32d</span><br><span class="line">kube-system            pod/coredns-94d74667-8jp5k                       1/1     Running   4          32d</span><br><span class="line">kube-system            pod/coredns-94d74667-tlph7                       1/1     Running   4          32d</span><br><span class="line">kube-system            pod/etcd-k8s-head                                1/1     Running   4          32d</span><br><span class="line">kube-system            pod/kube-apiserver-k8s-head                      1/1     Running   4          32d</span><br><span class="line">kube-system            pod/kube-controller-manager-k8s-head             1/1     Running   4          32d</span><br><span class="line">kube-system            pod/kube-proxy-4rsp4                             1/1     Running   5          32d</span><br><span class="line">kube-system            pod/kube-proxy-dccdc                             1/1     Running   5          32d</span><br><span class="line">kube-system            pod/kube-proxy-x82tl                             1/1     Running   4          32d</span><br><span class="line">kube-system            pod/kube-scheduler-k8s-head                      1/1     Running   4          32d</span><br><span class="line">kubernetes-dashboard   pod/dashboard-metrics-scraper-6c554969c6-wmwpt   1/1     Running   0          18m</span><br><span class="line">kubernetes-dashboard   pod/kubernetes-dashboard-56c5f95c6b-s66g8        1/1     Running   0          18m</span><br><span class="line"></span><br><span class="line">NAMESPACE              NAME                                TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)                  AGE</span><br><span class="line">default                service/kubernetes                  ClusterIP   10.96.0.1        &lt;none&gt;        443/TCP                  32d</span><br><span class="line">kube-system            service/calico-typha                ClusterIP   10.104.182.223   &lt;none&gt;        5473/TCP                 32d</span><br><span class="line">kube-system            service/kube-dns                    ClusterIP   10.96.0.10       &lt;none&gt;        53/UDP,53/TCP,9153/TCP   32d</span><br><span class="line">kubernetes-dashboard   service/dashboard-metrics-scraper   ClusterIP   10.99.243.131    &lt;none&gt;        8000/TCP                 18m</span><br><span class="line">kubernetes-dashboard   service/kubernetes-dashboard        NodePort    10.96.23.239     &lt;none&gt;        443:30646/TCP            18m</span><br></pre></td></tr></table></figure>

<p>可以看到暴露端口是<strong>30646</strong>，访问Master节点上的30646端口<code>https://192.168.205.10:30646</code>，需要填写的<strong>token</strong>和上面<code>kubectl proxy</code>遇到的问题一样，先创建<strong>ServiceAccount</strong>和<strong>ClusterRoleBinding</strong>，然后查看这个账号的token。</p>
<h4 id="API-Server"><a href="#API-Server" class="headerlink" title="API Server"></a>API Server</h4><p>首先，我们需要导出p12证书：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"># 生成 client-certificate-data</span><br><span class="line">grep &apos;client-certificate-data&apos; ~/.kube/config | head -n 1 | awk &apos;&#123;print $2&#125;&apos; | base64 -d &gt;&gt; kubecfg.crt</span><br><span class="line"></span><br><span class="line"># 生成 client-key-data</span><br><span class="line">grep &apos;client-key-data&apos; ~/.kube/config | head -n 1 | awk &apos;&#123;print $2&#125;&apos; | base64 -d &gt;&gt; kubecfg.key</span><br><span class="line"></span><br><span class="line"># 生成 p12</span><br><span class="line">openssl pkcs12 -export -clcerts -inkey kubecfg.key -in kubecfg.crt -out kubecfg.p12 -name &quot;kubernetes-client&quot;</span><br></pre></td></tr></table></figure>

<p>然后，在在 chrome 导入了 p12 证书（点击“设置”，“管理证书”那里导入）。<br>访问链接：<code>https://192.168.205.10:6443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy</code>，就可以看到<strong>登录界面</strong>了（注意：<strong>新版的Dashboard，命名空间移动到了kubernetes-dashboard中</strong>）<br><img src="https://s2.ax1x.com/2020/01/26/1mG9UJ.png" alt><br><strong>token</strong>的填写跟上面<code>kubectl proxy</code>一样，当然你也可以直接用master节点中<code>$HOME/.kube/config</code>文件来登录。</p>
<h2 id="kubernetes常用命令"><a href="#kubernetes常用命令" class="headerlink" title="kubernetes常用命令"></a>kubernetes常用命令</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">## 查看</span><br><span class="line">kubectl cluster-info    ----查看集群信息</span><br><span class="line">kubectl get pods --all-namespaces ------查看所有pod信息</span><br><span class="line">kubectl get cs    ----查看各组件（componentstatuses）信息，可以简写为rc</span><br><span class="line">kubectl get pods -n default   ----列出default命名空间所有的pods</span><br><span class="line">kubectl get pods -o wide    ----查看pods所在的运行节点</span><br><span class="line">kubectl get pods -o yaml    ----查看pods定义的详细信息</span><br><span class="line">kubectl get rc    ----查看Replication Controller信息</span><br><span class="line">kubectl get service    ----查看service的信息</span><br><span class="line">kubectl get nodes    ----查看节点信息</span><br><span class="line">kubectl get pod --selector name=redis    ----按selector名来查找pod</span><br><span class="line">kubectl exec pod名字 env    ----查看运行的pod的环境变量</span><br><span class="line">kubectl  get pod,deploy,svc -n kubernetes-dashboard ---一起查看pod，service，deployment信息</span><br><span class="line"></span><br><span class="line">## 创建</span><br><span class="line">kubectl create -f 文件名    ----创建</span><br><span class="line">kubectl replace -f 文件名  [--force]    ----重建</span><br><span class="line"></span><br><span class="line">## 删除</span><br><span class="line">kubectl delete -f 文件名</span><br><span class="line">kubectl delete pod pod名</span><br><span class="line">kubectl delete rc rc名</span><br><span class="line">kubectl delete service service名</span><br><span class="line">kubectl delete pod --all</span><br><span class="line">kubectl run mybusybox --image=busybox    ----启动一个pod</span><br><span class="line">kubectl run mybusybox --image=busybox --replicas=5    ----启动多个pod</span><br><span class="line">kubectl delete deployments mybusybox    ----删除创建的pod</span><br><span class="line">kubectl get pods    ----列出当前所有的pod</span><br><span class="line">kubectl describe pod [PODNAME]    ----查看pod的状态</span><br><span class="line">kubectl run mynginx --image=nginx --port=80 --hostport=8000    ----创建带有端口映射的pod</span><br><span class="line">kubectl run -i --tty busybox --image=busybox    ----创建带有终端的pod</span><br></pre></td></tr></table></figure>

<p>参考</p>
<ul>
<li><a href="https://github.com/ecomm-integration-ballerina/kubernetes-cluster" target="_blank" rel="noopener">Github——kubernetes-cluster-via-vagrant</a></li>
<li><a href="https://www.australtech.net/kubernetes-unable-to-login-to-the-dashboard/" target="_blank" rel="noopener">Kubernetes – unable to login to the Dashboard
</a></li>
<li><a href="https://www.cnblogs.com/rainingnight/p/deploying-k8s-dashboard-ui.html#api-server" target="_blank" rel="noopener">kubernetes-dashboard(1.8.3)部署与踩坑</a></li>
</ul>
]]></content>
      <categories>
        <category>kubernetes</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
        <tag>vagrant</tag>
        <tag>virtualbox</tag>
      </tags>
  </entry>
  <entry>
    <title>一步步自己做个Docker之Linux Namespace 简介</title>
    <url>/2019/11/28/docker-Linux-Namespace-intro/</url>
    <content><![CDATA[<p><img src="/images/docker-logo.png" alt="docker logo"></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.3 LTS</li>
<li>内核版本： 5.0.0-36-generic </li>
</ul>
<h2 id="Linux-Namespaces"><a href="#Linux-Namespaces" class="headerlink" title="Linux Namespaces"></a>Linux Namespaces</h2><p>Docker的所用的两个关键技术，一个是<code>Namespaces</code>，一个是<code>Cgroups</code>。它俩都不是新技术，Linux内核很早就支持，但是Docker把它们有机地结合起来，加上自己创新，使得现在容器技术非常流行。<br><code>Linux Namespaces</code>其实是做到了进程之间全局资源的隔离，譬如，<code>UTS Namespace</code>隔离了Hostname空间。这意味着在新的<code>UTS Namespace</code>中的进程，可以拥有不同于宿主机的主机名。 </p>
<a id="more"></a>

<p>目前Linux内核主要实现了以下几种不同的资源<code>Namespace</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>宏定义</th>
<th>隔离的内容</th>
</tr>
</thead>
<tbody><tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>System V IPC, POSIX message queues (since Linux 2.6.19)</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>network device interfaces, IPv4 and IPv6 protocol stacks, IP routing tables, firewall rules, the /proc/net and /sys/class/net directory trees, sockets, etc (since Linux 2.6.24)</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>Mount points (since Linux 2.4.19)</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>Process IDs (since Linux 2.6.24)</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)</td>
</tr>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>Hostname and NIS domain name (since Linux 2.6.19)</td>
</tr>
<tr>
<td>Cgroup</td>
<td>CLONE_NEWCGROUP</td>
<td>Cgroup root directory (since Linux 4.6)</td>
</tr>
</tbody></table>
<p>要注意一点的是，不是所有的系统资源都能隔离，时间就是个例外，没有对应的<code>Namespace</code>，因此同一台Linux启动的容器时间都是相同的。</p>
<h3 id="尝试一下Namespace"><a href="#尝试一下Namespace" class="headerlink" title="尝试一下Namespace"></a>尝试一下Namespace</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lucy@lucy-computer:~$ unshare -h</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line"> unshare [选项] [&lt;程序&gt; [&lt;参数&gt;...]]</span><br><span class="line"></span><br><span class="line">以某些未与父(进程)共享的名字空间运行某个程序。</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"> -m, --mount[=&lt;文件&gt;]      取消共享 mounts 名字空间</span><br><span class="line"> -u, --uts[=&lt;文件&gt;]        取消共享 UTS 名字空间(主机名等)</span><br><span class="line"> -i, --ipc[=&lt;文件&gt;]        取消共享 System V IPC 名字空间</span><br><span class="line"> -n, --net[=&lt;file&gt;]        取消共享网络名字空间</span><br><span class="line"> -p, --pid[=&lt;文件&gt;]        取消共享 pid 名字空间</span><br><span class="line"> -U, --user[=&lt;文件&gt;]       取消共享用户名字空间</span><br><span class="line"> -C, --cgroup[=&lt;文件&gt;]     取消共享 cgroup 名字空间</span><br><span class="line"> -f, --fork                在启动&lt;程序&gt;前 fork</span><br><span class="line">     --mount-proc[=&lt;目录&gt;] 先挂载 proc 文件系统(连带打开 --mount)</span><br><span class="line"> -r, --map-root-user       将当前用户映射为 root (连带打开 --user)</span><br><span class="line">     --propagation slave|shared|private|unchanged</span><br><span class="line">                           修改 mount 名字空间中的 mount 传播</span><br><span class="line"> -s, --setgroups allow|deny  控制用户名字空间中的 setgroups 系统调用</span><br><span class="line"></span><br><span class="line"> -h, --help                display this help</span><br><span class="line"> -V, --version             display version</span><br></pre></td></tr></table></figure>

<p><code>unshare</code>命令可以让你在新的名称空间集中启动一个新的程序（unshared本身的含义就是不和父进程共享）。<br>下面的例子使用了<code>UTS namespace</code>，可以看到在新的<code>/bin/sh</code>进程中修改hostname，并没有影响宿主机：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo su                   # become root user</span><br><span class="line">$ hostname                  # check current hostname</span><br><span class="line">lucy-computer  </span><br><span class="line">$ unshare -u /bin/sh        # create a shell in new UTS namespace</span><br><span class="line">$ hostname my-new-hostname  # set hostname</span><br><span class="line">$ hostname                  # confirm new hostname</span><br><span class="line">my-new-hostname  </span><br><span class="line">$ exit                      # exit new UTS namespace</span><br><span class="line">$ hostname                  # confirm original hostname unchanged</span><br><span class="line">lucy-computer</span><br></pre></td></tr></table></figure>

<h3 id="三个系统调用"><a href="#三个系统调用" class="headerlink" title="三个系统调用"></a>三个系统调用</h3><p><code>unshare</code>命令很棒，但是当我们想要对程序中的命名空间进行更细粒度的控制时，那该怎么办呢？<br>Linux 内核提供的功能都会提供<code>系统调用</code>接口供应用程序使用，<code>Namespace</code>也不例外。和<code>Namespace</code>相关的系统调用主要有三个：</p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man2/clone.2.html" target="_blank" rel="noopener">clone</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/setns.2.html" target="_blank" rel="noopener">setns</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/unshare.2.html" target="_blank" rel="noopener">unshare</a></li>
</ul>
<p><strong>注意</strong>：这些系统调用都是 linux 内核实现的，不能直接适用于其他操作系统。</p>
<p>查看一下它们对应的C语言函数原型：</p>
<h4 id="clone：创建新进程并设置它的Namespace"><a href="#clone：创建新进程并设置它的Namespace" class="headerlink" title="clone：创建新进程并设置它的Namespace"></a>clone：创建新进程并设置它的Namespace</h4><p><code>clone</code>类似于<code>fork</code>系统调用，可以创建一个新的进程，不同的是你可以指定要子进程要执行的函数以及通过参数控制子进程的运行环境。</p>
<blockquote>
<p>实际上，clone() 是在 C 语言库中定义的一个封装(wrapper)函数，它负责建立新进程的堆栈并且调用对编程者隐藏的 clone() 系统调用。Clone() 其实是 linux 系统调用 fork() 的一种更通用的实现方式，它可以通过 flags 来控制使用多少功能。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line"></span><br><span class="line">int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure>

<ul>
<li>fn：指定一个由新进程执行的函数。当这个函数返回时，子进程终止。该函数返回一个整数，表示子进程的退出代码。</li>
<li>child_stack：传入子进程使用的栈空间，也就是把用户态堆栈指针赋给子进程的 esp 寄存器。调用进程(指调用 clone() 的进程)应该总是为子进程分配新的堆栈。</li>
<li>flags：表示使用哪些 CLONE_ 开头的标志位，与 namespace 相关的有CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP，如果要同时隔离多个 namespace，<strong>可以使用 | (按位或)组合这些参数</strong>。</li>
<li>arg：指向传递给 fn() 函数的参数。</li>
</ul>
<h4 id="setns：让进程加入已经存在Namespace"><a href="#setns：让进程加入已经存在Namespace" class="headerlink" title="setns：让进程加入已经存在Namespace"></a>setns：让进程加入已经存在Namespace</h4><p>setns 能够把某个进程加入到给定的 namespace，它的定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">int setns(int fd, int nstype);</span><br></pre></td></tr></table></figure>

<p>和<code>clone()</code>函数一样，C 语言库中的<code>setns()</code>函数也是对<code>setns系统调用</code>的封装。  </p>
<ul>
<li>fd：表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录中文件的文件描述符，可以通过直接打开该目录下的链接文件或者打开一个挂载了该目录下链接文件的文件得到。</li>
<li>nstype：参数 nstype 让调用者可以检查 fd 指向的 namespace 类型是否符合实际要求。若把该参数设置为 0 表示不检查。</li>
</ul>
<h4 id="unshare：让进程加入新的Namespace"><a href="#unshare：让进程加入新的Namespace" class="headerlink" title="unshare：让进程加入新的Namespace"></a>unshare：让进程加入新的Namespace</h4><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">int unshare(int flags);</span><br></pre></td></tr></table></figure>

<p><code>unshare()</code>函数比较简单，只有一个参数<code>flags</code>，它的含义和<code>clone()</code>的<code>flags</code>相同。<code>unshare</code>和 <code>setns</code> 的区别是，<code>setns</code> 只能让进程加入到已经存在的<code>namespace</code>中，而<code>unshare</code>则让进程离开当前的<code>namespace</code>，加入到新建的<code>namespace</code>中。  </p>
<p><code>unshare()</code>和<code>clone()</code>的区别在于：<code>unshare()</code>是把当前进程进入到新的<code>namespace</code>；<code>clone()</code>是创建新的进程，然后让新创建的进程（子进程）加入到新的<code>namespace</code>。</p>
<h2 id="C程序中使用clone系统调用"><a href="#C程序中使用clone系统调用" class="headerlink" title="C程序中使用clone系统调用"></a>C程序中使用clone系统调用</h2><p>我们先来看看 clone 一个简单的使用例子：创建一个新的进程，并执行 /bin/bash，这样就可以接受命令，方便我们查看新进程的信息。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 设置子进程要使用的栈空间</span><br><span class="line">#define STACK_SIZE (1024*1024)</span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">#define errExit(code, msg); &#123;if(code == -1)&#123;perror(msg); exit(-1);&#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int container_func(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Container[%d] - inside the container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 用一个新的bash来替换掉当前子进程，</span><br><span class="line">    // 这样我们就能通过 bash 查看当前子进程的情况.</span><br><span class="line">    // bash退出后，子进程执行完毕</span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line"></span><br><span class="line">    // 从这里开始的代码将不会被执行到，因为当前子进程已经被上面的bash替换掉了;</span><br><span class="line">    // 所以如果执行到这里，一定是出错了</span><br><span class="line">    printf(&quot;Container[%d] - oops!\n&quot;, pid);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Parent[%d] - create a container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 创建并启动子进程，调用该函数后，父进程将继续往后执行，也就是执行后面的waitpid</span><br><span class="line">    pid_t child_pid = clone(container_func,  // 子进程将执行container_func这个函数</span><br><span class="line">                    container_stack + sizeof(container_stack),</span><br><span class="line">                    // 这里SIGCHLD是子进程退出后返回给父进程的信号，跟namespace无关</span><br><span class="line">                    SIGCHLD,</span><br><span class="line">                    NULL);  // 传给child_func的参数</span><br><span class="line">    errExit(child_pid, &quot;clone&quot;);</span><br><span class="line"></span><br><span class="line">    waitpid(child_pid, NULL, 0); // 等待子进程结束</span><br><span class="line"></span><br><span class="line">    printf(&quot;Parent[%d] - container exited!\n&quot;, pid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不长，但是做了很多事情：</p>
<ul>
<li>通过<code>clone()</code>创建出一个子进程，并设置启动时的参数</li>
<li>在子进程中调用 execv 来执行 /bin/bash，等待用户进行交互</li>
<li>子进程退出之后，父进程也跟着退出</li>
</ul>
<p>我们可以用<code>ls -l /proc/$$/ns</code>查看当前进程所在命名空间的信息，运行程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">lucy@lucy-computer:~$ gcc container.c -o container</span><br><span class="line">lucy@lucy-computer:~$ ./container </span><br><span class="line">Parent[19644] - create a container!</span><br><span class="line">Container[19645] - inside the container!</span><br><span class="line">lucy@lucy-computer:~$ ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 uts -&gt; &apos;uts:[4026531838]&apos;</span><br><span class="line">lucy@lucy-computer:~$ exit</span><br><span class="line">exit</span><br><span class="line">Parent[19644] - container exited!</span><br><span class="line">lucy@lucy-computer:~$ ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 uts -&gt; &apos;uts:[4026531838]&apos;</span><br></pre></td></tr></table></figure>

<p>各类命名空间id都是一样，因为我们只是单单使用了<code>clone</code>，未设置要隔离的命名空间，现在，我们加入<code>UTS Namespace</code>隔离，<code>UTS namespace</code> 功能最简单，它只隔离了 hostname 和 NIS domain name 两个资源。<br>同一个 namespace 里面的进程看到的 hostname 和 domain name 是相同的，这两个值可以通过 <code>sethostname(2)</code> 和 <code>setdomainname(2)</code> 来进行设置，也可以通过 <code>uname(2)</code>、<code>gethostname(2)</code> 和 <code>getdomainname(2)</code> 来读取。<br><strong>注意</strong>： UTS 的名字来自于<code>uname</code>函数用到的结构体<code>struct utsname</code>，这个结构体的名字源自于<code>UNIX Time-sharing System</code>。<br>代码主要修改两个地方：clone 的参数加上了 CLONE_NEWUTS，子进程函数中使用<code>sethostname</code>来设置 hostname。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/utsname.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 设置子进程要使用的栈空间</span><br><span class="line">#define STACK_SIZE (1024*1024)</span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">#define errExit(code, msg); &#123;if(code == -1)&#123;perror(msg); exit(-1);&#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int container_func(void *hostname)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Container[%d] - inside the container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 使用 sethostname 设置子进程的 hostname 信息</span><br><span class="line">    struct utsname uts;</span><br><span class="line">    if (sethostname(hostname, strlen(hostname)) == -1) &#123;</span><br><span class="line">        errExit(-1, &quot;sethostname&quot;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 使用 uname 获取子进程的机器信息，并打印 hostname 出来</span><br><span class="line">    if (uname(&amp;uts) == -1)&#123;</span><br><span class="line">        errExit(-1, &quot;uname&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Container[%d] - container uts.nodename: [%s]!\n&quot;, pid, uts.nodename);</span><br><span class="line"></span><br><span class="line">    // 用一个新的bash来替换掉当前子进程，</span><br><span class="line">    // 这样我们就能通过 bash 查看当前子进程的情况.</span><br><span class="line">    // bash退出后，子进程执行完毕</span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line"></span><br><span class="line">    // 从这里开始的代码将不会被执行到，因为当前子进程已经被上面的bash替换掉了;</span><br><span class="line">    // 所以如果执行到这里，一定是出错了</span><br><span class="line">    printf(&quot;Container[%d] - oops!\n&quot;, pid);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Parent[%d] - create a container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 把第一个参数作为子进程的 hostname，默认是 `container`</span><br><span class="line">    char *hostname;</span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        hostname = &quot;container&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        hostname = argv[1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建并启动子进程，调用该函数后，父进程将继续往后执行，也就是执行后面的waitpid</span><br><span class="line">    pid_t child_pid = clone(container_func,  // 子进程将执行container_func这个函数</span><br><span class="line">                    container_stack + sizeof(container_stack),</span><br><span class="line">                    // CLONE_NEWUTS表示创建新的UTS namespace</span><br><span class="line">                    CLONE_NEWUTS | SIGCHLD,</span><br><span class="line">                    hostname);  // 传给child_func的参数</span><br><span class="line">    errExit(child_pid, &quot;clone&quot;);</span><br><span class="line"></span><br><span class="line">    waitpid(child_pid, NULL, 0); // 等待子进程结束</span><br><span class="line"></span><br><span class="line">    printf(&quot;Parent[%d] - container exited!\n&quot;, pid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行程序，发现容器中hostname与宿主机已经不一样了，容器中<code>UTS Namespace</code>id也跟宿主机不一样了（这里需要root权限）：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo su</span><br><span class="line">root@lucy-computer:/home/lucy# gcc container.c -o container</span><br><span class="line">root@lucy-computer:/home/lucy# ./container </span><br><span class="line">Parent[21091] - create a container!</span><br><span class="line">Container[21092] - inside the container!</span><br><span class="line">Container[21092] - container uts.nodename: [container]!</span><br><span class="line">root@container:/home/lucy# hostname</span><br><span class="line">container</span><br><span class="line">root@container:/home/lucy# ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 uts -&gt; &apos;uts:[4026532944]&apos;</span><br><span class="line">root@container:/home/lucy# exit</span><br><span class="line">exit</span><br><span class="line">Parent[21091] - container exited!</span><br><span class="line">root@lucy-computer:/home/lucy# ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 uts -&gt; &apos;uts:[4026531838]&apos;</span><br><span class="line">root@lucy-computer:/home/lucy# hostname</span><br><span class="line">lucy-computer</span><br></pre></td></tr></table></figure>

<h3 id="Let’s-Go"><a href="#Let’s-Go" class="headerlink" title="Let’s Go"></a>Let’s Go</h3><p>C语言很底层，能控制到很多细节，但是它对于大部分人有点困难，接下来我们会有Go语言来一步步实现Docker容器。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://cizixs.com/2017/08/29/linux-namespace/" target="_blank" rel="noopener">cizixs.com/2017/08/29/linux-namespace</a></li>
<li><a href="https://www.cnblogs.com/sparkdev/p/9365405.html" target="_blank" rel="noopener">Linux Namespace : 简介</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Namespace</tag>
        <tag>Cgroup</tag>
      </tags>
  </entry>
  <entry>
    <title>最小生成树回顾</title>
    <url>/2019/12/10/min_spanning_tree/</url>
    <content><![CDATA[<p><img src="/images/MST.png" alt="docker logo"></p>
<p>解决<code>最小生成树</code>（Minimum spanning tree）问题的算法，书上介绍了两个：<code>Prime</code>算法和<code>Kruskal</code>算法。</p>
<a id="more"></a>

<h2 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"graph.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">extern</span> <span class="keyword">void</span> <span class="title">DispMat1</span><span class="params">(MGraph)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Prim</span><span class="params">(MGraph g, <span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lowcost[MAXV], min, n = g.n;</span><br><span class="line">    <span class="keyword">int</span> closest[MAXV], i, j, k;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        lowcost[i] = g.edges[v][i];</span><br><span class="line">        closest[i] = v;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">1</span>; i &lt; n; i++)   <span class="comment">// 找出n - 1个顶点</span></span><br><span class="line">    &#123;</span><br><span class="line">        min = INF;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (lowcost[j] != <span class="number">0</span> &amp;&amp; lowcost[j] &lt; min)</span><br><span class="line">            &#123;</span><br><span class="line">                min = lowcost[j];</span><br><span class="line">                k = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"    边（%d， %d）权为：%d\n"</span>, closest[k], k, min);</span><br><span class="line">        lowcost[k] = <span class="number">0</span>;      <span class="comment">// 标记k已经加入U</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (g.edges[k][j] != <span class="number">0</span> &amp;&amp; g.edges[k][j] &lt; lowcost[j])</span><br><span class="line">            &#123;</span><br><span class="line">                lowcost[j] = g.edges[k][j];</span><br><span class="line">                lowcost[j] = k;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h2><p>实现克鲁斯卡尔算法的关键是<strong>判断选取的边是否与生成树中已保留的边形成回路，这可以通过判断边的两个顶点所在的连通分量来解决</strong>（给顶点所在连通分量编号）。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef struct</span><br><span class="line">&#123;</span><br><span class="line">    int u;      // 边的起始顶点</span><br><span class="line">    int v;      // 边的终止顶点</span><br><span class="line">    int w;      // 边的权值</span><br><span class="line">&#125; Edge;</span><br><span class="line"></span><br><span class="line">void Kruskal(MGraph g, int v)</span><br><span class="line">&#123;</span><br><span class="line">    int i, j, u1, v1, sn1, sn2, k;</span><br><span class="line">    int vset[MAXV];         // 存放所有边</span><br><span class="line">    Edge E[MaxSize];        // e数组的下标从0开始计</span><br><span class="line">    k = 0;</span><br><span class="line">    for (i = 0; i &lt; g.n; i++)   // 由g产生的边集E</span><br><span class="line">    &#123;</span><br><span class="line">        for (j = 0; j &lt; g.n; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            if (g.edges[i][j] != 0 &amp;&amp; g.edges[i][j] != INF)</span><br><span class="line">            &#123;</span><br><span class="line">                E[k].u = i;</span><br><span class="line">                E[k].v = i;</span><br><span class="line">                E[k].w = g.edges[i][j];</span><br><span class="line">                k++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    InsertSort(E, g.e);</span><br><span class="line">    for (i = 0; i &lt; g.n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vset[i] = i;</span><br><span class="line">    &#125;</span><br><span class="line">    k = 1;                      // k表示当前构造生成树的第几条边，初值为1</span><br><span class="line">    j = 0;                      // E中边的下标，初值为0</span><br><span class="line">    while (k &lt; g.n)</span><br><span class="line">    &#123;</span><br><span class="line">        u1 = E[j].u;</span><br><span class="line">        v1 = E[j].v;</span><br><span class="line">        sn1 = vset[u1];</span><br><span class="line">        sn2 = vset[v1];</span><br><span class="line">        if (sn1 != sn2)</span><br><span class="line">        &#123;</span><br><span class="line">            printf(&quot; (%d, %d): %d\n&quot;, u1, v1, E[j].w);</span><br><span class="line">            k++;               // 生成边数增1</span><br><span class="line">            for (i = 0; i &lt; g.n; i++)      // 两个集合统一编号</span><br><span class="line">            &#123;</span><br><span class="line">                if (vset[i] == sn2)        // 集合编号为sn2的改为sn1</span><br><span class="line">                &#123;</span><br><span class="line">                    if (vset[i] == sn2)</span><br><span class="line">                    &#123;</span><br><span class="line">                        vset[i] = sn1;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        j++;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>算法参考：</p>
<ul>
<li>《数据结构教程（第4版）》（李春葆）</li>
</ul>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>图</tag>
        <tag>最小生成树</tag>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title>栈应用之四则运算</title>
    <url>/2019/08/19/stack_si_ze/</url>
    <content><![CDATA[<h2 id="四则运算"><a href="#四则运算" class="headerlink" title="四则运算"></a>四则运算</h2><p>四则运算表达式是我们小学就接触的内容，它遵循“先乘除，后加减，从左到右，括号内先算”的法则，例如“7 + (5 - 3) * 4 + 6 / 3”，这个表达式先算<strong>5 - 3</strong>得<strong>2</strong>，再算<strong>2 * 4</strong>和<strong>6 / 3</strong>，最后计算<strong>7 + 8 +2</strong>，这个过程很简单，口算就能完成，但是如果让我们在程序里实现这个功能，该如何实现呢？我们遇到的困难在于乘除优在加减的后面，却要先运算，另外还要考虑括号，问题就复杂了。</p>
<a id="more"></a>

<h2 id="后缀表达式"><a href="#后缀表达式" class="headerlink" title="后缀表达式"></a>后缀表达式</h2><p>波兰有位科学家也想到了这个问题，他想出了一种新的<strong>不需要括号</strong>的表达式：“后缀表达式”，它更有利于计算机计算。让我们看看它的样子：对于“7 + (5 - 3) * 4 + 6 / 3”，后缀表达式为“7 5 3 - 4 * + 6 3 / +”，叫后缀的原因在于<strong>运算符在操作数之后</strong>。我们人类喜欢看到的表达式叫“中缀表达式”（因为运算符在操作数中间），但是计算机不喜欢它。</p>
<h3 id="后缀表达式的方法"><a href="#后缀表达式的方法" class="headerlink" title="后缀表达式的方法"></a>后缀表达式的方法</h3><p>为了看到后缀表达式的好处，我们先看看，计算机如何利用后缀表达式计算出最终结果。</p>
<ul>
<li>后缀表达式：<strong>7 5 3 - 4 * + 6 3 / +</strong></li>
<li>规则：从左到右遍历字符串，遇到数字则进栈，遇到符号则将栈顶的两个数字出栈，进行计算，运算结果进栈，一直到最终获得结果。</li>
</ul>
<ol>
<li>初始化一个空栈，此栈用来对要运算的数字进出使用。</li>
<li>字符串中前三个都是数字，所以7，5，3进栈。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/20/mGkVZ6.jpg" alt="过程"></p>
<ol start="3">
<li>接下来是“-”，所以5和3出栈，5作为被减数，3作为减数，5减3得到2，并将2入栈。</li>
<li>接着是4入栈。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/20/mGkByn.jpg" alt="过程"></p>
<ol start="5">
<li>接下来是”*“，所以4和2出栈，4乘以2得8，8入栈。</li>
<li>下面是“+”，7和8出栈，7加8得15，15入栈。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/20/mGk7TK.jpg" alt="过程"></p>
<ol start="7">
<li>接下来6和3数字入栈。</li>
<li>遇到符号“/”，所以6和3出栈，6作为被除数，3作为除数，6除3得2，2入栈。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/20/mGA9Tf.jpg" alt="过程"></p>
<ol start="9">
<li>最后遇到符号“+”，15和2出栈，15加2得17，17入栈，遍历结束，将最后结果出栈，得到17。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/20/mGAV6s.jpg" alt="过程"></p>
<h3 id="中缀表达式转后缀表达式"><a href="#中缀表达式转后缀表达式" class="headerlink" title="中缀表达式转后缀表达式"></a>中缀表达式转后缀表达式</h3><p>可以看到利用<strong>栈</strong>就很容易计算后缀表达式的值，那么现在我们的问题就是中缀转后缀。</p>
<ul>
<li>中缀表达式：“8 + (7 - 2 * 3 + 2) * 3 + 10 / 2”</li>
<li>规则：遍历字符串，遇到数字则输出，即成为后缀表达式一部分；若是操作符，则判断与栈顶符号的优先级（乘除优先级比加减优先级高，乘除优先级一样，加和减也一样），如果高于栈顶符号，则压栈，否则从栈顶开始弹出元素直到遇到遇到优先级更低的符号（或者遇到“(”，“(”只有遇到“)”才会弹出），弹出完这些符号后，把当前符号压栈。</li>
</ul>
<ol>
<li>初始化一空栈，用来对符号进出栈使用。</li>
<li>第一个字符是数字8，输出8，后面符号是“+”，进栈。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/21/mUD2S1.png" alt="过程"></p>
<ol start="3">
<li>第三个字符是“(”，因为是左括号，所以压栈，第四个字符是7，输出，总表达式为8 7。</li>
<li>接着是“-”，因为栈顶是“(”，所以压栈。后面字符是2，输出，总表达式为8 7 2。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/25/mgNyRO.png" alt="过程"></p>
<ol start="5">
<li>之后符号是“*”，它的优先级比栈顶“-”高，所以压栈，再之后是数字3，输出，总表达式为8 7 2 3。</li>
<li>接着是符号“+”，它比“*”的优先级低，所以“*”弹出栈输出，而“-”优先级和“+”一样，也要弹出栈输出，接下来碰到符号“(”，就要把“+”压栈。接着是数字2，输出，总表达式为8 7 2 3 * - 2。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/25/mgUPlF.png" alt="过程"></p>
<ol start="7">
<li>接着是符号“)”，这时需要从栈顶开始依次弹出符号输出，直到遇到“(”（“(”也要弹出，只是不输出），“(”之后只剩一个“+”，所以弹出“+”输出，接下来是符号“*”，优先级比“+”高，所以压栈，总表达式为8 7 2 3 * - 2 +。</li>
<li>接下来是数字3，输出，紧接着是符号“+”，它比栈顶“*”优先级低，所以弹出“*”输出，而之后比较的“+”优先级一样，也弹出栈输出，最后“+”压栈，总表达式为8 7 2 3 * - 2 + 3 * +。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/28/moOHG6.jpg" alt="过程"></p>
<ol start="9">
<li>接着是数字10，输出，接下来是符号“/”，比符号“+”优先级高，所以压栈，总表达式为8 7 2 3 * - 2 + 3 * + 10。</li>
<li>接着是数字2，输出。遍历结束，依次弹出栈中元素，最后总表达式为8 7 2 3 * - 2 + 3 * + 10 2 / +。</li>
</ol>
<p><img src="https://s2.ax1x.com/2019/08/28/moXELQ.jpg" alt="过程"></p>
<h3 id="代码示例"><a href="#代码示例" class="headerlink" title="代码示例"></a>代码示例</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 预先生成运算符的tokens</span><br><span class="line">prepareTokens() &#123;</span><br><span class="line">    this.tokens = [</span><br><span class="line">        new Token(&apos;#&apos;, TOKEN_TYPE.ENDEXPR),</span><br><span class="line">        new Token(&apos;(&apos;, TOKEN_TYPE.LEFTPAREN),</span><br><span class="line">        new Token(&apos;)&apos;, TOKEN_TYPE.RIGHTPAREN),</span><br><span class="line">        new Token(&apos;~&apos;, TOKEN_TYPE.UNARYOP, 6),       // 负号</span><br><span class="line">        new Token(&apos;abs&apos;, TOKEN_TYPE.UNARYOP, 6),     // 求绝对值</span><br><span class="line">        new Token(&apos;sqrt&apos;, TOKEN_TYPE.UNARYOP, 6),    // 开平方根</span><br><span class="line">        new Token(&apos;exp&apos;, TOKEN_TYPE.UNARYOP, 6),     // e的x次</span><br><span class="line">        new Token(&apos;ln&apos;, TOKEN_TYPE.UNARYOP, 6),      // e为底数的对数</span><br><span class="line">        new Token(&apos;log10&apos;, TOKEN_TYPE.UNARYOP, 6),   // 10为底数的对数</span><br><span class="line">        new Token(&apos;sin&apos;, TOKEN_TYPE.UNARYOP, 6),     // 求sin x</span><br><span class="line">        new Token(&apos;cos&apos;, TOKEN_TYPE.UNARYOP, 6),     // 求cos x</span><br><span class="line">        new Token(&apos;tan&apos;, TOKEN_TYPE.UNARYOP, 6),     // 求tan x</span><br><span class="line">        new Token(&apos;+&apos;, TOKEN_TYPE.BINARYOP, 4),      // 二元+</span><br><span class="line">        new Token(&apos;-&apos;, TOKEN_TYPE.BINARYOP, 4),      // 二元-</span><br><span class="line">        new Token(&apos;*&apos;, TOKEN_TYPE.BINARYOP, 5),      // 乘法</span><br><span class="line">        new Token(&apos;/&apos;, TOKEN_TYPE.BINARYOP, 5),      // 除法</span><br><span class="line">        new Token(&apos;%&apos;, TOKEN_TYPE.BINARYOP, 5),      // 除模取余</span><br><span class="line">        new Token(&apos;^&apos;, TOKEN_TYPE.BINARYOP, 6),      // 指数运算</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 中缀表达式转化为后缀表达式</span><br><span class="line"> * @return &#123;Array&#125;</span><br><span class="line"> */</span><br><span class="line">transform() &#123;</span><br><span class="line">    const postExp = []</span><br><span class="line">    const opStack = []</span><br><span class="line">    for (let i = 0; i &lt; this.infixExp.length; i++) &#123;</span><br><span class="line">        const pos = this.infixExp[i]</span><br><span class="line">        const token = this.tokens[pos]</span><br><span class="line">        switch (token.type) &#123;</span><br><span class="line">            case TOKEN_TYPE.OPRAND:</span><br><span class="line">                postExp.push(pos)</span><br><span class="line">                break;</span><br><span class="line">            case TOKEN_TYPE.LEFTPAREN:  // “(”直接入栈</span><br><span class="line">                opStack.push(pos)</span><br><span class="line">                break;</span><br><span class="line">            case TOKEN_TYPE.RIGHTPAREN: // 为“)”，出栈直到遇到运算符“(”</span><br><span class="line">                let prePos = opStack.pop()</span><br><span class="line">                while (prePos in this.tokens &amp;&amp; opStack.length &gt;= 0 &amp;&amp;</span><br><span class="line">                this.tokens[prePos].type !== TOKEN_TYPE.LEFTPAREN) &#123;</span><br><span class="line">                    postExp.push(prePos)</span><br><span class="line">                    prePos = opStack.pop()</span><br><span class="line">                &#125;</span><br><span class="line">                break;</span><br><span class="line">            case TOKEN_TYPE.UNARYOP:</span><br><span class="line">            case TOKEN_TYPE.BINARYOP:</span><br><span class="line">                let endright = 0</span><br><span class="line">                while (endright === 0) &#123;</span><br><span class="line">                    if (opStack.length &lt;= 0)</span><br><span class="line">                        endright = 1</span><br><span class="line">                    else if (this.tokens[opStack[opStack.length - 1]].type === TOKEN_TYPE.LEFTPAREN) &#123;</span><br><span class="line">                        endright = 1</span><br><span class="line">                    &#125; else if (this.tokens[opStack[opStack.length - 1]].priority &lt; token.priority) &#123;</span><br><span class="line">                        endright = 1</span><br><span class="line">                    &#125; else if (this.tokens[opStack[opStack.length - 1]].priority === token.priority &amp;&amp;</span><br><span class="line">                                token.priority === MAX_PRIORITY) &#123;</span><br><span class="line">                        endright = 1</span><br><span class="line">                    &#125; else &#123;</span><br><span class="line">                        postExp.push(opStack.pop())</span><br><span class="line">                        endright = 0</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                opStack.push(pos)</span><br><span class="line">                break</span><br><span class="line">            case TOKEN_TYPE.ENDEXPR:</span><br><span class="line">                while (opStack.length &gt;= 1) &#123;</span><br><span class="line">                    postExp.push(opStack.pop())</span><br><span class="line">                &#125;</span><br><span class="line">                break</span><br><span class="line">            default:</span><br><span class="line">                break</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    postExp.push(0)  // 添加终止符</span><br><span class="line">    return postExp</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>中缀表达式<code>infixExp</code>中存的是<code>this.tokens</code>中的索引，完整代码<a href="https://github.com/salamander-mh/calculator" target="_blank" rel="noopener">Github</a></p>
]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>栈</tag>
        <tag>四则运算</tag>
      </tags>
  </entry>
  <entry>
    <title>https深入分析</title>
    <url>/2020/03/21/https_more/</url>
    <content><![CDATA[<img src="/images/https-click.png" width="700px">

<h2 id="https"><a href="#https" class="headerlink" title="https"></a>https</h2><p>https就是在http的基础上又增加了一个TLS层，它就是一个套壳协议。  </p>
<a id="more"></a>



<h2 id="加密和解密"><a href="#加密和解密" class="headerlink" title="加密和解密"></a>加密和解密</h2><p>https的发展和密码学的发展是分不开的。加密方式可以大体分为对称加密和非对称加密  </p>
<ul>
<li>对称加密，就是加密和解密都是用同一个秘钥，这种方式优点就是速度快，缺点就是在管理和分配秘钥的时候不安全。</li>
<li>非对称加密算法，非对称加密有一个秘钥对，叫做公钥和私钥，私钥自己持有，公钥可以公开的发送给使用的人。使用公钥进行加密的信息，只有和其配对的私钥可以解开。目前常见的非对称加密算法是RSA，非对称的加密算法的优点是安全，因为他不需要把私钥暴露出去。 在正式的使用场景中一般都是对称加密和非对称加密结合使用，使用非对称加密完成秘钥的传递，然后使用对称秘钥进行数据加密和解密</li>
</ul>
<h2 id="https的简要流程"><a href="#https的简要流程" class="headerlink" title="https的简要流程"></a>https的简要流程</h2><p><img src="https://s1.ax1x.com/2020/03/26/GpEtjs.png" alt> </p>
<ol>
<li><p>先是经典的TCP三次握手，这里不详细展开了。</p>
</li>
<li><p>client Hello,客户端（通常是浏览器）先向服务器发出加密通信的请求</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 支持的协议版本，比如TLS 1.0版。</span><br><span class="line">* 一个客户端生成的随机数 random1，稍后用于生成&quot;对话密钥&quot;。</span><br><span class="line">* 支持的加密方法，比如RSA公钥加密。</span><br><span class="line">* 支持的压缩方法。</span><br></pre></td></tr></table></figure>
</li>
<li><p>服务器收到请求,然后响应 (server Hello)</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">* 确认使用的加密通信协议版本，比如TLS 1.0版本。如果浏览器与服务器支持的版本不一致，服务器关闭加密通信。</span><br><span class="line">* 一个服务器生成的随机数random2，稍后用于生成&quot;对话密钥&quot;。</span><br><span class="line">* 确认使用的加密方法，比如RSA公钥加密。</span><br><span class="line">* 服务器证书。</span><br></pre></td></tr></table></figure>
</li>
<li><p>客户端收到证书之后会首先会进行验证</p>
<pre><code>验证通过之后，客户端会生成一个随机数pre-master secret，然后使用证书中的公钥进行加密，然后传递给服务器端</code></pre></li>
<li><p>服务器收到使用公钥加密的内容，在服务器端使用私钥解密之后获得随机数pre-master secret，然后根据radom1、radom2、pre-master secret通过一定的算法得出session Key和MAC算法秘钥，作为后面交互过程中使用对称秘钥。同时客户端也会使用radom1、radom2、pre-master secret，和同样的算法生成session Key和MAC算法的秘钥。  </p>
</li>
</ol>
<h2 id="https证书"><a href="#https证书" class="headerlink" title="https证书"></a>https证书</h2><p>服务器发给了客户端证书，客户端是如何验证证书的<strong>有效性</strong>的呢？这里我们分析一下它的原理。  </p>
<p>SSL 证书中包含的具体内容有：<br>（1）证书的发布机构CA<br>（2）证书的有效期<br>（3）公钥<br>（4）证书所有者<br>（5）签名<br>…<br>CA机构在签发证书的时候，都会使用自己的<strong>私钥对证书进行签名</strong>，如果我们使用的是购买的证书，那么很有可能，颁发这个证书的CA机构的公钥已经预置在操作系统中。这样<strong>浏览器就可以使用CA机构的公钥对服务器的证书进行验签</strong>，验签之后得到的是CA机构使用sha256得到的证书摘要，客户端就会对服务器发送过来的证书使用sha256进行哈希计算得到一份摘要，然后对比之前由CA得出来的摘要，就可以知道这个证书是不是正确的，是否被修改过。<br><strong>所以说原理就是因为CA机构的公钥已经预存于我们的操作系统之中。</strong>  </p>
<p>完整的验证过程如下：   </p>
<ol>
<li>首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验；</li>
<li>浏览器开始查找操作系统中已内置的受信任的证书发布机构CA，与服务器发来的证书中的颁发者CA比对，用于校验证书是否为合法机构颁发；</li>
<li>如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的；</li>
<li>如果找到，那么浏览器就会从操作系统中取出 颁发者CA 的公钥，然后对服务器发来的证书里面的签名进行解密；</li>
<li>浏览器使用相同的hash算法计算出服务器发来的证书的hash值，将这个计算的hash值与证书中签名做对比；</li>
<li>对比结果一致，则证明服务器发来的证书合法，没有被冒充；</li>
<li>此时浏览器就可以读取证书中的公钥，用于后续加密了</li>
</ol>
<p> 参考：</p>
<ul>
<li><a href="https://juejin.im/post/5a2fbe1b51882507ae25f991" target="_blank" rel="noopener">深入理解HTTPS协议</a></li>
<li><a href="https://cloud.tencent.com/developer/article/1425339" target="_blank" rel="noopener">HTTPS协议原理和流程分析</a></li>
</ul>
]]></content>
      <categories>
        <category>protocol	</category>
        <category>https</category>
      </categories>
      <tags>
        <tag>https</tag>
        <tag>协议</tag>
      </tags>
  </entry>
  <entry>
    <title>一步步自己做个Docker之Docker网络原理</title>
    <url>/2020/04/28/step_to_step_Docker%E4%B9%8BDocker_network_underlying/</url>
    <content><![CDATA[<p><img src="/images/docker-logo.png" alt="docker logo"></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>Golang版本：1.12.13</li>
</ul>
<a id="more"></a>


<h2 id="自己创建Docker网络"><a href="#自己创建Docker网络" class="headerlink" title="自己创建Docker网络"></a>自己创建Docker网络</h2><blockquote>
<p>当 Docker 启动时，会自动在主机上创建一个 docker0 虚拟网桥，实际上是 Linux 的一个 bridge，可以理解为一个软件交换机。它会在挂载到它的网口之间进行转发。 同时，Docker 随机分配一个本地未占用的私有网段（在 RFC1918 中定义）中的一个地址给 docker0 接口。比如典型的 172.17.42.1，掩码为 255.255.0.0。此后启动的容器内的网口也会自动分配一个同一网段（172.17.0.0/16）的地址。 当创建一个 Docker 容器的时候，同时会创建了一对 veth pair 接口（当数据包发送到一个接口时，另外一个接口也可以收到相同的数据包）。这对接口一端在容器内，即 eth0；另一端在本地并被挂载到 docker0 网桥，名称以 veth 开头（例如 vethAQI2QT）。通过这种方式，主机可以跟容器通信，容器之间也可以相互通信。Docker 就创建了在主机和所有容器之间一个虚拟共享网络。如图<br><img src="https://s1.ax1x.com/2020/04/29/J7aODe.png" alt="upload successful"></p>
</blockquote>
<p>下面以自定义的容器方式，一步步配置网络, 达到以下目标:</p>
<ul>
<li>容器间能够通信</li>
<li>容器能够联外网<br>首先创建一个容器，但不使用默认网络配置，使用<code>--net=none</code>选项:<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker run -t -i --net=none ubuntu:14.04 bash</span><br><span class="line">docker ps # 获取容器id=6414d7278905</span><br></pre></td></tr></table></figure>

</li>
</ul>
<p>获取容器pid:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">docker inspect 6414d7278905 | grep -i &quot;\&lt;pid\&quot;&quot;</span><br><span class="line">#  &quot;Pid&quot;: 11776,</span><br><span class="line">pid=11776</span><br></pre></td></tr></table></figure>

<p>创建一个新的netns，并把容器放入新建的netns中。（根据约定，命名的 network namespace 是可以打开的 <strong>/var/run/netns/</strong> 目录下的一个对象。比如有一个名称为 net1 的 network namespace 对象，则可以由打开 <strong>/var/run/netns/net1</strong> 对象产生的文件描述符引用 network namespace net1。通过引用该文件描述符，可以修改进程的 network namespace。）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ip netns add netns666 # 会产生一个/var/run/netns/netns666的文件</span><br><span class="line">sudo ip netns ls # 查看新创建netns</span><br><span class="line">netns666</span><br><span class="line">sudo mount --bind /proc/$pid/ns/net /var/run/netns/netns666 # 加入新的netns</span><br><span class="line">sudo ip netns pids netns666   # 查看netns666中进程的 PID</span><br><span class="line">11776</span><br></pre></td></tr></table></figure>

<p>接下来创建一个veth对，其中一个设置为容器所在的netns，即<code>netns666</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ip link add name veth_d366 type veth peer name veth_d366_peer</span><br><span class="line">sudo ip link set veth_d366_peer netns netns666</span><br></pre></td></tr></table></figure>

<p>进入<code>netns666</code> netns设置网卡名称和ip:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ip netns exec netns666 bash</span><br><span class="line">sudo ip link set veth_d366_peer name eth0</span><br><span class="line">sudo ifconfig  eth0 10.0.0.2/24 # 设置ip为10.0.0.2</span><br><span class="line">ping 10.0.0.2 # 能ping通</span><br><span class="line">exit</span><br></pre></td></tr></table></figure>

<p>上述命令给veth_d366_peer配置完ip的情况：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ip addr show</span><br><span class="line">1: lo: &lt;LOOPBACK,UP,LOWER_UP&gt; mtu 65536 qdisc noqueue state UNKNOWN group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">    inet 127.0.0.1/8 scope host lo</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">36: eth0@if37: &lt;NO-CARRIER,BROADCAST,MULTICAST,UP&gt; mtu 1500 qdisc noqueue state LOWERLAYERDOWN group default qlen 1000</span><br><span class="line">    link/ether 9e:67:30:e3:65:34 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br><span class="line">    inet 10.0.0.2/24 brd 10.0.0.255 scope global eth0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>在容器中ping 10.0.0.2也能ping通,说明设置正确</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping 10.0.0.2 # 宿主机上应该不通</span><br><span class="line">docker exec 6414d7278905 ping 10.0.0.2 # 成功ping通</span><br></pre></td></tr></table></figure>

<p>创建网桥，并把veth另一端的虚拟网卡加入新创建的网桥中:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo brctl addbr br666 # 创建新网桥br666</span><br><span class="line">sudo brctl addif br666 veth_d366 # 把虚拟网卡加入网桥br666中</span><br><span class="line">sudo ifconfig br666 10.0.0.1/24 # 设置网桥ip</span><br><span class="line">sudo ip link set veth_d366 up # 启动虚拟网卡</span><br></pre></td></tr></table></figure>

<p>测试下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping 10.0.0.2 # 宿主机上成功ping通</span><br><span class="line">docker exec 6414d7278905 ping 10.0.0.1 # 成功ping通</span><br></pre></td></tr></table></figure>

<p>若以上两个都能ping通说明配置成功！<br>最后，我们需要使得容器能够联外网，需要设置NAT，使用iptables设置:  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o em1 -j MASQUERADE</span><br></pre></td></tr></table></figure>

<p><code>em1</code>是真正的物理网卡对应的网络设备，不同电脑上名字不一样，我的Ubuntu上为<code>enp7s0</code>。<br>另外，还需要设置<code>FORWARD</code>规则（允许<code>br666</code>转发，IP forwarding要开启，使用<code>sudo sysctl -w net.ipv4.ip_forward=1</code>）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo iptables -A FORWARD -i br666 -o br666  -j ACCEPT</span><br><span class="line">sudo iptables -A FORWARD -i br666 ! -o br666  -j ACCEPT</span><br><span class="line">sudo iptables -A FORWARD ! -i br666  -o br666  -j ACCEPT</span><br></pre></td></tr></table></figure>

<p>设置容器默认路由为网桥ip（注意在容器内使用route add 添加, 会出现SIOCADDRT: Operation not permitted错误), 因此只能使用ip netns exec设置:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sudo ip netns exec netns666 route add default gw 10.0.0.1</span><br></pre></td></tr></table></figure>

<p>测试，此时请确保宿主机能够联外网,进入容器内部:</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping baidu.com # 成功ping通，确保icmp没有被禁</span><br></pre></td></tr></table></figure>

<p>效果图：  </p>
<p><img src="/images/my_docker_ping.png" alt="upload successful"></p>
<h2 id="Docker网络和虚拟机网络区别"><a href="#Docker网络和虚拟机网络区别" class="headerlink" title="Docker网络和虚拟机网络区别"></a>Docker网络和虚拟机网络区别</h2><h3 id="虚拟机"><a href="#虚拟机" class="headerlink" title="虚拟机"></a>虚拟机</h3><p>虚拟机，如图，虚拟机通过tun/tap或者其它类似的虚拟网络设备，将虚拟机内的网卡同br0连接起来，这样就达到和真实交换机一样的效果，虚拟机发出去的数据包先到达br0，然后由br0交给eth0发送出去，数据包都不需要经过host机器的协议栈，效率高。  </p>
<p><img src="https://s1.ax1x.com/2020/04/30/Jb090O.png" alt="image"></p>
<h3 id="Docker"><a href="#Docker" class="headerlink" title="Docker"></a>Docker</h3><p>docker，如图，由于容器运行在自己单独的network namespace里面，所以都有自己单独的协议栈，情况和上面的虚拟机差不多，但它采用了另一种方式来和外界通信</p>
<p><img src="https://s1.ax1x.com/2020/04/30/JbrFNF.png" alt></p>
<p>容器中配置网关为.9.1，发出去的数据包先到达<code>br0</code>，然后交给host机器的协议栈，由于目的IP是外网IP，且host机器开启了<code>IP forward</code>功能，于是数据包会通过eth0发送出去，由于.9.1是内网IP，所以一般发出去之前会先做NAT转换（NAT转换和IP forward功能都需要自己配置）。<strong>由于要经过host机器的协议栈，并且还要做NAT转换，所以性能没有上面虚拟机那种方案好</strong>，优点是容器处于内网中，安全性相对要高点。（由于数据包统一由IP层从eth0转发出去，所以不存在mac地址的问题，在无线网络环境下也工作良好）</p>
<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/sparkdev/p/9253409.html" target="_blank" rel="noopener">Linux ip netns 命令</a></li>
<li><a href="https://github.com/int32bit/notes/blob/master/cloud/docker%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86.md" target="_blank" rel="noopener">docker网络原理.md</a></li>
<li><a href="https://www.cnblogs.com/sparkdev/p/9217310.html" target="_blank" rel="noopener">Docker 网络之理解 bridge 驱动</a></li>
<li><a href="http://blog.nsfocus.net/linux-bridge/" target="_blank" rel="noopener">Linux内核网络设备——bridge设备</a></li>
</ul>
]]></content>
      <categories>
        <category>Docker</category>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Docker</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux网络虚拟化技术之tun/tap</title>
    <url>/2020/01/13/tun-tap/</url>
    <content><![CDATA[<p>我们都知道，Linux实际是通过<strong>网络设备</strong>去操作和使用网卡的，系统安装了一个网卡之后会为其生成一个网络设备实例，比如<strong>eth0</strong>（或者叫<strong>enp7s0</strong>，不同发行版默认网卡命名规则不同）。随着网络虚拟化技术的发展，Linux支持创建出虚拟化的设备，可以通过虚拟化设备的组合实现多种多样的功能和网络拓扑。<br>常见的虚拟化设备有<strong>tun/tap</strong>、<strong>Veth</strong>、<strong>Bridge</strong>、<strong>802.1q VLAN device</strong>。  </p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.3 LTS</li>
</ul>
<a id="more"></a>

<p>先回顾一下经典的<strong>OSI</strong>七层网络模型：<br>┌───────┐<br>  │　应用层　│←第七层<br>├───────┤<br>│　表示层　│<br>├───────┤<br>│　会话层　│<br>├───────┤<br>│　传输层　│<br>├───────┤<br>│　网络层　│<br>├───────┤<br>│数据链路层│<br>├───────┤<br>│　物理层　│←第一层<br>└───────┘ </p>
<p>OSI七层参考模型</p>
<h2 id="虚拟设备和物理设备的区别"><a href="#虚拟设备和物理设备的区别" class="headerlink" title="虚拟设备和物理设备的区别"></a>虚拟设备和物理设备的区别</h2><p>对于一个网络设备来说，就像一个管道（pipe）一样，<strong>有两端</strong>，从其中任意一端收到的数据将从另一端发送出去。  </p>
<p>比如一个物理网卡eth0，它的两端分别是内核协议栈（通过内核网络设备管理模块间接的通信）和外面的物理网络，从物理网络收到的数据，会转发给内核协议栈，而应用程序从协议栈发过来的数据将会通过物理网络发送出去。  </p>
<p>那么对于一个虚拟网络设备呢？首先它也归内核的网络设备管理子系统管理，对于Linux内核网络设备管理模块来说，虚拟设备和物理设备没有区别，都是网络设备，都能配置IP，从网络设备来的数据，都会转发给协议栈，协议栈过来的数据，也会交由网络设备发送出去，至于是怎么发送出去的，发到哪里去，那是设备驱动的事情，跟Linux内核就没关系了，所以说虚拟网络设备的一端也是协议栈，而另一端是什么取决于虚拟网络设备的驱动实现。</p>
<h2 id="tun-tap"><a href="#tun-tap" class="headerlink" title="tun/tap"></a>tun/tap</h2><h3 id="tun分析实验"><a href="#tun分析实验" class="headerlink" title="tun分析实验"></a>tun分析实验</h3><p>先上图说话：<br><img src="https://s2.ax1x.com/2020/01/13/l7D6zT.png" alt></p>
<p>上图中是<strong>tun</strong>设备的数据走向。<br>图中<strong>nsfocus_tun0</strong>就是tun0，是一个tun/tap虚拟设备，而<strong>eno16777736</strong>就是eth0。<br>socket、协议栈（Newwork Protocol Stack）和网络设备（eth0和tun0）部分都在内核层，其实socket是协议栈的一部分，这里分开来的目的是为了看的更直观。</p>
<p>从上图中可以看出它和物理设备eth0的差别，它们的一端虽然都连着协议栈，但另一端不一样，eth0的另一端是物理网络，这个物理网络可能就是一个交换机，而tun0的另一端是一个用户层的程序，协议栈发给tun0的数据包能被这个应用程序读取到，并且应用程序能直接向tun0写数据。  </p>
<p>数据流向分析：</p>
<ol>
<li>User Application A通过套接字（socket A）发数据发给使用与<strong>eno16777736</strong>处于同一个网段ip的应用程序，数据走向为通过socket A发给协议栈，最后通过netdevice子系统中的eno16777736的设备驱动（以太网驱动）发送出去，这个是通过真实的物理网卡发送出去。</li>
<li>User Application B通过套接字（socket B）发送数据给使用与<strong>nsfocus_tun0</strong>处于同一个网段ip的应用程序，数据走向为通过socket B发送给协议栈，最后通过netdevice子系统中的<strong>nsfocus_tun0</strong>的设备驱动（tun驱动）发送出去。由于tun设备没有对应真实的物理网卡，所以nsfocus_tun0对端收取数据的是User Application C。User Application C通过读写/dev/tun设备文件进行数据的收发。</li>
</ol>
<p>其实一般<strong>User Application C</strong>就是个VPN程序（例如openvpn），它收到数据包之后，做一些跟业务相关的处理，然后构造一个新的数据包，将原来的数据包嵌入在新的数据包中，最后通过socket B将数据包转发出去，这时候新数据包的源地址变成了eth0的地址，而目的IP地址变成了一个其它的地址，比如是10.33.0.1（VPN服务器地址），协议栈根据本地路由，发现这个数据包应该要通过<strong>eth0</strong>发送出去，于是将数据包交给eth0，最后<strong>eth0</strong>通过物理网络将数据包发送出去。</p>
<p>从上面的流程中可以看出，数据包选择走哪个网络设备完全由<strong>路由表</strong>控制，所以如果我们想让某些网络流量走应用程序B的转发流程，就需要配置路由表让这部分数据走tun0。</p>
<h3 id="示例程序"><a href="#示例程序" class="headerlink" title="示例程序"></a>示例程序</h3><p>为了使用tun/tap设备，用户层程序需要通过系统调用打开/dev/net/tun获得一个读写该设备的文件描述符(FD)，并且调用ioctl()向内核注册一个TUN或TAP类型的虚拟网卡(实例化一个tun/tap设备)，其名称可能是<strong>tap7b7ee9a9-c1/vnetXX/tunXX/tap0</strong>等。</p>
<p>这里写了一个程序，它收到tun设备的数据包之后，只打印出收到了多少字节的数据包，其它的什么都不做。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;net/if.h&gt;</span><br><span class="line">#include &lt;sys/ioctl.h&gt;</span><br><span class="line">#include &lt;sys/stat.h&gt;</span><br><span class="line">#include &lt;fcntl.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line">#include &lt;sys/types.h&gt;</span><br><span class="line">#include &lt;linux/if_tun.h&gt;</span><br><span class="line">#include&lt;stdlib.h&gt;</span><br><span class="line">#include&lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int tun_alloc(int flags)</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    struct ifreq ifr;</span><br><span class="line">    int fd, err;</span><br><span class="line">    char *clonedev = &quot;/dev/net/tun&quot;;</span><br><span class="line"></span><br><span class="line">    if ((fd = open(clonedev, O_RDWR)) &lt; 0) &#123;</span><br><span class="line">        return fd;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    memset(&amp;ifr, 0, sizeof(ifr));</span><br><span class="line">    ifr.ifr_flags = flags;</span><br><span class="line"></span><br><span class="line">    if ((err = ioctl(fd, TUNSETIFF, (void *) &amp;ifr)) &lt; 0) &#123;</span><br><span class="line">        close(fd);</span><br><span class="line">        return err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printf(&quot;Open tun/tap device: %s for reading...\n&quot;, ifr.ifr_name);</span><br><span class="line"></span><br><span class="line">    return fd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    int tun_fd, nread;</span><br><span class="line">    char buffer[1500];</span><br><span class="line"></span><br><span class="line">    /* Flags: IFF_TUN   - TUN device (no Ethernet headers)</span><br><span class="line">     *        IFF_TAP   - TAP device</span><br><span class="line">     *        IFF_NO_PI - Do not provide packet information</span><br><span class="line">     */</span><br><span class="line">    tun_fd = tun_alloc(IFF_TUN | IFF_NO_PI);</span><br><span class="line"></span><br><span class="line">    if (tun_fd &lt; 0) &#123;</span><br><span class="line">        perror(&quot;Allocating interface&quot;);</span><br><span class="line">        exit(1);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        nread = read(tun_fd, buffer, sizeof(buffer));</span><br><span class="line">        if (nread &lt; 0) &#123;</span><br><span class="line">            perror(&quot;Reading from interface&quot;);</span><br><span class="line">            close(tun_fd);</span><br><span class="line">            exit(1);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        printf(&quot;Read %d bytes from tun/tap device\n&quot;, nread);</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译、运行程序，会发现多出一个网络设备</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ gcc -o tun tun.c</span><br><span class="line">$ sudo ./tun</span><br><span class="line">Open tun/tap device: tun0 for reading...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">$ ip addr</span><br><span class="line">...</span><br><span class="line">8: tun0: &lt;POINTOPOINT,MULTICAST,NOARP&gt; mtu 1500 qdisc noop state DOWN group default qlen 500</span><br><span class="line">    link/none</span><br></pre></td></tr></table></figure>

<p><code>tun0</code>就是新增的网络设备，现在给它配置一个ip，查看接口信息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ sudo ifconfig tun0 192.168.10.11/24</span><br><span class="line">$ ip addr</span><br><span class="line">...</span><br><span class="line">8: tun0: &lt;POINTOPOINT,MULTICAST,NOARP,UP,LOWER_UP&gt; mtu 1500 qdisc fq_codel state UNKNOWN group default qlen 500</span><br><span class="line">    link/none </span><br><span class="line">    inet 192.168.10.11/24 scope global tun0</span><br><span class="line">       valid_lft forever preferred_lft forever</span><br><span class="line">    inet6 fe80::dd59:736:65ee:e31a/64 scope link stable-privacy </span><br><span class="line">       valid_lft forever preferred_lft forever</span><br></pre></td></tr></table></figure>

<p>这时候我们ping地址<code>192.168.10.12</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">ping 192.168.10.12 -c 2</span><br></pre></td></tr></table></figure>

<p>发现<code>tun</code>程序收到了数据<br><img src="https://s2.ax1x.com/2020/01/13/l7oJfS.png" alt></p>
<h3 id="tun和tap区别"><a href="#tun和tap区别" class="headerlink" title="tun和tap区别"></a>tun和tap区别</h3><p>两者很类似，只是tun和tap设备他们工作的协议栈层次不同，tap等同于一个以太网设备，用户层程序向tap设备读写的是二层数据包如以太网数据帧，tap设备最常用的就是作为虚拟机网卡。tun则模拟了网络层设备，操作第三层数据包比如IP数据包，openvpn使用TUN设备在C/S间建立VPN隧道。</p>
<h3 id="tap分析实验"><a href="#tap分析实验" class="headerlink" title="tap分析实验"></a>tap分析实验</h3><p>tap设备最常见的用途就是作为虚拟机网卡。</p>
<h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul>
<li><a href="https://segmentfault.com/a/1190000009249039" target="_blank" rel="noopener">Linux虚拟网络设备之tun/tap</a></li>
<li><a href="https://opengers.github.io/openstack/openstack-base-virtual-network-devices-tuntap-veth/" target="_blank" rel="noopener">云计算底层技术-虚拟网络设备(tun/tap,veth)
</a></li>
</ul>
]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
        <tag>network</tag>
        <tag>tun</tag>
        <tag>tap</tag>
      </tags>
  </entry>
  <entry>
    <title>基于Zookeeper的分布式锁</title>
    <url>/2020/03/12/zookeeper_cluster_lock/</url>
    <content><![CDATA[<img src="/images/zk-logo.png" width="300px">


<p>Zookeeper 是 Apache 的一个顶级项目，为分布式应用提供高效、高可用的分布式协调服务，提供了诸如数据发布/订阅、负载均衡、命名服务、分布式协调/通知和分布式锁等分布式基础服务。<br>由于 ZooKeeper 便捷的使用方式、卓越的性能和良好的稳定性，被广泛地应用于诸如 Hadoop、HBase、Kafka 和 Dubbo 等大型分布式系统中。</p>
<a id="more"></a>

<h2 id="搭建Zookeeper集群"><a href="#搭建Zookeeper集群" class="headerlink" title="搭建Zookeeper集群"></a>搭建Zookeeper集群</h2><p>这里我们用Docker在本机上快速搭建一个zk集群，根据官方的<a href="https://hub.docker.com/_/zookeeper" target="_blank" rel="noopener">zookeeper镜像</a>给的docker-compose文件，我们稍加修改就可以了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &apos;2&apos;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line">  zoo1:</span><br><span class="line">    image: zookeeper:3.4</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: zoo1</span><br><span class="line">    ports:</span><br><span class="line">      - 2181:2181</span><br><span class="line">    environment:</span><br><span class="line">      ZOO_MY_ID: 1</span><br><span class="line">      ZOO_SERVERS: server.1=0.0.0.0:2888:3888 server.2=zoo2:2888:3888 server.3=zoo3:2888:3888</span><br><span class="line">    volumes:</span><br><span class="line">    - ./zoo1/data:/data</span><br><span class="line">    - ./zoo1/datalog:/datalog</span><br><span class="line"></span><br><span class="line">  zoo2:</span><br><span class="line">    image: zookeeper:3.4</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: zoo2</span><br><span class="line">    ports:</span><br><span class="line">      - 2182:2181</span><br><span class="line">    environment:</span><br><span class="line">      ZOO_MY_ID: 2</span><br><span class="line">      ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=0.0.0.0:2888:3888 server.3=zoo3:2888:3888</span><br><span class="line">    volumes:</span><br><span class="line">    - ./zoo2/data:/data</span><br><span class="line">    - ./zoo2/datalog:/datalog</span><br><span class="line"></span><br><span class="line">  zoo3:</span><br><span class="line">    image: zookeeper:3.4</span><br><span class="line">    restart: always</span><br><span class="line">    hostname: zoo3</span><br><span class="line">    ports:</span><br><span class="line">      - 2183:2181</span><br><span class="line">    environment:</span><br><span class="line">      ZOO_MY_ID: 3</span><br><span class="line">      ZOO_SERVERS: server.1=zoo1:2888:3888 server.2=zoo2:2888:3888 server.3=0.0.0.0:2888:3888</span><br><span class="line">    volumes:</span><br><span class="line">    - ./zoo3/data:/data</span><br><span class="line">    - ./zoo3/datalog:/datalog</span><br></pre></td></tr></table></figure>

<p><code>docker-compose up</code> 启动集群，然后查看服务状态：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ docker-compose ps</span><br><span class="line">          Name                        Command               State                          Ports                        </span><br><span class="line">------------------------------------------------------------------------------------------------------------------------</span><br><span class="line">zookeeper-cluster_zoo1_1   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2181-&gt;2181/tcp, 2888/tcp, 3888/tcp, 8080/tcp</span><br><span class="line">zookeeper-cluster_zoo2_1   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2182-&gt;2181/tcp, 2888/tcp, 3888/tcp, 8080/tcp</span><br><span class="line">zookeeper-cluster_zoo3_1   /docker-entrypoint.sh zkSe ...   Up      0.0.0.0:2183-&gt;2181/tcp, 2888/tcp, 3888/tcp, 8080/tcp</span><br><span class="line"></span><br><span class="line">$ docker-compose exec zoo1 ./bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br><span class="line"></span><br><span class="line">$ docker-compose exec zoo2 ./bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /conf/zoo.cfg</span><br><span class="line">Mode: follower</span><br><span class="line"></span><br><span class="line">$ docker-compose exec zoo3 ./bin/zkServer.sh status</span><br><span class="line">ZooKeeper JMX enabled by default</span><br><span class="line">Using config: /conf/zoo.cfg</span><br><span class="line">Mode: leader</span><br></pre></td></tr></table></figure>

<p>可以看到zoo3这个节点是leader节点（<code>zookeeper</code>3.5的镜像似乎有点问题，集群起来后有个节点一直出错，所以我用了3.4）。</p>
<h2 id="zookeeper配置文件"><a href="#zookeeper配置文件" class="headerlink" title="zookeeper配置文件"></a>zookeeper配置文件</h2><p>zoo.cfg配置文件常见配置</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tickTime=2000</span><br><span class="line">initLimit=10</span><br><span class="line">syncLimit=5</span><br><span class="line">dataLogDir=/opt/zookeeper/logs</span><br><span class="line">dataDir=/opt/zookeeper/data</span><br><span class="line">clientPort=2181</span><br><span class="line">autopurge.snapRetainCount=500</span><br><span class="line">autopurge.purgeInterval=24</span><br><span class="line">server.1= 192.168.1.148:2888:3888</span><br><span class="line">server.2= 192.168.1.149:2888:3888</span><br><span class="line">server.3= 192.168.1.150:2888:3888</span><br></pre></td></tr></table></figure>

<p>zoo.cfg配置文件参数详细说明  </p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>clientPort</td>
<td>客户端连接server的端口，即对外服务端口，一般设置为2181吧。</td>
</tr>
<tr>
<td>dataDir</td>
<td>存储快照文件snapshot的目录。默认情况下，事务日志也会存储在这里。建议同时配置参数dataLogDir, 事务日志的写性能直接影响zk性能。</td>
</tr>
<tr>
<td>tickTime</td>
<td>ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。</td>
</tr>
<tr>
<td>dataLogDir</td>
<td>事务日志输出目录。尽量给事务日志的输出配置单独的磁盘或是挂载点，这将极大的提升ZK性能。 （No Java system property）</td>
</tr>
<tr>
<td>globalOutstandingLimit</td>
<td>最大请求堆积数。默认是1000。ZK运行的时候， 尽管server已经没有空闲来处理更多的客户端请求了，但是还是允许客户端将请求提交到服务器上来，以提高吞吐性能。当然，为了防止Server内存溢出，这个请求堆积数还是需要限制下的。 (Java system property:zookeeper.globalOutstandingLimit. )</td>
</tr>
<tr>
<td>preAllocSize</td>
<td>预先开辟磁盘空间，用于后续写入事务日志。默认是64M，每个事务日志大小就是64M。如果ZK的快照频率较大的话，建议适当减小这个参数。(Java system property:zookeeper.preAllocSize )</td>
</tr>
<tr>
<td>snapCount</td>
<td>每进行snapCount次事务日志输出后，触发一次快照(snapshot), 此时，ZK会生成一个snapshot.文件，同时创建一个新的事务日志文件log.。默认是100000.（真正的代码实现中，会进行一定的随机数处理，以避免所有服务器在同一时间进行快照而影响性能）(Java system property:zookeeper.snapCount )</td>
</tr>
<tr>
<td>traceFile</td>
<td>用于记录所有请求的log，一般调试过程中可以使用，但是生产环境不建议使用，会严重影响性能。(Java system property:? requestTraceFile )</td>
</tr>
<tr>
<td>maxClientCnxns</td>
<td>单个客户端与单台服务器之间的连接数的限制，是ip级别的，默认是60，如果设置为0，那么表明不作任何限制。请注意这个限制的使用范围，仅仅是单台客户端机器与单台ZK服务器之间的连接数限制，不是针对指定客户端IP，也不是ZK集群的连接数限制，也不是单台ZK对所有客户端的连接数限制。指定客户端IP的限制策略，这里有一个patch，可以尝试一下：<a href="http://rdc\.taobao\.com/team/jm/archives/1334（No" target="_blank" rel="noopener">http://rdc\.taobao\.com/team/jm/archives/1334（No</a> Java system property）</td>
</tr>
<tr>
<td>clientPortAddress</td>
<td>对于多网卡的机器，可以为每个IP指定不同的监听端口。默认情况是所有IP都监听 clientPort 指定的端口。 New in 3.3.0</td>
</tr>
<tr>
<td>minSessionTimeoutmaxSessionTimeoutSession</td>
<td>超时时间限制，如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。默认的Session超时时间是在2 * tickTime ~ 20 * tickTime 这个范围 New in 3.3.0</td>
</tr>
<tr>
<td>fsync.warningthresholdms</td>
<td>事务日志输出时，如果调用fsync方法超过指定的超时时间，那么会在日志中输出警告信息。默认是1000ms。(Java system property: fsync.warningthresholdms )New in 3.3.4</td>
</tr>
<tr>
<td>autopurge.purgeInterval</td>
<td>在上文中已经提到，3.4.0及之后版本，ZK提供了自动清理事务日志和快照文件的功能，这个参数指定了清理频率，单位是小时，需要配置一个1或更大的整数，默认是0，表示不开启自动清理功能。(No Java system property) New in 3.4.0</td>
</tr>
<tr>
<td>autopurge.snapRetainCount</td>
<td>这个参数和上面的参数搭配使用，这个参数指定了需要保留的文件数目。默认是保留3个。(No Java system property) New in 3.4.0</td>
</tr>
<tr>
<td>electionAlg</td>
<td>在之前的版本中， 这个参数配置是允许我们选择leader选举算法，但是由于在以后的版本中，只会留下一种“TCP-based version of fast leader election”算法，所以这个参数目前看来没有用了，这里也不详细展开说了。(No Java system property)</td>
</tr>
<tr>
<td>initLimitFollowe</td>
<td>r在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在 initLimit 时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。(No Java system property)</td>
</tr>
<tr>
<td>syncLimit</td>
<td>在运行过程中，Leader负责与ZK集群中所有机器进行通信，例如通过一些心跳检测机制，来检测机器的存活状态。如果L发出心跳包在syncLimit之后，还没有从F那里收到响应，那么就认为这个F已经不在线了。注意：不要把这个参数设置得过大，否则可能会掩盖一些问题。(No Java system property)</td>
</tr>
<tr>
<td>leaderServes</td>
<td>默认情况下，Leader是会接受客户端连接，并提供正常的读写服务。但是，如果你想让Leader专注于集群中机器的协调，那么可以将这个参数设置为no，这样一来，会大大提高写操作的性能。(Java system property: zookeeper. leaderServes )。</td>
</tr>
<tr>
<td>server.x=[hostname]:nnnnn[:nnnnn]</td>
<td>这里的x是一个数字，与myid文件中的id是一致的。右边可以配置两个端口，第一个端口用于F和L之间的数据同步和其它通信，第二个端口用于Leader选举过程中投票通信。 (No Java system property)</td>
</tr>
<tr>
<td>group.x=nnnnn[:nnnnn]weight.x=nnnnn</td>
<td>对机器分组和权重设置，可以 参见这里(No Java system property)</td>
</tr>
<tr>
<td>cnxTimeoutLeader</td>
<td>选举过程中，打开一次连接的超时时间，默认是5s。(Java system property: zookeeper. cnxTimeout)</td>
</tr>
<tr>
<td>zookeeper.DigestAuthenticationProvider.superDigestZK</td>
<td>权限设置相关，具体参见 《 使用super 身份对有权限的节点进行操作 》  和 《 ZooKeeper 权限控制 》</td>
</tr>
<tr>
<td>skipACL</td>
<td>对所有客户端请求都不作ACL检查。如果之前节点上设置有权限限制，一旦服务器上打开这个开头，那么也将失效。(Java system property: zookeeper.skipACL )</td>
</tr>
<tr>
<td>forceSync</td>
<td>这个参数确定了是否需要在事务日志提交的时候调用 FileChannel .force来保证数据完全同步到磁盘。(Java system property: zookeeper.forceSync )</td>
</tr>
<tr>
<td>jute.maxbuffer</td>
<td>每个节点最大数据量，是默认是1M。这个限制必须在server和client端都进行设置才会生效。(Java system property: jute.maxbuffer )</td>
</tr>
</tbody></table>
<p>上面的<code>docker-compose.yml</code>文件中，我没用配置文件，但是上面的配置项其实可以用<code>zookeeper镜像</code>里的环境变量来实现，例如<code>ZOO_TICK_TIME</code>。</p>
<h2 id="Zookeeper分布式锁实现"><a href="#Zookeeper分布式锁实现" class="headerlink" title="Zookeeper分布式锁实现"></a>Zookeeper分布式锁实现</h2><h3 id="Zookeeper的节点"><a href="#Zookeeper的节点" class="headerlink" title="Zookeeper的节点"></a>Zookeeper的节点</h3><p>要用Zookeeper实现分布式锁，我就不得不说说Zookeeper的数据存储。首先zookeeper的核心保存结构是一个DataTree数据结构，其实内部是一个Map&lt;String, DataNode&gt; nodes的数据结构，其中key是path，DataNode才是真正保存数据的核心数据结构，DataNode核心字段包括byte data[]用于保存节点内容。  </p>
<p>节点是Zookeeper（zk）中数据存储的基础结构，zk中万物皆节点，就好比Java中万物皆对象一样。zk的数据模型就是基于节点的树形结构，但zk规定每个节点的引用规则是路径引用。每个节点中包含子节点引用、存储数据、访问权限以及节点元数据等四部分。</p>
<p><img src="/images/pasted-2.png" alt="upload successful">  </p>
<p>zookeeper中提供了节点类型主要有：  </p>
<ul>
<li><strong>持久节点</strong>：节点创建后，就一直存在，直到有删除操作来主动清除。</li>
<li><strong>顺序节点</strong>：假如当前有一个父节点为/lock，我们可以在这个父节点下面创建子节点；zk提供了一个可选的有序特性，例如我们可以创建子节点“/lock/test_”并且指明有序，那么zk在生成子节点时会根据当前子节点数量自动添加整数序号，如果第一个子节点为/lock/test_0000000000，下一个节点则为/lock/test_0000000001，依次类推。</li>
<li><strong>临时节点</strong>：客户端可以建立一个临时节点，在会话结束或者会话超时后，zookeeper会自动删除该节点。</li>
</ul>
]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>zookeeper</tag>
      </tags>
  </entry>
  <entry>
    <title>ftplib源码分析</title>
    <url>/2020/05/13/ftplib_source/</url>
    <content><![CDATA[<h2 id="FTP协议"><a href="#FTP协议" class="headerlink" title="FTP协议"></a>FTP协议</h2><p>相比其他协议，如 HTTP 协议，FTP 协议要复杂一些。与一般的 C/S 应用不同点在于一般的C/S 应用程序一般只会建立一个 Socket 连接，这个连接同时处理服务器端和客户端的连接命令和数据传输。而FTP协议中将命令与数据分开传送的方法提高了效率。 </p>
<a id="more"></a>


<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.4 LTS 还有 Windows 10专业版</li>
<li>ftplib：V4.0-1</li>
<li>gcc： 7.5.0 (Ubuntu 7.5.0-3ubuntu1~18.04)</li>
</ul>
<h3 id="命令结构"><a href="#命令结构" class="headerlink" title="命令结构"></a>命令结构</h3><p>FTP 每个命令都有 3 到 4 个大写字母组成，命令后面跟参数，用空格分开。每个命令都以 “\r\n”结束（应答也是用”\r\n”结束），例如发送一个<code>CWD</code>命令，那要要发送数据就是：<code>CWD dirname\r\n</code>。  </p>
<p>常见的FTP命令有：<br><img src="https://s1.ax1x.com/2020/05/12/YNtW3F.png" alt></p>
<h3 id="响应结构"><a href="#响应结构" class="headerlink" title="响应结构"></a>响应结构</h3><p>FTP响应跟命令结构是类似的。<br>FTP响应通常是单行的，格式为”响应码+空格+提示信息+\r\n”。如果需要<strong>产生一条多行应答</strong>，第1行在第3位数字应答码之后包含一个连字符”-“，而不是空格，最后一行包含相同的3位数字应答码，后跟一个空格字符。</p>
<h3 id="FTP响应码"><a href="#FTP响应码" class="headerlink" title="FTP响应码"></a>FTP响应码</h3><p>客户端发送 FTP 命令后，服务器返回响应码。<br>响应码用<strong>三位数字编码</strong>表示：<br>第一个数字给出了命令状态的一般性指示，比如响应成功、失败或不完整。<br>第二个数字是响应类型的分类，如 2 代表跟连接有关的响应，3 代表用户认证。<br>第三个数字提供了更加详细的信息。  </p>
<p>第一个数字的含义如下：  </p>
<ul>
<li>1 表示服务器正确接收信息，还未处理。</li>
<li>2 表示服务器已经正确处理信息。</li>
<li>3 表示服务器正确接收信息，正在处理。</li>
<li>4 表示信息暂时错误。</li>
<li>5 表示信息永久错误。</li>
</ul>
<p>第二个数字的含义如下：  </p>
<ul>
<li>0 表示语法。</li>
<li>1 表示系统状态和信息。</li>
<li>2 表示连接状态。</li>
<li>3 表示与用户认证有关的信息。</li>
<li>4 表示未定义。</li>
<li>5 表示与文件系统有关的信息。</li>
</ul>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>用<code>客户端登录 FTP 服务器</code>为例子<br><img src="https://s1.ax1x.com/2020/05/18/YfCuff.jpg" alt></p>
<p>大致调用函数过称为：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 命令 ”USER username\r\n” */</span><br><span class="line">sprintf(send_buf,&quot;USER %s\r\n&quot;,username);</span><br><span class="line">/*客户端发送用户名到服务器端 */</span><br><span class="line">write(control_sock, send_buf, strlen(send_buf));</span><br><span class="line">/* 客户端接收服务器的响应码和信息，正常为 ”331 User name okay, need password.” */</span><br><span class="line">read(control_sock, read_buf, read_len);</span><br><span class="line"> </span><br><span class="line">/* 命令 ”PASS password\r\n” */</span><br><span class="line">sprintf(send_buf,&quot;PASS %s\r\n&quot;,password);</span><br><span class="line">/* 客户端发送密码到服务器端 */</span><br><span class="line">write(control_sock, send_buf, strlen(send_buf));</span><br><span class="line">/* 客户端接收服务器的响应码和信息，正常为 ”230 User logged in, proceed.” */</span><br><span class="line">read(control_sock, read_buf, read_len);</span><br></pre></td></tr></table></figure>

<h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p>ftplib在这里<a href="https://nbpfaus.net/~pfau/ftplib/" target="_blank" rel="noopener">下载</a>。</p>
<p>登录了FTP服务器后，肯定需要一个句柄的量，在这个<code>ftplib</code>中是<code>netbuf</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">NetBuf</span> <span class="title">netbuf</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">NetBuf</span> &#123;</span></span><br><span class="line">    <span class="keyword">char</span> *cput,*cget;</span><br><span class="line">    <span class="keyword">int</span> handle;</span><br><span class="line">    <span class="keyword">int</span> cavail,cleft;</span><br><span class="line">    <span class="keyword">char</span> *buf;</span><br><span class="line">    <span class="keyword">int</span> dir;</span><br><span class="line">    netbuf *ctrl;</span><br><span class="line">    netbuf *data;    </span><br><span class="line">    <span class="keyword">int</span> cmode;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">idletime</span>;</span></span><br><span class="line">    FtpCallback idlecb;</span><br><span class="line">    <span class="keyword">void</span> *idlearg;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> xfered;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> cbbytes;</span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> <span class="keyword">int</span> xfered1;</span><br><span class="line">    <span class="keyword">char</span> response[RESPONSE_BUFSIZ];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>handle</code>字段其实就存了tcp握手成功后的<code>socket</code>。</p>
<h3 id="FtpSendCmd函数"><a href="#FtpSendCmd函数" class="headerlink" title="FtpSendCmd函数"></a>FtpSendCmd函数</h3><p>首先来看<code>FtpSendCmd</code>函数，这个函数顾名思义，就是用来发送FTP命令，你在<code>FtpPwd</code>、<code>FtpNlst</code>、<code>FtpDir</code>、<code>FtpGet</code>等函数中都可以看到它：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">FtpSendCmd</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cmd, <span class="keyword">char</span> expresp, netbuf *nControl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> buf[TMP_BUFSIZ];</span><br><span class="line">    <span class="keyword">if</span> (nControl-&gt;dir != FTPLIB_CONTROL)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (ftplib_debug &gt; <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s\n"</span>,cmd);</span><br><span class="line">    <span class="keyword">if</span> ((<span class="built_in">strlen</span>(cmd) + <span class="number">3</span>) &gt; <span class="keyword">sizeof</span>(buf))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">sprintf</span>(buf,<span class="string">"%s\r\n"</span>,cmd);</span><br><span class="line">    <span class="keyword">if</span> (net_write(nControl-&gt;handle, buf, <span class="built_in">strlen</span>(buf)) &lt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ftplib_debug)</span><br><span class="line">            perror(<span class="string">"write"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> readresp(expresp, nControl);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这个函数的过程：</p>
<ol>
<li>用<code>net_write</code>函数操作socket发送数据</li>
<li><code>readresp</code>函数读取服务器响应</li>
</ol>
<h4 id="net-write函数"><a href="#net-write函数" class="headerlink" title="net_write函数"></a>net_write函数</h4><p>我们查看一下<code>net_write</code>，其实它就是封装了一下<code>write</code>函数，因为<strong>TCP通信对于应用程序来说是完全异步</strong>，你调用<code>write</code>写入5个字节，返回不一定是5个字节，可能是3个，4个，所以<code>net_write</code>多次调用了<code>write</code>（在《UNIX网络编程 卷1》中，作者也有类似的封装）。另外，<code>write</code>返回成功了也只代表buf中的数据被复制到了kernel中的TCP发送缓冲区，至于数据什么时候被发往网络，什么时候被对方主机接收，什么时候被对方进程读取，系统调用层面不会给予任何保证和通知。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">net_write</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span> *buf, <span class="keyword">size_t</span> len)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> done = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> ( len &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> c = write( fd, buf, len );</span><br><span class="line">        <span class="keyword">if</span> ( c == <span class="number">-1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> ( errno != EINTR &amp;&amp; errno != EAGAIN )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( c == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> done;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            buf += c;</span><br><span class="line">            done += c;</span><br><span class="line">            len -= c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> done;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="readresp函数"><a href="#readresp函数" class="headerlink" title="readresp函数"></a>readresp函数</h4><p>发送了FTP的命令数据后，就需要用socket接受响应数据了，<strong>切记TCP是流式传输的</strong>，所以你需要自己做应用层的解析。<br>FTP的消息块的分割符是<code>\r\n</code>，看<code>readline</code>函数名应该是读取一行数据</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readresp</span><span class="params">(<span class="keyword">char</span> c, netbuf *nControl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> match[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">if</span> (readline(nControl-&gt;response, RESPONSE_BUFSIZ, nControl) == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ftplib_debug)</span><br><span class="line">            perror(<span class="string">"Control socket read failed"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ftplib_debug &gt; <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s"</span>,nControl-&gt;response);</span><br><span class="line">    <span class="keyword">if</span> (nControl-&gt;response[<span class="number">3</span>] == <span class="string">'-'</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">strncpy</span>(match,nControl-&gt;response,<span class="number">3</span>);</span><br><span class="line">        match[<span class="number">3</span>] = <span class="string">' '</span>;</span><br><span class="line">        match[<span class="number">4</span>] = <span class="string">'\0'</span>;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (readline(nControl-&gt;response, RESPONSE_BUFSIZ, nControl) == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ftplib_debug)</span><br><span class="line">                    perror(<span class="string">"Control socket read failed"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ftplib_debug &gt; <span class="number">1</span>)</span><br><span class="line">                <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s"</span>,nControl-&gt;response);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span> (<span class="built_in">strncmp</span>(nControl-&gt;response, match, <span class="number">4</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (nControl-&gt;response[<span class="number">0</span>] == c)</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="readline函数"><a href="#readline函数" class="headerlink" title="readline函数"></a>readline函数</h4><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">readline</span><span class="params">(<span class="keyword">char</span> *buf, <span class="keyword">int</span> max, netbuf *ctl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x, retval = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">char</span> *end,*bp=buf;</span><br><span class="line">    <span class="keyword">int</span> eof = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((ctl-&gt;dir != FTPLIB_CONTROL) &amp;&amp; (ctl-&gt;dir != FTPLIB_READ))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">if</span> (max == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (ctl-&gt;cavail &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            x = (max &gt;= ctl-&gt;cavail) ? ctl-&gt;cavail : max<span class="number">-1</span>;</span><br><span class="line">            end = memccpy(bp, ctl-&gt;cget, <span class="string">'\n'</span>,x);</span><br><span class="line">            <span class="keyword">if</span> (end != <span class="literal">NULL</span>)</span><br><span class="line">                x = end - bp;</span><br><span class="line">            retval += x;</span><br><span class="line">            bp += x;</span><br><span class="line">            *bp = <span class="string">'\0'</span>;</span><br><span class="line">            max -= x;</span><br><span class="line">            ctl-&gt;cget += x;</span><br><span class="line">            ctl-&gt;cavail -= x;</span><br><span class="line">            <span class="keyword">if</span> (end != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                bp -= <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(bp,<span class="string">"\r\n"</span>) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    *bp++ = <span class="string">'\n'</span>;</span><br><span class="line">                    *bp++ = <span class="string">'\0'</span>;</span><br><span class="line">                    --retval;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (max == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            *buf = <span class="string">'\0'</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ctl-&gt;cput == ctl-&gt;cget)</span><br><span class="line">        &#123;</span><br><span class="line">            ctl-&gt;cput = ctl-&gt;cget = ctl-&gt;buf;</span><br><span class="line">            ctl-&gt;cavail = <span class="number">0</span>;</span><br><span class="line">            ctl-&gt;cleft = FTPLIB_BUFSIZ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (eof)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (retval == <span class="number">0</span>)</span><br><span class="line">                retval = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!socket_wait(ctl))</span><br><span class="line">            <span class="keyword">return</span> retval;</span><br><span class="line">        <span class="keyword">if</span> ((x = net_read(ctl-&gt;handle, ctl-&gt;cput, ctl-&gt;cleft)) == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (ftplib_debug)</span><br><span class="line">                perror(<span class="string">"read"</span>);</span><br><span class="line">            retval = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == <span class="number">0</span>)</span><br><span class="line">            eof = <span class="number">1</span>;</span><br><span class="line">        ctl-&gt;cleft -= x;</span><br><span class="line">        ctl-&gt;cavail += x;</span><br><span class="line">        ctl-&gt;cput += x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="socket-wait-函数"><a href="#socket-wait-函数" class="headerlink" title="socket_wait()函数"></a>socket_wait()函数</h4><p>这个函数用了<code>select</code>系统函数，用来检测<code>ctl-&gt;handle</code>是否可读（这里可读的时候就是服务端发过来响应数据了）。select函数的返回值：返回-1表示调用select函数时有错误发生，具体的错误在Linux可通过errno输出来查看；返回0，表示select函数超时；返回正数即调用select函数成功，表示集合中文件描述符的数量，集合也会被修改以显示哪一个文件描述符已准备就绪。<br>不过在用来发送命令的<code>socket</code>上（也就是调用<code>FtpConnect</code>函数得到的那个<code>socket</code>），因为<code>ctl-&gt;dir</code>是<code>FTPLIB_CONTROL</code>（<code>ctl-&gt;idlecb</code>也是NULL），所以直接返回了1。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * socket_wait - wait for socket to receive or flush data</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * return 1 if no user callback, otherwise, return value returned by</span></span><br><span class="line"><span class="comment"> * user callback</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">socket_wait</span><span class="params">(netbuf *ctl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    fd_set fd,*rfd = <span class="literal">NULL</span>,*wfd = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">tv</span>;</span></span><br><span class="line">    <span class="keyword">int</span> rv = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((ctl-&gt;dir == FTPLIB_CONTROL) || (ctl-&gt;idlecb == <span class="literal">NULL</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (ctl-&gt;dir == FTPLIB_WRITE)</span><br><span class="line">        wfd = &amp;fd;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        rfd = &amp;fd;</span><br><span class="line">    FD_ZERO(&amp;fd);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        FD_SET(ctl-&gt;handle,&amp;fd);</span><br><span class="line">        tv = ctl-&gt;idletime;</span><br><span class="line">        rv = select(ctl-&gt;handle+<span class="number">1</span>, rfd, wfd, <span class="literal">NULL</span>, &amp;tv);</span><br><span class="line">        <span class="keyword">if</span> (rv == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rv = <span class="number">0</span>;</span><br><span class="line">            <span class="built_in">strncpy</span>(ctl-&gt;ctrl-&gt;response, strerror(errno),</span><br><span class="line">                        <span class="keyword">sizeof</span>(ctl-&gt;ctrl-&gt;response));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (rv &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            rv = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> ((rv = ctl-&gt;idlecb(ctl, ctl-&gt;xfered, ctl-&gt;idlearg)));</span><br><span class="line">    <span class="keyword">return</span> rv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="net-read函数"><a href="#net-read函数" class="headerlink" title="net_read函数"></a>net_read函数</h4><p>这个函数简单，用了<code>read</code>函数读到了数据，就立马返回，但也要注意，你读10个字节，也不一定能读取10个字节，可能会比10个字节小，因为<code>read</code>总是在接收缓冲区有数据时立即返回，而不是等到给定的read buffer填满时返回。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">int net_read(int fd, char *buf, size_t len)</span><br><span class="line">&#123;</span><br><span class="line">    while ( 1 )</span><br><span class="line">    &#123;</span><br><span class="line">        int c = read(fd, buf, len);</span><br><span class="line">        if ( c == -1 )</span><br><span class="line">        &#123;</span><br><span class="line">            if ( errno != EINTR &amp;&amp; errno != EAGAIN )</span><br><span class="line">            return -1;</span><br><span class="line">        &#125;</span><br><span class="line">        else</span><br><span class="line">        &#123;</span><br><span class="line">            return c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://www.ibm.com/developerworks/cn/linux/l-cn-socketftp/index.html" target="_blank" rel="noopener">使用 Socket 通信实现 FTP 客户端程序</a></li>
<li><a href="https://www.cnblogs.com/wuchanming/p/3783650.html" target="_blank" rel="noopener">网络编程中的read，write函数</a></li>
</ul>
]]></content>
      <categories>
        <category>c</category>
      </categories>
      <tags>
        <tag>c</tag>
      </tags>
  </entry>
  <entry>
    <title>gRPC入门使用</title>
    <url>/2020/06/02/gRPC_learn/</url>
    <content><![CDATA[<h2 id="gRPC是什么"><a href="#gRPC是什么" class="headerlink" title="gRPC是什么"></a>gRPC是什么</h2><p><a href="(https://grpc.io/)">官网</a>如此写到</p>
<blockquote>
<p>A high-performance, open source universal RPC framework</p>
</blockquote>
<p>其实，gRPC是一个高性能的，通用的，面向服务端和移动端，基于 HTTP/2 设计的RPC框架。</p>
<a id="more"></a>


<h2 id="RPC框架是什么？"><a href="#RPC框架是什么？" class="headerlink" title="RPC框架是什么？"></a>RPC框架是什么？</h2><p>RPC 框架说白了就是让你可以像调用本地方法一样调用远程服务提供的方法，而不需要关心底层的通信细节。简单地说就让远程服务调用更加简单、透明。<br>RPC框架包含了客户端（Client）和服务端（Server）<br>常见的RPC框架有</p>
<ul>
<li>gRPC。谷歌出品</li>
<li>Thrift。Apache出品</li>
<li>Dubbo。阿里出品，也是一个微服务框架</li>
</ul>
<h2 id="gRPC的特性"><a href="#gRPC的特性" class="headerlink" title="gRPC的特性"></a>gRPC的特性</h2><p>看<a href="https://grpc.io/" target="_blank" rel="noopener">官方文档</a>的介绍，有以下4点特性：</p>
<ol>
<li>使用Protocal Buffers这个强大的结构数据序列化工具</li>
<li>gRPC可以跨语言使用</li>
<li>安装简单，扩展方便（用该框架每秒可达到百万个RPC）</li>
<li>基于HTTP2协议</li>
</ol>
<h2 id="gRPC使用流程"><a href="#gRPC使用流程" class="headerlink" title="gRPC使用流程"></a>gRPC使用流程</h2><ul>
<li>定义标准的proto文件</li>
<li>生成标准代码（用<code>protoc</code>工具）</li>
<li>服务端使用生成的代码提供服务</li>
<li>客户端使用生成的代码调用服务</li>
</ul>
<h2 id="Golang实践"><a href="#Golang实践" class="headerlink" title="Golang实践"></a>Golang实践</h2><h3 id="安装protoc"><a href="#安装protoc" class="headerlink" title="安装protoc"></a>安装protoc</h3><p>首先，我们需要安装<code>protoc</code>，这个工具是<code>Protocol Buffer</code>的编译器，把proto文件翻译成不同语言（Java，Go等）。<br>地址：<a href="https://github.com/protocolbuffers/protobuf/releases" target="_blank" rel="noopener">protobuf/releases</a><br>解压把bin目录下<strong>protoc</strong>文件放到/usr/local/bin目录下即可。</p>
<h3 id="安装-protoc-gen-go"><a href="#安装-protoc-gen-go" class="headerlink" title="安装 protoc-gen-go"></a>安装 protoc-gen-go</h3><p><code>protoc-gen-go</code>是Go的protoc编译插件，protobuf内置了许多高级语言的编译器，但没有Go的。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ protoc -h</span><br><span class="line">...</span><br><span class="line">--cpp_out=OUT_DIR           Generate C++ header and source.</span><br><span class="line">  --csharp_out=OUT_DIR        Generate C# source file.</span><br><span class="line">  --java_out=OUT_DIR          Generate Java source file.</span><br><span class="line">  --js_out=OUT_DIR            Generate JavaScript source.</span><br><span class="line">  --objc_out=OUT_DIR          Generate Objective C header and source.</span><br><span class="line">  --php_out=OUT_DIR           Generate PHP source file.</span><br><span class="line">  --python_out=OUT_DIR        Generate Python source file.</span><br><span class="line">  --ruby_out=OUT_DIR          Generate Ruby source file.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>我们借助<code>Go Modules</code>来安装，新建一个目录grpc-test，在目录下执行<code>go mod init grpc-test</code>创建一个Module<br>因为墙的原因，我们在<code>go get</code>之前要设置proxy（或者把<code>GOPROXY</code>设置到<code>.bashrc</code>文件中）</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ export GOPROXY=https://goproxy.cn</span><br></pre></td></tr></table></figure>

<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">go get -u github.com/golang/protobuf/protoc-gen-go</span><br></pre></td></tr></table></figure>

<p>执行完就可以在<code>$GOPATH</code>的bin目录下看到<strong>protoc-gen-go</strong>文件。</p>
<h3 id="定义服务"><a href="#定义服务" class="headerlink" title="定义服务"></a>定义服务</h3><p>在grpc-test目录下新建一个protos的目录，写入<strong>hello.proto</strong>文件</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">syntax = &quot;proto3&quot;;</span><br><span class="line"></span><br><span class="line">package hello;</span><br><span class="line">option go_package = &quot;hellopb&quot;;</span><br><span class="line"></span><br><span class="line">message helloRequest &#123;</span><br><span class="line">    string name = 1;</span><br><span class="line">    int64 age  = 2;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">message helloResponse &#123;</span><br><span class="line">    string greeting = 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">service helloService &#123;</span><br><span class="line">    rpc Hello(helloRequest) returns (helloResponse) &#123;&#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>helloService</code>就是给外部调用的服务<br>然后我们利用<code>protoc</code>工具把 <strong>.proto</strong> 文件翻译成需要语言的代码（这里是go）<br><code>gen.sh</code>文件： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#!/bin/bash</span><br><span class="line"></span><br><span class="line">protoDir=&quot;./protos&quot;</span><br><span class="line">outDir=&quot;./grpc&quot;</span><br><span class="line">protoc -I $&#123;protoDir&#125;/ $&#123;protoDir&#125;/*proto --go_out=plugins=grpc:$&#123;outDir&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>-I： 指定import路径，可以指定多个-I参数，编译时按顺序查找，不指定默认当前目录</li>
<li>–go_out：指定go语言的访问类</li>
<li>plugins：指定依赖的插件<br>这个bash会把生成的go代码写到hellopb目录下。</li>
</ul>
<h3 id="定义服务端"><a href="#定义服务端" class="headerlink" title="定义服务端"></a>定义服务端</h3><p>我们需要去实现<strong>hello.proto</strong>中的<code>helloService</code></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;google.golang.org/grpc&quot;</span><br><span class="line">	&quot;grpc-test/hellopb&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">	&quot;net&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">type server struct &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func (*server) Hello(ctx context.Context, request *hellopb.HelloRequest) (*hellopb.HelloResponse, error) &#123;</span><br><span class="line">	name := request.Name</span><br><span class="line">	response := &amp;hellopb.HelloResponse&#123;</span><br><span class="line">		Greeting: &quot;Hello &quot; + name,</span><br><span class="line">	&#125;</span><br><span class="line">	return response, nil</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	address := &quot;0.0.0.0:50051&quot;</span><br><span class="line">	lis, err := net.Listen(&quot;tcp&quot;, address)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatalf(&quot;Error %v&quot;, err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Printf(&quot;Server is listening on %v ...&quot;, address)</span><br><span class="line"></span><br><span class="line">	s := grpc.NewServer()</span><br><span class="line">	hellopb.RegisterHelloServiceServer(s, &amp;server&#123;&#125;)</span><br><span class="line"></span><br><span class="line">	s.Serve(lis)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="定义客户端"><a href="#定义客户端" class="headerlink" title="定义客户端"></a>定义客户端</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;context&quot;</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;grpc-test/hellopb&quot;</span><br><span class="line">	&quot;google.golang.org/grpc&quot;</span><br><span class="line">	&quot;log&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	fmt.Println(&quot;Hello client ...&quot;)</span><br><span class="line"></span><br><span class="line">	opts := grpc.WithInsecure()</span><br><span class="line">	cc, err := grpc.Dial(&quot;localhost:50051&quot;, opts)</span><br><span class="line">	if err != nil &#123;</span><br><span class="line">		log.Fatal(err)</span><br><span class="line">	&#125;</span><br><span class="line">	defer cc.Close()</span><br><span class="line"></span><br><span class="line">	client := hellopb.NewHelloServiceClient(cc)</span><br><span class="line">	request := &amp;hellopb.HelloRequest&#123;Name: &quot;Jeremy&quot;, Age: 18&#125;</span><br><span class="line"></span><br><span class="line">	resp, _ := client.Hello(context.Background(), request)</span><br><span class="line">	fmt.Printf(&quot;Receive response =&gt; [%v]&quot;, resp.Greeting)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://www.cnblogs.com/chenqionghe/p/12394845.html" target="_blank" rel="noopener">gRPC详细入门教程，Golang/Python/PHP多语言讲解</a></li>
</ul>
]]></content>
      <categories>
        <category>Go</category>
        <category>gRPC</category>
      </categories>
      <tags>
        <tag>rpc</tag>
        <tag>go</tag>
      </tags>
  </entry>
  <entry>
    <title>go并发之WaitGroup使用</title>
    <url>/2020/06/15/go_sync_WaitGroup/</url>
    <content><![CDATA[<h2 id="需求"><a href="#需求" class="headerlink" title="需求"></a>需求</h2><p>有时候我们会开启很多线程（go中是协程）去做一件事件，然后希望主线程等待这些线程都完成后才结束，一个简单的想法是，我在主线程sleep一段时间，譬如3s钟，但是明显这样的做法不科学，因为这些任务很有可能在200ms内就都完成了。如果你用过Java的话，那你很快就会想到<code>CountDownLatch</code>类，在Go中，也有类似的结构，就是本文要讨论的<code>WaitGroup</code>。</p>
<a id="more"></a>


<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><p>示例代码</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	learnWaitGroup()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func learnWaitGroup() &#123;</span><br><span class="line">	num := 10</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(num)</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; num; i++ &#123;</span><br><span class="line">		go func(idx int) &#123;</span><br><span class="line">			fmt.Printf(&quot;%d Doing something...\n&quot;, idx)</span><br><span class="line">			time.Sleep(time.Second)</span><br><span class="line">			wg.Done()</span><br><span class="line">		&#125;(i)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(&quot;All is done...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>WaitGroup</code> 对象内部有一个计数器，最初从0开始，它有三个方法：<code>Add()</code>, <code>Done()</code>, <code>Wait()</code> 用来控制计数器的数量。<code>Add(n)</code> 把计数器设置为n ，<code>Done()</code> 每次把计数器-1 ，<code>Wait()</code> 会阻塞代码的运行，直到计数器地值减为0。  </p>
<h2 id="注意问题"><a href="#注意问题" class="headerlink" title="注意问题"></a>注意问题</h2><p><code>WaitGroup</code>对象不是一个引用类型，所以在作为参数的时候，你应该要使用指针。在上面的示例提取一个任务函数</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line">	&quot;sync&quot;</span><br><span class="line">	&quot;time&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	learnWaitGroup()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func learnWaitGroup() &#123;</span><br><span class="line">	num := 10</span><br><span class="line">	wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">	wg.Add(num)</span><br><span class="line"></span><br><span class="line">	for i := 0; i &lt; num; i++ &#123;</span><br><span class="line">		go runTask(i, &amp;wg)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	wg.Wait()</span><br><span class="line">	fmt.Println(&quot;All is done...&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">func runTask(idx int, wg *sync.WaitGroup) &#123;</span><br><span class="line">	fmt.Printf(&quot;%d Doing something...\n&quot;, idx)</span><br><span class="line">	time.Sleep(time.Second)</span><br><span class="line">	wg.Done()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="Java类比"><a href="#Java类比" class="headerlink" title="Java类比"></a>Java类比</h2><p>Java中可以使用<code>CountDownLatch</code>类实现这个功能，它暴露出三个方法：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">// 调用此方法的线程会被阻塞，直到 CountDownLatch 的 count 为 0</span><br><span class="line">public void await() throws InterruptedException</span><br><span class="line"></span><br><span class="line">// 会将 count 减 1，直至为 0</span><br><span class="line">public void countDown()</span><br></pre></td></tr></table></figure>

<p><code>countDown()</code> 跟<code>WaitGroup</code>的<code>Done()</code>函数类似，我们还是很容易实现的</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">public class Main &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        try &#123;</span><br><span class="line">            testCountDownLatch();</span><br><span class="line">        &#125; catch (Exception ex) &#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    static class TaskThread extends Thread &#123;</span><br><span class="line">        </span><br><span class="line">        CountDownLatch latch;</span><br><span class="line">        </span><br><span class="line">        public TaskThread(CountDownLatch latch) &#123;</span><br><span class="line">            this.latch = latch;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        @Override</span><br><span class="line">        public void run() &#123;</span><br><span class="line">            try &#123;</span><br><span class="line">                Thread.sleep(1000);</span><br><span class="line">            &#125; catch (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125; finally &#123;</span><br><span class="line">                System.out.println(getName() + &quot; Task is Done&quot;);</span><br><span class="line">                latch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public static void testCountDownLatch() throws InterruptedException &#123;</span><br><span class="line">        final int threadNum = 10;</span><br><span class="line">        CountDownLatch latch = new CountDownLatch(threadNum);</span><br><span class="line">        for(int i = 0; i &lt; threadNum; i++) &#123;</span><br><span class="line">            TaskThread task = new TaskThread(latch);</span><br><span class="line">            task.start();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        System.out.println(&quot;Task Start!&quot;);</span><br><span class="line">        latch.await();</span><br><span class="line">        System.out.println(&quot;All Task is Done!&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>Go</category>
      </categories>
      <tags>
        <tag>Go</tag>
      </tags>
  </entry>
  <entry>
    <title>gdb调试简单使用</title>
    <url>/2020/07/02/gdb_use/</url>
    <content><![CDATA[<h2 id="gdb"><a href="#gdb" class="headerlink" title="gdb"></a>gdb</h2><p>gdb 是 UNIX 及 UNIX-like 下的调试工具，在 Linux 下一般都直接在命令行中用 gdb 来调试程序，相比 Windows 上的集成开发环境 IDE 提供的图形界面调试，一开始使用 gdb 调试可能会让你感觉很难适应，但是只要熟悉了 gdb 调试的常用命令，调试出程序会很有成就感，一方面因为这些命令就类似图形界面调试按钮背后的逻辑，另一方面用命令行来调试程序，逼格瞬间就上了一个档次，这次就跟大家分享 gdb 调试的基本技术和 15 个常用调试命令。</p>
<a id="more"></a>

<h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h3 id="gdb快捷键说明"><a href="#gdb快捷键说明" class="headerlink" title="gdb快捷键说明"></a>gdb快捷键说明</h3> <figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"> 一些快捷命令</span><br><span class="line"></span><br><span class="line">l – list</span><br><span class="line">p – print print &#123;variable&#125;  //打印变量</span><br><span class="line">c – continue           //继续执行</span><br><span class="line">s – step          </span><br><span class="line">b - break break line_number/break [file_name]:line_number/break [file_name]:func_name       //设置断点</span><br><span class="line">r - run                    //执行文件</span><br></pre></td></tr></table></figure>

<h3 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h3><h4 id="编译可以调试的程序"><a href="#编译可以调试的程序" class="headerlink" title="编译可以调试的程序"></a>编译可以调试的程序</h4><p>这是本次要调试的 hello.c 程序，非常简单：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line"></span><br><span class="line">int add(int x, int y) &#123;</span><br><span class="line">	return x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	int a = 1;</span><br><span class="line">	int b = 2;</span><br><span class="line">	printf(&quot;a = %d\n&quot;, a);</span><br><span class="line">	printf(&quot;b = %d\n&quot;, b);</span><br><span class="line"></span><br><span class="line">	int c = add(a, b);</span><br><span class="line">	printf(&quot;%d + %d = %d\n&quot;, a, b, c);</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>我们平常使用 gcc 编译的程序如果不加 [-g] 选项：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gcc hello.c -o hello</span><br></pre></td></tr></table></figure>

<p>gdb 会提示该可执行文件没有调试符号，不能调试：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello</span><br><span class="line">...</span><br><span class="line">Reading symbols from hello...(no debugging symbols found)...done.</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>如果需要让程序可以调试，就*<em>必须在编译的时候加上 *</em> <code>[-g]</code> 参数</p>
<h4 id="载入要调试的程序"><a href="#载入要调试的程序" class="headerlink" title="载入要调试的程序"></a>载入要调试的程序</h4><p>使用如下的命令来载入可执行文件 hello 到 gdb 中：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb hello</span><br></pre></td></tr></table></figure>

<p>载入成功，gdb 会打印一段提示信息，并且命令行前缀变为 (gdb)，下面是我的 Ubuntu 输出的信息：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.  Type &quot;show copying&quot;</span><br><span class="line">and &quot;show warranty&quot; for details.</span><br><span class="line">This GDB was configured as &quot;x86_64-linux-gnu&quot;.</span><br><span class="line">Type &quot;show configuration&quot; for configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">&lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line">For help, type &quot;help&quot;.</span><br><span class="line">Type &quot;apropos word&quot; to search for commands related to &quot;word&quot;...</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>注，<strong>按 q 退出 gdb</strong>  </p>
<p>方法二 - 使用 gdb 提供的 file 命令<br>第二种方法是在 gdb 环境中使用 file 命令，我们需要先进入 gdb 环境下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb</span><br></pre></td></tr></table></figure>

<p>使用 file hello 载入待调试程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line">(gdb) file hello</span><br><span class="line">Reading symbols from hello...done.</span><br><span class="line">(gdb) q</span><br></pre></td></tr></table></figure>

<h4 id="查看调试程序"><a href="#查看调试程序" class="headerlink" title="查看调试程序"></a>查看调试程序</h4><p>在 gdb 下查看调试程序使用命令 <code>list</code> 或简写 <code>l</code>，「回车」列出后面程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) list</span><br><span class="line">1       #include &lt;stdio.h&gt;</span><br><span class="line">2</span><br><span class="line">3       int add(int x, int y) &#123;</span><br><span class="line">4               return x + y;</span><br><span class="line">5       &#125;</span><br><span class="line">6</span><br><span class="line">7       int main() &#123;</span><br><span class="line">8               int a = 1;</span><br><span class="line">9               int b = 2;</span><br><span class="line">10              printf(&quot;a = %d\n&quot;, a);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<h4 id="添加断点"><a href="#添加断点" class="headerlink" title="添加断点"></a>添加断点</h4><p>在 gdb 下添加断点使用命令 <code>break</code> 或简写 <code>b</code>，有下面几个常见用法（这里统一用 <code>b</code>）：</p>
<ol>
<li>b function_name</li>
<li>b row_num</li>
<li>b file_name:row_num</li>
<li>b row_num if condition</li>
</ol>
<p>比如我们以第一个为例，在 <code>main</code> 函数上添加断点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x666: file hello.c, line 8.</span><br></pre></td></tr></table></figure>

<p>打印的信息告诉我们在 hello.c 文件的第 8 行，地址 0x666 处添加了一个断点，那如何查看断点呢？  </p>
<h4 id="查看断点"><a href="#查看断点" class="headerlink" title="查看断点"></a>查看断点</h4><p>在 gdb 下查看断点使用命令 <code>info break</code> 或简写 <code>i b</code>，比如查看刚才打的断点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) i b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000000000666 in main at hello.c:8</span><br></pre></td></tr></table></figure>

<h4 id="删除断点"><a href="#删除断点" class="headerlink" title="删除断点"></a>删除断点</h4><p>在 gdb 下删除断点使用命令 delete 断点 Num 或简写 d Num，比如删除刚才的 Num = 1 的断点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) d 1</span><br><span class="line">(gdb) i b</span><br><span class="line">No breakpoints or watchpoints.</span><br></pre></td></tr></table></figure>

<p>删除后再次查看断点，提示当前没有断点，说明删除成功啦，下面来运行程序试试。</p>
<h4 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h4><p>在 gdb 下使用命令 run 或简写 r 来运行当前载入的程序：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/salamander/文档/test/hello </span><br><span class="line">a = 1</span><br><span class="line">b = 2</span><br><span class="line">1 + 2 = 3</span><br><span class="line">[Inferior 1 (process 16249) exited normally]</span><br></pre></td></tr></table></figure>

<p>我这次没有添加断点，程序全速运行，然后正常退出了。</p>
<h4 id="单步执行下一步"><a href="#单步执行下一步" class="headerlink" title="单步执行下一步"></a>单步执行下一步</h4><p>在 gdb 下使用命令 <code>next</code> 或简写 <code>n</code> 来单步执行下一步，假设我们在 <code>main</code> 打了断点：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x555555554666: file hello.c, line 8.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/salamander/文档/test/hello </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at hello.c:8</span><br><span class="line">8               int a = 1;</span><br><span class="line">(gdb) n</span><br><span class="line">9               int b = 2;</span><br></pre></td></tr></table></figure>

<p>可以看到当前停在 int a = 1; 这一行，按 n 执行了下一句代码 <code>int b = 2;</code></p>
<h4 id="打印变量"><a href="#打印变量" class="headerlink" title="打印变量"></a>打印变量</h4><p>在 gdb 中使用命令 print var 或简写 p var 来打印一个变量或者函数的返回值，在上述gdb中打印 a 的值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) b main</span><br><span class="line">Breakpoint 1 at 0x555555554666: file hello.c, line 8.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/salamander/文档/test/hello </span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at hello.c:8</span><br><span class="line">8               int a = 1;</span><br><span class="line">(gdb) n</span><br><span class="line">9               int b = 2;</span><br><span class="line">(gdb) n</span><br><span class="line">10              printf(&quot;a = %d\n&quot;, a);</span><br><span class="line">(gdb) p a</span><br><span class="line">$1 = 1</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://dlonng.com/posts/gdb" target="_blank" rel="noopener">Linux 高级编程 - 15 个 gdb 调试基础命令</a></li>
</ul>
]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>gdb</tag>
      </tags>
  </entry>
  <entry>
    <title>调试PHP源码</title>
    <url>/2020/07/03/Debug_PHP_source_code/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/07/05/U91xmt.png" alt></p>
<h2 id="缘由"><a href="#缘由" class="headerlink" title="缘由"></a>缘由</h2><p>有时候，我们想看看一个变量底层对应底层的数据结构或者PHP脚本是如何执行的，gdb就是这样一个好工具，之前有篇<a href="/2020/07/02/gdb_use/">文章写过</a>如何简单使用gdb。  </p>
<p>本文环境：</p>
<ul>
<li>PHP版本：PHP 7.1.16 (cli) (built: Apr  8 2020 11:56:59) ( ZTS )</li>
<li>OS：Ubuntu 18.04.4 LTS</li>
<li>gdb: GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</li>
</ul>
<a id="more"></a>


<h2 id="编译"><a href="#编译" class="headerlink" title="编译"></a>编译</h2><p>你可以从<a href="https://www.php.net/downloads" target="_blank" rel="noopener">PHP官网下载PHP源码的压缩包</a>，者是从git.php.net（或者是github的镜像）的git库clone最新的代码库，然后切换到对应的PHP版本的分支，本文使用的是PHP7.1，你可以使用下面的命令完成这些工作：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">git clone http://git.php.net/repository/php-src.git</span><br><span class="line">cd php-src</span><br><span class="line">git checkout PHP-7.1</span><br></pre></td></tr></table></figure>

<p>如果你是从git库中clone的代码，那么你先要运行下buildconf命令：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~/php-src&gt; ./buildconf</span><br></pre></td></tr></table></figure>

<p>这个命令会生成configure脚本，<strong>从官网下载的源码包中会直接包含这个脚本</strong>，如果你执行<code>buildconf</code>出错，那么很可能是因为你的系统中没有<code>autoconf</code>这个工具，你可以使用包安装工具进行安装。<br>如果你已经成功生成了configure脚本文件（或者是使用已包含这个脚本文件的源码包），那就可以开始编译了。为了调式PHP源码，我们的编译会disable所有的扩展（除了一些必须包含的外，这些PHP的编译脚本会自行处理），我们使用下面的命令来完成编译安装的工作，假设安装的路径为$HOME/myphp：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">~/php-src&gt; ./configure --disable-all --enable-debug --prefix=$HOME/myphp</span><br><span class="line">~/php-src&gt; make -jN</span><br><span class="line">~/php-src&gt; make install</span><br></pre></td></tr></table></figure>

<p>注意这里的prefix的参数必须为绝对路径，所以你不能写成~/myphp，另外我们这次编译只是为了调式，所以建议一定要设置prefix参数，要不然PHP会被安装到默认路径中，大多数时候是/usr/local/php中，这可能会造成一些没必要的污染。另外我们使用了两个选项，一个是–disable-all，这个表示禁止安装所有扩展（除了一个必须安装的），另外一个就是–enable-debug，这个选项表示以debug模式编译PHP源码，<strong>相当于gcc的-g选项</strong>，它会把调试信息编译进最终的二进制程序中。  </p>
<p>上面的命令make -jN，N表示你的CPU数量（或者是CPU核心的数量），设置了这个参数后就可以使用多个CPU进行并行编译，这可以提高编译效率。</p>
<h2 id="调试PHP"><a href="#调试PHP" class="headerlink" title="调试PHP"></a>调试PHP</h2><p>我们调试一段简单的PHP代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">$a = 10;</span><br><span class="line">$b = 42;</span><br><span class="line"></span><br><span class="line">echo $b;</span><br></pre></td></tr></table></figure>

<p>我们想看下<code>$a</code>对应的底层变量结构，那我们应该在哪个函数上叫断点呢？通过查阅资料（如《PHP7内核分析》）我们发现，ZendVM的执行器就是一个white循环，在这个循环中依次调用<code>opline</code>指令的handler，然后根据handler的返回决定下一步的动作。执行调度器为<strong>zend_execute_ex</strong>，这是函数指针，默认为<code>execute_ex</code>，我们看下这个函数的代码：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">//删除了预处理语句</span><br><span class="line">ZEND_API void execute_ex(zend_execute_data *ex)</span><br><span class="line">&#123;</span><br><span class="line">    DCL_OPLINE</span><br><span class="line"></span><br><span class="line">    const zend_op *orig_opline = opline;</span><br><span class="line">    zend_execute_data *orig_execute_data = execute_data; /* execute_data是一个全局变量 */</span><br><span class="line">    execute_data = ex; </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    LOAD_OPLINE();</span><br><span class="line"></span><br><span class="line">    while (1) &#123;</span><br><span class="line">        ((opcode_handler_t)OPLINE-&gt;handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU); //执行OPCode对应的C函数，OPLINE是一个全局变量</span><br><span class="line">        if (UNEXPECTED(!OPLINE)) &#123; //当前OPArray执行完</span><br><span class="line">            execute_data = orig_execute_data;</span><br><span class="line">            opline = orig_opline;</span><br><span class="line">            return;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    zend_error_noreturn(E_CORE_ERROR, &quot;Arrived at end of main loop which shouldn&apos;t happen&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们可以在给<code>execute_ex</code>函数打断点。  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">gdb ~/myphp/bin/php</span><br><span class="line"></span><br><span class="line">(gdb) r index.php</span><br><span class="line">Starting program: /home/salamander/myphp/bin/php index.php</span><br><span class="line"></span><br><span class="line">Breakpoint 1, execute_ex (ex=0x7ffff7014030) at /home/salamander/php-7.1.16/Zend/zend_vm_execute.h:411</span><br><span class="line">411             const zend_op *orig_opline = opline;</span><br><span class="line">(gdb) n</span><br><span class="line">414             zend_execute_data *orig_execute_data = execute_data;</span><br><span class="line">(gdb) n</span><br><span class="line">415             execute_data = ex;</span><br><span class="line">(gdb) n</span><br><span class="line">421             LOAD_OPLINE();</span><br><span class="line">(gdb) n</span><br><span class="line">422             ZEND_VM_LOOP_INTERRUPT_CHECK();</span><br><span class="line">(gdb) n</span><br><span class="line">429                     ((opcode_handler_t)OPLINE-&gt;handler)(ZEND_OPCODE_HANDLER_ARGS_PASSTHRU);</span><br></pre></td></tr></table></figure>

<p>现在就要调用<code>opline</code>指令的handler，我们应该键入<code>s</code>，跳到对应函数内部去： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) s</span><br><span class="line">ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER () at /home/salamander/php-7.1.16/Zend/zend_vm_execute.h:39506</span><br><span class="line">39506           SAVE_OPLINE();</span><br><span class="line">(gdb) n</span><br><span class="line">39507           value = EX_CONSTANT(opline-&gt;op2);</span><br><span class="line">(gdb) n</span><br><span class="line">39508           variable_ptr = _get_zval_ptr_cv_undef_BP_VAR_W(execute_data, opline-&gt;op1.var);</span><br><span class="line">(gdb) n</span><br><span class="line">39516                   value = zend_assign_to_variable(variable_ptr, value, IS_CONST);</span><br><span class="line">(gdb) p value</span><br><span class="line">$1 = (zval *) 0x7ffff707b460</span><br><span class="line">(gdb) p *$1</span><br><span class="line">$3 = &#123;value = &#123;lval = 10, dval = 4.9406564584124654e-323, counted = 0xa, str = 0xa, arr = 0xa, obj = 0xa, res = 0xa, ref = 0xa, ast = 0xa, zv = 0xa, </span><br><span class="line">    ptr = 0xa, ce = 0xa, func = 0xa, ww = &#123;w1 = 10, w2 = 0&#125;&#125;, u1 = &#123;v = &#123;type = 4 &apos;\004&apos;, type_flags = 0 &apos;\000&apos;, const_flags = 0 &apos;\000&apos;, </span><br><span class="line">      reserved = 0 &apos;\000&apos;&#125;, type_info = 4&#125;, u2 = &#123;next = 4294967295, cache_slot = 4294967295, lineno = 4294967295, num_args = 4294967295, </span><br><span class="line">    fe_pos = 4294967295, fe_iter_idx = 4294967295, access_flags = 4294967295, property_guard = 4294967295, extra = 4294967295&#125;&#125;</span><br></pre></td></tr></table></figure>

<p>我们第一行PHP代码是<code>$a = 10;</code>，这是一条赋值语句,<code>ZEND_ASSIGN_SPEC_CV_CONST_RETVAL_UNUSED_HANDLER</code>是把一个常量赋值给一个变量，<code>EX_CONSTANT(opline-&gt;op2)</code>是获取常量的值，<code>$a</code>为CV变量，分配在zend_execute_data动态变量区，通过<code>_get_zval_ptr_cv_undef_BP_VAR_W</code>取到这个变量的地址，剩下的好理解了，就是把变量值赋值给CV变量。<br><code>value</code>就是我们的变量值，<code>$a</code>对应的底层变量就是它。<br>回忆一下PHP7变量的数据结构，是一个叫<code>zval</code>的结构体，<code>zend_value</code>保存具体的变量值：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">typedef union _zend_value &#123;</span><br><span class="line">	zend_long         lval;				/* long value */</span><br><span class="line">	double            dval;				/* double value */</span><br><span class="line">	zend_refcounted  *counted;</span><br><span class="line">	zend_string      *str;</span><br><span class="line">	zend_array       *arr;</span><br><span class="line">	zend_object      *obj;</span><br><span class="line">	zend_resource    *res;</span><br><span class="line">	zend_reference   *ref;</span><br><span class="line">	zend_ast_ref     *ast;</span><br><span class="line">	zval             *zv;</span><br><span class="line">	void             *ptr;</span><br><span class="line">	zend_class_entry *ce;</span><br><span class="line">	zend_function    *func;</span><br><span class="line">	struct &#123;</span><br><span class="line">		uint32_t w1;</span><br><span class="line">		uint32_t w2;</span><br><span class="line">	&#125; ww;</span><br><span class="line">&#125; zend_value;</span><br><span class="line"></span><br><span class="line">struct _zval_struct &#123;</span><br><span class="line">	zend_value        value;			/* value */</span><br><span class="line">	union &#123;</span><br><span class="line">		struct &#123;</span><br><span class="line">			ZEND_ENDIAN_LOHI_4(</span><br><span class="line">				zend_uchar    type,			/* 变量类型 */</span><br><span class="line">				zend_uchar    type_flags,</span><br><span class="line">				zend_uchar    const_flags,</span><br><span class="line">				zend_uchar    reserved)	    /* call info for EX(This) */</span><br><span class="line">		&#125; v;</span><br><span class="line">		uint32_t type_info;</span><br><span class="line">	&#125; u1;</span><br><span class="line">	union &#123;</span><br><span class="line">		uint32_t     next;                 /* hash collision chain */</span><br><span class="line">		uint32_t     cache_slot;           /* literal cache slot */</span><br><span class="line">		uint32_t     lineno;               /* line number (for ast nodes) */</span><br><span class="line">		uint32_t     num_args;             /* arguments number for EX(This) */</span><br><span class="line">		uint32_t     fe_pos;               /* foreach position */</span><br><span class="line">		uint32_t     fe_iter_idx;          /* foreach iterator index */</span><br><span class="line">		uint32_t     access_flags;         /* class constant access flags */</span><br><span class="line">		uint32_t     property_guard;       /* single property guard */</span><br><span class="line">		uint32_t     extra;                /* not further specified */</span><br><span class="line">	&#125; u2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">#define IS_UNDEF                                        0</span><br><span class="line">#define IS_NULL                                         1</span><br><span class="line">#define IS_FALSE                                        2</span><br><span class="line">#define IS_TRUE                                         3</span><br><span class="line">#define IS_LONG                                         4</span><br><span class="line">#define IS_DOUBLE                                       5</span><br><span class="line">#define IS_STRING                                       6</span><br><span class="line">#define IS_ARRAY                                        7</span><br><span class="line">#define IS_OBJECT                                       8</span><br><span class="line">#define IS_RESOURCE                                     9</span><br><span class="line">#define IS_REFERENCE                                    10</span><br><span class="line"></span><br><span class="line">/* constant expressions */</span><br><span class="line">#define IS_CONSTANT                                     11</span><br><span class="line">#define IS_CONSTANT_AST                                 12</span><br></pre></td></tr></table></figure>

<p>我们打印出来的底层变量，<code>lval</code>是10，<code>u1</code>里的<code>type</code>是4，也正好是<code>IS_LONG</code>，别的字段的值大家也可以分析看看。</p>
<p>参考：</p>
<ul>
<li><a href="http://yangxikun.github.io/php/2016/11/04/php-7-func-call.html" target="_blank" rel="noopener">PHP 7 中函数调用的实现</a></li>
</ul>
]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title>ES6中的class</title>
    <url>/2020/08/29/ES6_class/</url>
    <content><![CDATA[<p><img src="https://s1.ax1x.com/2020/08/30/dbt2p6.png" alt></p>
<h2 id="ES6"><a href="#ES6" class="headerlink" title="ES6"></a>ES6</h2><p>ECMAScript 2015或ES2015是对JavaScript编程语言的重大更新。这是自2009年对ES5进行标准化以来对语言的首次重大更新，ES6加入很多有用的特性。因此，ES2015通常被称为ES6。</p>
<p>本文环境：</p>
<ul>
<li>NodeJs版本：v12.13.0</li>
<li>OS：Ubuntu 18.04.4 LTS</li>
</ul>
<a id="more"></a>


<h2 id="class语法糖"><a href="#class语法糖" class="headerlink" title="class语法糖"></a>class语法糖</h2><p>首先我们先来看一下关于 ES6 中的类</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Persion</span> </span>&#123;</span><br><span class="line">    say() &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'hello~'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面这段代码是 ES6 中定义一个类的写法，其实只是一个语法糖，而实际上当我们给一个类添加一个属性的时候，会调用到 <code>Object.defineProperty</code> 这个方法，它会接受三个参数：target 、name 和 descriptor ，所以上面的代码实际上在执行时是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Persion</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(Persion.prototype, <span class="string">"say"</span>, &#123;</span><br><span class="line">    value: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">"hello ~"</span>); &#125;,</span><br><span class="line">    enumerable: <span class="literal">false</span>,</span><br><span class="line">    configurable: <span class="literal">true</span>,</span><br><span class="line">    writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<h2 id="ES6中extends"><a href="#ES6中extends" class="headerlink" title="ES6中extends"></a>ES6中extends</h2><p>ES6中可以很方便地用<code>extends</code>的实现继承：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x = x;</span><br><span class="line">        <span class="keyword">this</span>.y = y;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    move(x, y) &#123;</span><br><span class="line">        <span class="keyword">this</span>.x += x;</span><br><span class="line">        <span class="keyword">this</span>.y += y;</span><br><span class="line">        <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rectangle</span> <span class="keyword">extends</span> <span class="title">Shape</span> </span>&#123;</span><br><span class="line">    <span class="keyword">constructor</span>() &#123;</span><br><span class="line">        <span class="keyword">super</span>();  <span class="comment">// ES6 要求，子类的构造函数必须执行一次 super 函数，否则会报错。</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>要用ES5实现继承，就是用利用<strong>原型链</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Shape - 父类(superclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Shape</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.y = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 父类的方法</span></span><br><span class="line">Shape.prototype.move = <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x += x;</span><br><span class="line">  <span class="keyword">this</span>.y += y;</span><br><span class="line">  <span class="built_in">console</span>.info(<span class="string">'Shape moved.'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Rectangle - 子类(subclass)</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  Shape.call(<span class="keyword">this</span>); <span class="comment">// call super constructor.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 子类续承父类</span></span><br><span class="line">Rectangle.prototype = <span class="built_in">Object</span>.create(Shape.prototype);</span><br><span class="line">Rectangle.prototype.constructor = Rectangle;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> rect = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is rect an instance of Rectangle?'</span>,</span><br><span class="line">  rect <span class="keyword">instanceof</span> Rectangle); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'Is rect an instance of Shape?'</span>,</span><br><span class="line">  rect <span class="keyword">instanceof</span> Shape); <span class="comment">// true</span></span><br><span class="line">rect.move(<span class="number">1</span>, <span class="number">1</span>); <span class="comment">// Outputs, 'Shape moved.'</span></span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/create" target="_blank" rel="noopener">MDN Object create</a></li>
</ul>
]]></content>
      <categories>
        <category>JavaScript</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>class</tag>
      </tags>
  </entry>
  <entry>
    <title>Puppeteer使用例子</title>
    <url>/2021/03/05/puppeteer%E4%BD%BF%E7%94%A8%E4%BE%8B%E5%AD%90/</url>
    <content><![CDATA[<p><img src="https://s3.ax1x.com/2021/03/05/6eGwVJ.png" alt="Puppeteer"><br>这篇文章很简单呢，就是记录一下用<strong>Puppeteer</strong>的一些snippet。</p>
<a id="more"></a>


<h2 id="访问网站后截图"><a href="#访问网站后截图" class="headerlink" title="访问网站后截图"></a>访问网站后截图</h2><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const puppeteer = require(&apos;puppeteer&apos;);</span><br><span class="line">const url = &apos;https://segmentfault.com&apos;;</span><br><span class="line"></span><br><span class="line">(async() =&gt; &#123;</span><br><span class="line">    const browser = await puppeteer.launch(&#123;</span><br><span class="line">        headless: true,</span><br><span class="line">        args: [&quot;--no-sandbox&quot;, &quot;--single-process&quot;],</span><br><span class="line">    &#125;);</span><br><span class="line">    const page = await browser.newPage();</span><br><span class="line">    await page.setViewport(&#123; width: 1920, height: 1080 &#125;);</span><br><span class="line">    // ‘networkidle2’ means that there are no more than 2 active requests open. </span><br><span class="line">    // This is a good setting because for some websites (e.g. websites using websockets) there will always be connections open</span><br><span class="line">    await page.goto(url, &#123;</span><br><span class="line">        waitUntil: &apos;networkidle2&apos;,</span><br><span class="line">        timeout: 1000 * 60 * 5, // 毫秒 超时参数需要加上，有时候网络不好，会导致等着</span><br><span class="line">    &#125;);</span><br><span class="line">    await page.screenshot(&#123;path: &apos;./data/website.png&apos;, type: &apos;png&apos;&#125;);</span><br><span class="line">    page.close();</span><br><span class="line">    browser.close();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>]]></content>
      <tags>
        <tag>puppeteer</tag>
        <tag>Nodejs</tag>
      </tags>
  </entry>
  <entry>
    <title>RabbitMQ四五事之死信队列</title>
    <url>/2021/03/20/RabbitMQ_DLX/</url>
    <content><![CDATA[<img src="/images/RabbitMQ-Logo.png" width="800px">  


<h2 id="业务需求"><a href="#业务需求" class="headerlink" title="业务需求"></a>业务需求</h2><p>有时候我们需要某些任务定时执行，譬如取消订单，5分钟没支付，这个订单就被取消。简单实现的话，我们可以使用<code>Redis</code>或Linux的<strong>crontab</strong>来实现，而对于RabbitMQ，我们则可以用它的<code>死信队列</code>来实现定时任务。</p>
<a id="more"></a>


<h2 id="DLX"><a href="#DLX" class="headerlink" title="DLX"></a>DLX</h2><p>RabbitMQ 中有一种交换器叫 DLX，全称为 <code>Dead-Letter-Exchange</code>，可以称之为死信交换器。当消息在一个队列中变成死信（dead message）之后，它会被重新发送到另外一个交换器中，这个交换器就是 DLX，绑定在 DLX 上的队列就称之为死信队列。<br>消息变成死信一般是以下几种情况：</p>
<ul>
<li>消息被拒绝，并且设置 requeue 参数为 false</li>
<li>消息过期</li>
<li>队列达到最大长度</li>
</ul>
<p>DLX其实就是一个普通的交换器，要使用它也很简单，就是在声明某个队列的时候设置其 <code>deadLetterExchange</code> 和 <code>deadLetterRoutingKey</code> 参数，<code>deadLetterRoutingKey</code> 参数可选，表示为 DLX 指定的路由键，如果没有特殊指定，则使用原队列的路由键。这样设置后，这个队列的消息一过期，<code>RabbitMQ</code> 就会自动地将这个消息重新发布到设置的 DLX 上去，进而被路由到另一个队列，即死信队列。  </p>
<h2 id="简单例子"><a href="#简单例子" class="headerlink" title="简单例子"></a>简单例子</h2><p>用之前文章<a href="https://segmentfault.com/a/1190000018685360" target="_blank" rel="noopener">RabbitMQ二三事</a>快速启动RabbitMQ的服务，再把<a href="https://segmentfault.com/a/1190000019227064" target="_blank" rel="noopener">RabbitMQ三四事</a>的代码改造下。<br><strong>producer.js</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config &#x3D; require(&quot;.&#x2F;config&quot;);</span><br><span class="line">const amqp &#x3D; require(&#39;amqplib&#39;);</span><br><span class="line"></span><br><span class="line">async function getMQConnection() &#123;</span><br><span class="line">    return await amqp.connect(&#123;</span><br><span class="line">        protocol: &#39;amqp&#39;,</span><br><span class="line">        hostname: config.host,</span><br><span class="line">        port: config.port,</span><br><span class="line">        username: config.user,</span><br><span class="line">        password: config.pass,</span><br><span class="line">        locale: &#39;en_US&#39;,</span><br><span class="line">        frameMax: 0,</span><br><span class="line">        heartbeat: 5, &#x2F;&#x2F; 心跳</span><br><span class="line">        vhost: config.vhost,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function run(rmqConn, msgObj) &#123;</span><br><span class="line">    const noramlQueue &#x3D; &#39;noramlQu&#39;;</span><br><span class="line">    const noramlExchange &#x3D; &#39;noramlEx&#39;;</span><br><span class="line">    const exchangeDLX &#x3D; &#39;testExDLX&#39;;</span><br><span class="line">    const queueDLX &#x3D; &#39;testQueueDLX&#39;;</span><br><span class="line">    const routingKeyDLX &#x3D; &#39;testRoutingKeyDLX&#39;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        const channel &#x3D; await rmqConn.createChannel();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 声明死信交换器和队列，就跟普通的一样</span><br><span class="line">        await channel.assertExchange(exchangeDLX, &#39;direct&#39;, &#123; durable: true, autoDelete: false &#125;);</span><br><span class="line">        await channel.assertQueue(queueDLX, &#123;durable: true, autoDelete: false, &#125;);</span><br><span class="line">        await channel.bindQueue(queueDLX, exchangeDLX, routingKeyDLX);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 普通交换器和队列</span><br><span class="line">        await channel.assertExchange(noramlExchange, &#39;direct&#39;, &#123; durable: true, autoDelete: false &#125;)</span><br><span class="line">        await channel.assertQueue(noramlQueue, &#123;durable: true, autoDelete: false,</span><br><span class="line">            deadLetterExchange: exchangeDLX,</span><br><span class="line">            deadLetterRoutingKey: routingKeyDLX,</span><br><span class="line">        &#125;);  &#x2F;&#x2F; 队列设置DLX</span><br><span class="line">        await channel.bindQueue(noramlQueue, noramlExchange, noramlQueue);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发送消息</span><br><span class="line">        await channel.publish(noramlExchange, noramlQueue, Buffer.from(msgObj.content), &#123;</span><br><span class="line">            expiration: msgObj.expiration, &#x2F;&#x2F; 过期时间，ms</span><br><span class="line">            persistent: true, </span><br><span class="line">            mandatory: true,</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&#39;send message successfully.&#39;)</span><br><span class="line">        await channel.close();</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        console.log(&#39;send message failed:&#39; + err.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function testSend() &#123;</span><br><span class="line">    const conn &#x3D; await getMQConnection()</span><br><span class="line">    await run(conn, &#123;</span><br><span class="line">        content: (new Date()).toLocaleString(),</span><br><span class="line">        expiration: &#39;3000&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">    await conn.close()</span><br><span class="line">&#125;</span><br><span class="line">testSend();</span><br></pre></td></tr></table></figure>
<p><strong>consumer.js</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config &#x3D; require(&quot;.&#x2F;config&quot;);</span><br><span class="line">const amqp &#x3D; require(&#39;amqplib&#39;);</span><br><span class="line"></span><br><span class="line">async function getMQConnection() &#123;</span><br><span class="line">    return await amqp.connect(&#123;</span><br><span class="line">        protocol: &#39;amqp&#39;,</span><br><span class="line">        hostname: config.host,</span><br><span class="line">        port: config.port,</span><br><span class="line">        username: config.user,</span><br><span class="line">        password: config.pass,</span><br><span class="line">        locale: &#39;en_US&#39;,</span><br><span class="line">        frameMax: 0,</span><br><span class="line">        heartbeat: 5, &#x2F;&#x2F; 心跳</span><br><span class="line">        vhost: config.vhost,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function run(rmqConn) &#123;</span><br><span class="line">    const noramlQueue &#x3D; &#39;noramlQu&#39;;</span><br><span class="line">    const noramlExchange &#x3D; &#39;noramlEx&#39;;</span><br><span class="line">    const exchangeDLX &#x3D; &#39;testExDLX&#39;;</span><br><span class="line">    const queueDLX &#x3D; &#39;testQueueDLX&#39;;</span><br><span class="line">    const routingKeyDLX &#x3D; &#39;testRoutingKeyDLX&#39;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        const channel &#x3D; await rmqConn.createChannel();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 声明死信交换器和队列，就跟普通的一样</span><br><span class="line">        await channel.assertExchange(exchangeDLX, &#39;direct&#39;, &#123; durable: true, autoDelete: false &#125;);</span><br><span class="line">        await channel.assertQueue(queueDLX, &#123;durable: true, autoDelete: false, &#125;);</span><br><span class="line">        await channel.bindQueue(queueDLX, exchangeDLX, routingKeyDLX);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理死信队列消息</span><br><span class="line">        await channel.consume(queueDLX, msg &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;[$&#123;(new Date()).toLocaleString()&#125;] consumer msg：&#96;, msg.content.toString());</span><br><span class="line">        &#125;, &#123; noAck: true &#125;);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        console.log(&#39;consume message failed:&#39; + err.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function testConsume() &#123;</span><br><span class="line">    const conn &#x3D; await getMQConnection();</span><br><span class="line">    console.log(&#39;begin consuming messages...&#39;);</span><br><span class="line">    await run(conn);</span><br><span class="line"></span><br><span class="line">    process.on(&#39;SIGINT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;stop consumer.&#39;)</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line">testConsume();</span><br></pre></td></tr></table></figure>
<p><strong>config.js</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">    host: &#39;127.0.0.1&#39;,</span><br><span class="line">    port: 5672,</span><br><span class="line">    user: &#39;test&#39;,</span><br><span class="line">    pass: &#39;************&#39;,</span><br><span class="line">    vhost: &#39;&#x2F;&#39;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>上面的代码，我们让消息3s后过期，先启动<strong>消费者</strong>，再启动生产者，我们可以看到消息3s后过期:   </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node consumer.js </span><br><span class="line">begin consuming messages...</span><br><span class="line">[2021&#x2F;3&#x2F;20 下午3:22:29] consumer msg： 2021&#x2F;3&#x2F;20 下午3:22:26</span><br></pre></td></tr></table></figure>

<h2 id="死信队列问题"><a href="#死信队列问题" class="headerlink" title="死信队列问题"></a>死信队列问题</h2><p>RabbitMQ中，每个消息的过期不是独立的，一个队列里的某个消息即使比同队列中的其它消息提前过期，也不会优先进入到死信队列，<strong>只有当过期的消息到了队列的顶端，才会被真正的丢弃或者进入死信队列</strong>。<br>我们把<strong>生产者</strong>的代码调整下，先发一个20s过期的消息，再发一个3s过期的消息</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">....</span><br><span class="line">async function testSend() &#123;</span><br><span class="line">    const conn &#x3D; await getMQConnection()</span><br><span class="line">    await run(conn, &#123;</span><br><span class="line">        content: (new Date()).toLocaleString() + &#39; 20s过期 &#39;,</span><br><span class="line">        expiration: &#39;20000&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">    await run(conn, &#123;</span><br><span class="line">        content: (new Date()).toLocaleString() + &#39; 3s过期 &#39;,</span><br><span class="line">        expiration: &#39;3000&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">    await conn.close()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>观察<strong>消费者</strong>输出： </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node consumer.js </span><br><span class="line">begin consuming messages...</span><br><span class="line">[2021&#x2F;3&#x2F;21 下午6:10:21] consumer msg： 2021&#x2F;3&#x2F;21 下午6:10:01 20s过期 </span><br><span class="line">[2021&#x2F;3&#x2F;21 下午6:10:21] consumer msg： 2021&#x2F;3&#x2F;21 下午6:10:01 3s过期</span><br></pre></td></tr></table></figure>
<p>可以发现，3s过期的消息并没有先被消费，而是只能前面的20s过期的消息先过期，它才会被检查是否过期。<br>究其本质的话，RabbitMQ 的队列是一个 <code>FIFO</code> 的有序队列，投入的消息都顺序的压进 MQ 中。而 RabbitMQ 也只会对队列顶端的消息进行超时判定，所以就出现了上述的情况。<br>所以对于固定时间的延时任务的话，例如下单后半小时未支付则关闭订单这种场景，RabbitMQ无疑可以很好的承担起这个需求，但对于需要每条消息的死亡相互独立这种场景，RabbitMQ还是无法满足的。</p>
<h2 id="解决队列消息非异步"><a href="#解决队列消息非异步" class="headerlink" title="解决队列消息非异步"></a>解决队列消息非异步</h2><p>RabbitMQ 本身没有这种功能，但是它有个插件可以解决这个问题：<strong>rabbitmq_delayed_message_exchange</strong>，<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange" target="_blank" rel="noopener">地址</a> 。<br>这个插件的介绍如下：</p>
<blockquote>
<p>A user can declare an exchange with the type x-delayed-message and then publish messages with the custom header x-delay expressing in milliseconds a delay time for the message. The message will be delivered to the respective queues after x-delay milliseconds.  </p>
</blockquote>
<p>这个插件增加了一种新类型的<code>exchange</code>：<strong>x-delayed-message</strong>，然后只要发送消息时指定的是这个交换机，那么只需要在消息 header 中指定参数 x-delay [:毫秒值] 就能够实现每条消息的异步延时。  </p>
<h3 id="添加插件"><a href="#添加插件" class="headerlink" title="添加插件"></a>添加插件</h3><p>用了Docker之后，添加这个插件非常简单，添加<code>Dockerfile</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">FROM rabbitmq:3.8.12-management</span><br><span class="line">COPY .&#x2F;rabbitmq_delayed_message_exchange-3.8.9-0199d11c.ez &#x2F;plugins</span><br><span class="line">RUN rabbitmq-plugins enable rabbitmq_delayed_message_exchange</span><br></pre></td></tr></table></figure>
<p>插件可以在<a href="https://github.com/rabbitmq/rabbitmq-delayed-message-exchange/releases" target="_blank" rel="noopener">Release页</a>下载。<br><strong>docker-compose.yml</strong>改下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">version: &quot;2&quot;</span><br><span class="line">services:</span><br><span class="line">  mq:</span><br><span class="line">    build: .</span><br><span class="line">    restart: always</span><br><span class="line">    mem_limit: 2g</span><br><span class="line">    hostname: mq1</span><br><span class="line">    volumes:</span><br><span class="line">      - .&#x2F;mnesia:&#x2F;var&#x2F;lib&#x2F;rabbitmq&#x2F;mnesia</span><br><span class="line">      - .&#x2F;log:&#x2F;var&#x2F;log&#x2F;rabbitmq</span><br><span class="line">      - .&#x2F;rabbitmq.conf:&#x2F;etc&#x2F;rabbitmq&#x2F;rabbitmq.conf</span><br><span class="line">    ports:</span><br><span class="line">      - &quot;55672:15672&quot;</span><br><span class="line">      - &quot;5672:5672&quot;</span><br><span class="line">    environment:</span><br><span class="line">      - CONTAINER_NAME&#x3D;rabbitMQ</span><br><span class="line">      - RABBITMQ_ERLANG_COOKIE&#x3D;3t182q3wtj1p9z0kd3tb</span><br></pre></td></tr></table></figure>
<p>这样插件就安装成功了。  </p>
<h3 id="修改代码"><a href="#修改代码" class="headerlink" title="修改代码"></a>修改代码</h3><p><strong>producer.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config &#x3D; require(&quot;.&#x2F;config&quot;);</span><br><span class="line">const amqp &#x3D; require(&#39;amqplib&#39;);</span><br><span class="line"></span><br><span class="line">async function getMQConnection() &#123;</span><br><span class="line">    return await amqp.connect(&#123;</span><br><span class="line">        protocol: &#39;amqp&#39;,</span><br><span class="line">        hostname: config.host,</span><br><span class="line">        port: config.port,</span><br><span class="line">        username: config.user,</span><br><span class="line">        password: config.pass,</span><br><span class="line">        locale: &#39;en_US&#39;,</span><br><span class="line">        frameMax: 0,</span><br><span class="line">        heartbeat: 5, &#x2F;&#x2F; 心跳</span><br><span class="line">        vhost: config.vhost,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function run(rmqConn, msgObj) &#123;</span><br><span class="line">    const exchangeDelay &#x3D; &#39;testExNewDelay&#39;;</span><br><span class="line">    const queueDLX &#x3D; &#39;testQueueDLX&#39;;</span><br><span class="line">    const routingKeyDLX &#x3D; &#39;testRoutingKeyDLX&#39;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        const channel &#x3D; await rmqConn.createChannel();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; x-delayed-message类型的exchange</span><br><span class="line">        await channel.assertExchange(exchangeDelay, &#39;x-delayed-message&#39;, &#123; durable: true, autoDelete: false, arguments: &#123;&#39;x-delayed-type&#39;:  &quot;direct&quot;&#125; &#125;);</span><br><span class="line">        await channel.assertQueue(queueDLX, &#123;durable: true, autoDelete: false, &#125;);</span><br><span class="line">        await channel.bindQueue(queueDLX, exchangeDelay, routingKeyDLX);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 发送消息</span><br><span class="line">        await channel.publish(exchangeDelay, routingKeyDLX, Buffer.from(msgObj.content), &#123;</span><br><span class="line">            headers: &#123;&quot;x-delay&quot;: msgObj.expiration&#125;, &#x2F;&#x2F; ms</span><br><span class="line">            persistent: true,</span><br><span class="line">            mandatory: true,</span><br><span class="line">        &#125;);</span><br><span class="line">        console.log(&#39;send message successfully.&#39;)</span><br><span class="line">        await channel.close();</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        console.log(&#39;send message failed:&#39; + err.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function testSend() &#123;</span><br><span class="line">    const conn &#x3D; await getMQConnection()</span><br><span class="line">    await run(conn, &#123;</span><br><span class="line">        content: (new Date()).toLocaleString() + &#39; 20s过期 &#39;,</span><br><span class="line">        expiration: &#39;20000&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">    await run(conn, &#123;</span><br><span class="line">        content: (new Date()).toLocaleString() + &#39; 3s过期 &#39;,</span><br><span class="line">        expiration: &#39;3000&#39;,</span><br><span class="line">    &#125;)</span><br><span class="line">    await conn.close()</span><br><span class="line">&#125;</span><br><span class="line">testSend();</span><br></pre></td></tr></table></figure>

<p><code>x-delayed-type</code>告诉插件在给定的延迟时间过去之后，exchange应该跟<code>direct</code>，<code>fanout</code>，<code>topic</code>中的exchange路由功能一样。  </p>
<p><strong>consumer.js</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">const config &#x3D; require(&quot;.&#x2F;config&quot;);</span><br><span class="line">const amqp &#x3D; require(&#39;amqplib&#39;);</span><br><span class="line"></span><br><span class="line">async function getMQConnection() &#123;</span><br><span class="line">    return await amqp.connect(&#123;</span><br><span class="line">        protocol: &#39;amqp&#39;,</span><br><span class="line">        hostname: config.host,</span><br><span class="line">        port: config.port,</span><br><span class="line">        username: config.user,</span><br><span class="line">        password: config.pass,</span><br><span class="line">        locale: &#39;en_US&#39;,</span><br><span class="line">        frameMax: 0,</span><br><span class="line">        heartbeat: 5, &#x2F;&#x2F; 心跳</span><br><span class="line">        vhost: config.vhost,</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function run(rmqConn) &#123;</span><br><span class="line">    const exchangeDelay &#x3D; &#39;testExNewDelay&#39;;</span><br><span class="line">    const queueDLX &#x3D; &#39;testQueueDLX&#39;;</span><br><span class="line">    const routingKeyDLX &#x3D; &#39;testRoutingKeyDLX&#39;;</span><br><span class="line"></span><br><span class="line">    try &#123;</span><br><span class="line">        const channel &#x3D; await rmqConn.createChannel();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; x-delayed-message类型的exchange</span><br><span class="line">        await channel.assertExchange(exchangeDelay, &#39;x-delayed-message&#39;, &#123; durable: true, autoDelete: false, arguments: &#123;&#39;x-delayed-type&#39;:  &quot;direct&quot;&#125; &#125;);</span><br><span class="line">        await channel.assertQueue(queueDLX, &#123;durable: true, autoDelete: false, &#125;);</span><br><span class="line">        await channel.bindQueue(queueDLX, exchangeDelay, routingKeyDLX);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 处理死信队列消息</span><br><span class="line">        await channel.consume(queueDLX, msg &#x3D;&gt; &#123;</span><br><span class="line">            console.log(&#96;[$&#123;(new Date()).toLocaleString()&#125;] consumer msg：&#96;, msg.content.toString());</span><br><span class="line">        &#125;, &#123; noAck: true &#125;);</span><br><span class="line">    &#125; catch(err) &#123;</span><br><span class="line">        console.log(&#39;consume message failed:&#39; + err.message)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">async function testConsume() &#123;</span><br><span class="line">    const conn &#x3D; await getMQConnection();</span><br><span class="line">    console.log(&#39;begin consuming messages...&#39;);</span><br><span class="line">    await run(conn);</span><br><span class="line"></span><br><span class="line">    process.on(&#39;SIGINT&#39;, () &#x3D;&gt; &#123;</span><br><span class="line">        console.log(&#39;stop consumer.&#39;)</span><br><span class="line">        conn.close();</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">testConsume();</span><br></pre></td></tr></table></figure>

<h3 id="测试效果"><a href="#测试效果" class="headerlink" title="测试效果"></a>测试效果</h3><p>执行<strong>生产者</strong>代码之后，我们可以看到<strong>消费者</strong>输出：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">$ node consumer.js </span><br><span class="line">begin consuming messages...</span><br><span class="line">[2021&#x2F;3&#x2F;22 下午2:16:37] consumer msg： 2021&#x2F;3&#x2F;22 下午2:16:34 3s过期 </span><br><span class="line">[2021&#x2F;3&#x2F;22 下午2:16:54] consumer msg： 2021&#x2F;3&#x2F;22 下午2:16:34 20s过期</span><br></pre></td></tr></table></figure>
<p>可以发现，消息已经独立的过期了。</p>
<h3 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h3><p>没有什么东西是完美的，这个插件也不例外。看下这个插件的<code>Performance Impact</code>部分：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">For each message that crosses an &quot;x-delayed-message&quot; exchange, </span><br><span class="line">the plugin will try to determine if the message has to be expired by making sure the delay is within range, </span><br><span class="line">ie: Delay &gt; 0, Delay &#x3D;&lt; ?ERL_MAX_T (In Erlang a timer can be set up to (2^32)-1 milliseconds in the future).</span><br></pre></td></tr></table></figure>
<p>延迟时间最大为 (2^32)-1 毫秒，大约 49 天。另外这个插件也不适合大量延迟消息（例如数十万或数百万）的场景，<code>Limitations</code>也写了：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">Current design of this plugin doesn&#39;t really fit scenarios with a high number of delayed messages </span><br><span class="line">(e.g. 100s of thousands or millions). See #72 for details.</span><br></pre></td></tr></table></figure>

<p>参考：</p>
<ul>
<li><a href="https://www.skypyb.com/2020/01/jishu/1206/" target="_blank" rel="noopener">RabbitMQ 死信机制真的可以作为延时任务这个场景的解决方案吗？</a></li>
<li><a href="http://blog.lbanyan.com/rabbitmq_delay/" target="_blank" rel="noopener">RabbitMQ 延迟队列插件 x-delay Bug</a></li>
</ul>
]]></content>
      <categories>
        <category>RabbitMQ</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title>Typescript学习</title>
    <url>/2021/06/05/Typescript_learn/</url>
    <content><![CDATA[<h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装TypeScript还是很简单的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">npm install -g typescript</span><br></pre></td></tr></table></figure>
<p>写个hello.ts</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHello(person: string) &#123;</span><br><span class="line">    return &#39;Hello, &#39; + person;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let user &#x3D; &#39;Tom&#39;;</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure>

<a id="more"></a>

<p>然后执行</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">tsc hello.ts</span><br></pre></td></tr></table></figure>
<p>这时候会生成一个编译好的文件 <code>hello.js</code>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">function sayHello(person) &#123;</span><br><span class="line">    return &#39;Hello, &#39; + person;</span><br><span class="line">&#125;</span><br><span class="line">var user &#x3D; &#39;Tom&#39;;</span><br><span class="line">console.log(sayHello(user));</span><br></pre></td></tr></table></figure>
<p>可以看到，编译好后的就是平常的js代码，TS的一个优点在于类型的声明，这样在编译期bug就能及早发现（当然还有其他好处，例如<strong>泛型</strong>，<strong>Enum</strong>，<strong>装饰器</strong>）。<br>注意： <strong>TypeScript</strong> 只会在编译时对类型进行静态检查，如果发现有错误，编译的时候就会报错。而在运行时，与普通的 JavaScript 文件一样，不会对类型进行检查。</p>
<h2 id="复杂点"><a href="#复杂点" class="headerlink" title="复杂点"></a>复杂点</h2><p>构建一个TypeScript的项目就需要<code>tsconfig.json</code>文件了。如果一个目录下存在一个<code>tsconfig.json</code>文件，那么它意味着这个目录是TypeScript项目的根目录。  </p>
<p>创建一个简单的项目，目录结构如下：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">MyProj</span><br><span class="line">├── src</span><br><span class="line">│   ├── index.ts</span><br><span class="line">│   ├── person.ts</span><br><span class="line">│   ├── animal.js</span><br><span class="line">├── package.json</span><br><span class="line">├── tsconfig.json</span><br><span class="line">├── .eslintrc.js</span><br></pre></td></tr></table></figure>
<p>tsconfig.json文件  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;compilerOptions&quot;: &#123;</span><br><span class="line">    &quot;target&quot;: &quot;ES2018&quot;, &#x2F;&#x2F; 指定ECMAScript目标版本</span><br><span class="line">    &quot;module&quot;: &quot;commonjs&quot;,</span><br><span class="line">    &quot;moduleResolution&quot;: &quot;node&quot;,</span><br><span class="line">    &quot;experimentalDecorators&quot;: true, &#x2F;&#x2F; 开启装饰器</span><br><span class="line">    &quot;strict&quot;: true, &#x2F;&#x2F; 启用所有严格类型检查选项</span><br><span class="line">    &quot;noImplicitAny&quot;: false,</span><br><span class="line">    &quot;removeComments&quot;: true, &#x2F;&#x2F; 移除注释</span><br><span class="line">    &quot;sourceMap&quot;: false,</span><br><span class="line">    &quot;rootDir&quot;: &quot;src&quot;, &#x2F;&#x2F; Default: The longest common path of all non-declaration input files.</span><br><span class="line">    &quot;outDir&quot;: &quot;dist&quot;, &#x2F;&#x2F; 编译输出目录</span><br><span class="line">    &quot;allowJs&quot;: true &#x2F;&#x2F; 允许JS文件混合</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;include&quot;: [&quot;src&#x2F;**&#x2F;*&quot;], &#x2F;&#x2F; 指定要编译文件</span><br><span class="line">  &quot;exclude&quot;: [&quot;node_modules&quot;] &#x2F;&#x2F; 指定要排除的编译文件</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>person.ts</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class Person &#123;</span><br><span class="line">  private name: string;</span><br><span class="line"></span><br><span class="line">  private age: number;</span><br><span class="line"></span><br><span class="line">  constructor(name: string, age: number) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">    this.age &#x3D; age;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  getName() &#123;</span><br><span class="line">    return this.name;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export interface Payload &#123;</span><br><span class="line">  title: string;</span><br><span class="line">  description: string;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>index.ts</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">import &#123; Person, Payload &#125; from &#39;.&#x2F;person&#39;;</span><br><span class="line">import &#123; Animal &#125; from &#39;.&#x2F;animal&#39;;</span><br><span class="line"></span><br><span class="line">const p &#x3D; new Person(&#39;sala&#39;, 12);</span><br><span class="line"></span><br><span class="line">const data: Payload &#x3D; &#123; title: &#39;One&#39;, description: &#39;happy...&#39; &#125;;</span><br><span class="line"></span><br><span class="line">type StringOrNumber &#x3D; string | number;</span><br><span class="line"></span><br><span class="line">function getString(n: StringOrNumber): string &#123;</span><br><span class="line">  if (typeof n &#x3D;&#x3D;&#x3D; &#39;string&#39;) &#123;</span><br><span class="line">    return n;</span><br><span class="line">  &#125; else &#123;</span><br><span class="line">    return n.toString();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">const animal &#x3D; new Animal(&#39;Kitty&#39;);</span><br></pre></td></tr></table></figure>
<p><strong>animal.js</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">export class Animal &#123;</span><br><span class="line">  constructor(name) &#123;</span><br><span class="line">    this.name &#x3D; name;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  sayHi() &#123;</span><br><span class="line">    return &#39;hello!&#39;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>package.json</strong></p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;name&quot;: &quot;ts_learn_project&quot;,</span><br><span class="line">  &quot;version&quot;: &quot;1.0.0&quot;,</span><br><span class="line">  &quot;description&quot;: &quot;&quot;,</span><br><span class="line">  &quot;main&quot;: &quot;index.js&quot;,</span><br><span class="line">  &quot;dependencies&quot;: &#123;&#125;,</span><br><span class="line">  &quot;devDependencies&quot;: &#123;</span><br><span class="line">    &quot;@typescript-eslint&#x2F;eslint-plugin&quot;: &quot;^4.22.0&quot;,</span><br><span class="line">    &quot;@typescript-eslint&#x2F;parser&quot;: &quot;^4.22.0&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;^7.24.0&quot;,</span><br><span class="line">    &quot;typescript&quot;: &quot;^4.2.4&quot;,</span><br><span class="line">    &quot;mwts&quot;: &quot;^1.0.5&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;scripts&quot;: &#123;</span><br><span class="line">    &quot;test&quot;: &quot;echo \&quot;Error: no test specified\&quot; &amp;&amp; exit 1&quot;,</span><br><span class="line">    &quot;eslint&quot;: &quot;eslint src --ext .ts&quot;,</span><br><span class="line">    &quot;build&quot;: &quot;tsc&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;keywords&quot;: [</span><br><span class="line">    &quot;typescript&quot;</span><br><span class="line">  ],</span><br><span class="line">  &quot;author&quot;: &quot;salamander&quot;,</span><br><span class="line">  &quot;license&quot;: &quot;ISC&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>.eslintrc.js</strong>  </p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">module.exports &#x3D; &#123;</span><br><span class="line">  parser: &quot;@typescript-eslint&#x2F;parser&quot;,</span><br><span class="line">  plugins: [&quot;@typescript-eslint&quot;],</span><br><span class="line">  rules: &#123;</span><br><span class="line">    &#x2F;&#x2F; 禁止使用 var</span><br><span class="line">    &quot;no-var&quot;: &quot;error&quot;,</span><br><span class="line">    &#x2F;&#x2F; 优先使用 interface 而不是 type</span><br><span class="line">    &quot;@typescript-eslint&#x2F;consistent-type-definitions&quot;: [&quot;error&quot;, &quot;interface&quot;],</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2019 年 1 月，TypeScirpt 官方决定全面采用 ESLint 作为代码检查的工具，并创建了一个新项目 <a href="https://github.com/typescript-eslint/typescript-eslint/blob/master/packages/parser" target="_blank" rel="noopener">typescript-eslint</a>，提供了 TypeScript 文件的解析器 @typescript-eslint/parser 和相关的配置选项 @typescript-eslint/eslint-plugin 等。</p>
<p>参考：</p>
<ul>
<li><a href="https://typescript.bootcss.com/tutorials/typescript-in-5-minutes.html" target="_blank" rel="noopener">TypeScript 中文手册</a></li>
<li><a href="https://www.typescriptlang.org/tsconfig" target="_blank" rel="noopener">tsconfig</a></li>
</ul>
]]></content>
      <categories>
        <category>Javascript</category>
      </categories>
      <tags>
        <tag>Typescript</tag>
      </tags>
  </entry>
</search>
