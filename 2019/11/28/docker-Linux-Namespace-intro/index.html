<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 4.2.1">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="//cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.14.0/css/all.min.css">
  <link rel="stylesheet" href="//cdn.jsdelivr.net/npm/animate.css@3.1.1/animate.min.css">

<script class="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"yoursite.com","root":"/","scheme":"Muse","version":"8.0.0","exturl":false,"sidebar":{"position":"right","display":"post","padding":18,"offset":12},"copycode":false,"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}};
  </script>

  <meta name="description" content="本文环境：  OS：Ubuntu 18.04.3 LTS 内核版本： 5.0.0-36-generic   Linux NamespacesDocker的所用的两个关键技术，一个是Namespaces，一个是Cgroups。它俩都不是新技术，Linux内核很早就支持，但是Docker把它们有机地结合起来，加上自己创新，使得现在容器技术非常流行。Linux Namespaces其实是做到了进程之间">
<meta property="og:type" content="article">
<meta property="og:title" content="一步步自己做个Docker之Linux Namespace 简介">
<meta property="og:url" content="http://yoursite.com/2019/11/28/docker-Linux-Namespace-intro/index.html">
<meta property="og:site_name" content="Salamander的博客">
<meta property="og:description" content="本文环境：  OS：Ubuntu 18.04.3 LTS 内核版本： 5.0.0-36-generic   Linux NamespacesDocker的所用的两个关键技术，一个是Namespaces，一个是Cgroups。它俩都不是新技术，Linux内核很早就支持，但是Docker把它们有机地结合起来，加上自己创新，使得现在容器技术非常流行。Linux Namespaces其实是做到了进程之间">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://yoursite.com/images/docker-logo.png">
<meta property="article:published_time" content="2019-11-28T08:10:00.000Z">
<meta property="article:modified_time" content="2020-03-27T12:53:47.423Z">
<meta property="article:author" content="Salamander">
<meta property="article:tag" content="Docker">
<meta property="article:tag" content="Namespace">
<meta property="article:tag" content="Cgroup">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/images/docker-logo.png">


<link rel="canonical" href="http://yoursite.com/2019/11/28/docker-Linux-Namespace-intro/">


<script class="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>一步步自己做个Docker之Linux Namespace 简介 | Salamander的博客</title>
  






  <noscript>
  <style>
  body { margin-top: 2rem; }

  .use-motion .menu-item,
  .use-motion .sidebar,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header {
    visibility: visible;
  }

  .use-motion .header,
  .use-motion .site-brand-container .toggle,
  .use-motion .footer { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle,
  .use-motion .custom-logo-image {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line {
    transform: scaleX(1);
  }

  .search-pop-overlay, .sidebar-nav { display: none; }
  .sidebar-panel { display: block; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <h1 class="site-title">Salamander的博客</h1>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">Salamander的博客</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <section class="post-toc-wrap sidebar-panel">
          <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-Namespaces"><span class="nav-number">1.</span> <span class="nav-text">Linux Namespaces</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#尝试一下Namespace"><span class="nav-number">1.1.</span> <span class="nav-text">尝试一下Namespace</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#三个系统调用"><span class="nav-number">1.2.</span> <span class="nav-text">三个系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#clone：创建新进程并设置它的Namespace"><span class="nav-number">1.2.1.</span> <span class="nav-text">clone：创建新进程并设置它的Namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#setns：让进程加入已经存在Namespace"><span class="nav-number">1.2.2.</span> <span class="nav-text">setns：让进程加入已经存在Namespace</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#unshare：让进程加入新的Namespace"><span class="nav-number">1.2.3.</span> <span class="nav-text">unshare：让进程加入新的Namespace</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#C程序中使用clone系统调用"><span class="nav-number">2.</span> <span class="nav-text">C程序中使用clone系统调用</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Let’s-Go"><span class="nav-number">2.1.</span> <span class="nav-text">Let’s Go</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#参考资料"><span class="nav-number">2.2.</span> <span class="nav-text">参考资料</span></a></li></ol></li></ol></div>
      </section>
      <!--/noindex-->

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-author animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Salamander</p>
  <div class="site-description" itemprop="description">一个简单的博客</div>
</div>
<div class="site-state-wrap animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives">
          <span class="site-state-item-count">35</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">26</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">58</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author animated">
      <span class="links-of-author-item">
        <a href="https://github.com/salamander-mh" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;salamander-mh" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </section>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">
      

      

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2019/11/28/docker-Linux-Namespace-intro/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Salamander">
      <meta itemprop="description" content="一个简单的博客">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Salamander的博客">
    </span>

    
    
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          一步步自己做个Docker之Linux Namespace 简介
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2019-11-28 16:10:00" itemprop="dateCreated datePublished" datetime="2019-11-28T16:10:00+08:00">2019-11-28</time>
    </span>
      <span class="post-meta-item">
        <span class="post-meta-item-icon">
          <i class="far fa-calendar-check"></i>
        </span>
        <span class="post-meta-item-text">更新于</span>
        <time title="修改时间：2020-03-27 20:53:47" itemprop="dateModified" datetime="2020-03-27T20:53:47+08:00">2020-03-27</time>
      </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/Docker/" itemprop="url" rel="index"><span itemprop="name">Docker</span></a>
        </span>
    </span>

  
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p><img src="/images/docker-logo.png" alt="docker logo"></p>
<p>本文环境：</p>
<ul>
<li>OS：Ubuntu 18.04.3 LTS</li>
<li>内核版本： 5.0.0-36-generic </li>
</ul>
<h2 id="Linux-Namespaces"><a href="#Linux-Namespaces" class="headerlink" title="Linux Namespaces"></a>Linux Namespaces</h2><p>Docker的所用的两个关键技术，一个是<code>Namespaces</code>，一个是<code>Cgroups</code>。它俩都不是新技术，Linux内核很早就支持，但是Docker把它们有机地结合起来，加上自己创新，使得现在容器技术非常流行。<br><code>Linux Namespaces</code>其实是做到了进程之间全局资源的隔离，譬如，<code>UTS Namespace</code>隔离了Hostname空间。这意味着在新的<code>UTS Namespace</code>中的进程，可以拥有不同于宿主机的主机名。 </p>
<a id="more"></a>

<p>目前Linux内核主要实现了以下几种不同的资源<code>Namespace</code>：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>宏定义</th>
<th>隔离的内容</th>
</tr>
</thead>
<tbody><tr>
<td>IPC</td>
<td>CLONE_NEWIPC</td>
<td>System V IPC, POSIX message queues (since Linux 2.6.19)</td>
</tr>
<tr>
<td>Network</td>
<td>CLONE_NEWNET</td>
<td>network device interfaces, IPv4 and IPv6 protocol stacks, IP routing tables, firewall rules, the /proc/net and /sys/class/net directory trees, sockets, etc (since Linux 2.6.24)</td>
</tr>
<tr>
<td>Mount</td>
<td>CLONE_NEWNS</td>
<td>Mount points (since Linux 2.4.19)</td>
</tr>
<tr>
<td>PID</td>
<td>CLONE_NEWPID</td>
<td>Process IDs (since Linux 2.6.24)</td>
</tr>
<tr>
<td>User</td>
<td>CLONE_NEWUSER</td>
<td>User and group IDs (started in Linux 2.6.23 and completed in Linux 3.8)</td>
</tr>
<tr>
<td>UTS</td>
<td>CLONE_NEWUTS</td>
<td>Hostname and NIS domain name (since Linux 2.6.19)</td>
</tr>
<tr>
<td>Cgroup</td>
<td>CLONE_NEWCGROUP</td>
<td>Cgroup root directory (since Linux 4.6)</td>
</tr>
</tbody></table>
<p>要注意一点的是，不是所有的系统资源都能隔离，时间就是个例外，没有对应的<code>Namespace</code>，因此同一台Linux启动的容器时间都是相同的。</p>
<h3 id="尝试一下Namespace"><a href="#尝试一下Namespace" class="headerlink" title="尝试一下Namespace"></a>尝试一下Namespace</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">lucy@lucy-computer:~$ unshare -h</span><br><span class="line"></span><br><span class="line">用法：</span><br><span class="line"> unshare [选项] [&lt;程序&gt; [&lt;参数&gt;...]]</span><br><span class="line"></span><br><span class="line">以某些未与父(进程)共享的名字空间运行某个程序。</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line"> -m, --mount[=&lt;文件&gt;]      取消共享 mounts 名字空间</span><br><span class="line"> -u, --uts[=&lt;文件&gt;]        取消共享 UTS 名字空间(主机名等)</span><br><span class="line"> -i, --ipc[=&lt;文件&gt;]        取消共享 System V IPC 名字空间</span><br><span class="line"> -n, --net[=&lt;file&gt;]        取消共享网络名字空间</span><br><span class="line"> -p, --pid[=&lt;文件&gt;]        取消共享 pid 名字空间</span><br><span class="line"> -U, --user[=&lt;文件&gt;]       取消共享用户名字空间</span><br><span class="line"> -C, --cgroup[=&lt;文件&gt;]     取消共享 cgroup 名字空间</span><br><span class="line"> -f, --fork                在启动&lt;程序&gt;前 fork</span><br><span class="line">     --mount-proc[=&lt;目录&gt;] 先挂载 proc 文件系统(连带打开 --mount)</span><br><span class="line"> -r, --map-root-user       将当前用户映射为 root (连带打开 --user)</span><br><span class="line">     --propagation slave|shared|private|unchanged</span><br><span class="line">                           修改 mount 名字空间中的 mount 传播</span><br><span class="line"> -s, --setgroups allow|deny  控制用户名字空间中的 setgroups 系统调用</span><br><span class="line"></span><br><span class="line"> -h, --help                display this help</span><br><span class="line"> -V, --version             display version</span><br></pre></td></tr></table></figure>

<p><code>unshare</code>命令可以让你在新的名称空间集中启动一个新的程序（unshared本身的含义就是不和父进程共享）。<br>下面的例子使用了<code>UTS namespace</code>，可以看到在新的<code>/bin/sh</code>进程中修改hostname，并没有影响宿主机：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ sudo su                   # become root user</span><br><span class="line">$ hostname                  # check current hostname</span><br><span class="line">lucy-computer  </span><br><span class="line">$ unshare -u /bin/sh        # create a shell in new UTS namespace</span><br><span class="line">$ hostname my-new-hostname  # set hostname</span><br><span class="line">$ hostname                  # confirm new hostname</span><br><span class="line">my-new-hostname  </span><br><span class="line">$ exit                      # exit new UTS namespace</span><br><span class="line">$ hostname                  # confirm original hostname unchanged</span><br><span class="line">lucy-computer</span><br></pre></td></tr></table></figure>

<h3 id="三个系统调用"><a href="#三个系统调用" class="headerlink" title="三个系统调用"></a>三个系统调用</h3><p><code>unshare</code>命令很棒，但是当我们想要对程序中的命名空间进行更细粒度的控制时，那该怎么办呢？<br>Linux 内核提供的功能都会提供<code>系统调用</code>接口供应用程序使用，<code>Namespace</code>也不例外。和<code>Namespace</code>相关的系统调用主要有三个：</p>
<ul>
<li><a href="http://man7.org/linux/man-pages/man2/clone.2.html" target="_blank" rel="noopener">clone</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/setns.2.html" target="_blank" rel="noopener">setns</a></li>
<li><a href="http://man7.org/linux/man-pages/man2/unshare.2.html" target="_blank" rel="noopener">unshare</a></li>
</ul>
<p><strong>注意</strong>：这些系统调用都是 linux 内核实现的，不能直接适用于其他操作系统。</p>
<p>查看一下它们对应的C语言函数原型：</p>
<h4 id="clone：创建新进程并设置它的Namespace"><a href="#clone：创建新进程并设置它的Namespace" class="headerlink" title="clone：创建新进程并设置它的Namespace"></a>clone：创建新进程并设置它的Namespace</h4><p><code>clone</code>类似于<code>fork</code>系统调用，可以创建一个新的进程，不同的是你可以指定要子进程要执行的函数以及通过参数控制子进程的运行环境。</p>
<blockquote>
<p>实际上，clone() 是在 C 语言库中定义的一个封装(wrapper)函数，它负责建立新进程的堆栈并且调用对编程者隐藏的 clone() 系统调用。Clone() 其实是 linux 系统调用 fork() 的一种更通用的实现方式，它可以通过 flags 来控制使用多少功能。</p>
</blockquote>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line"></span><br><span class="line">int clone(int (*fn)(void *), void *child_stack, int flags, void *arg);</span><br></pre></td></tr></table></figure>

<ul>
<li>fn：指定一个由新进程执行的函数。当这个函数返回时，子进程终止。该函数返回一个整数，表示子进程的退出代码。</li>
<li>child_stack：传入子进程使用的栈空间，也就是把用户态堆栈指针赋给子进程的 esp 寄存器。调用进程(指调用 clone() 的进程)应该总是为子进程分配新的堆栈。</li>
<li>flags：表示使用哪些 CLONE_ 开头的标志位，与 namespace 相关的有CLONE_NEWIPC、CLONE_NEWNET、CLONE_NEWNS、CLONE_NEWPID、CLONE_NEWUSER、CLONE_NEWUTS 和 CLONE_NEWCGROUP，如果要同时隔离多个 namespace，<strong>可以使用 | (按位或)组合这些参数</strong>。</li>
<li>arg：指向传递给 fn() 函数的参数。</li>
</ul>
<h4 id="setns：让进程加入已经存在Namespace"><a href="#setns：让进程加入已经存在Namespace" class="headerlink" title="setns：让进程加入已经存在Namespace"></a>setns：让进程加入已经存在Namespace</h4><p>setns 能够把某个进程加入到给定的 namespace，它的定义是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">int setns(int fd, int nstype);</span><br></pre></td></tr></table></figure>

<p>和<code>clone()</code>函数一样，C 语言库中的<code>setns()</code>函数也是对<code>setns系统调用</code>的封装。  </p>
<ul>
<li>fd：表示要加入 namespace 的文件描述符。它是一个指向 /proc/[pid]/ns 目录中文件的文件描述符，可以通过直接打开该目录下的链接文件或者打开一个挂载了该目录下链接文件的文件得到。</li>
<li>nstype：参数 nstype 让调用者可以检查 fd 指向的 namespace 类型是否符合实际要求。若把该参数设置为 0 表示不检查。</li>
</ul>
<h4 id="unshare：让进程加入新的Namespace"><a href="#unshare：让进程加入新的Namespace" class="headerlink" title="unshare：让进程加入新的Namespace"></a>unshare：让进程加入新的Namespace</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">int unshare(int flags);</span><br></pre></td></tr></table></figure>

<p><code>unshare()</code>函数比较简单，只有一个参数<code>flags</code>，它的含义和<code>clone()</code>的<code>flags</code>相同。<code>unshare</code>和 <code>setns</code> 的区别是，<code>setns</code> 只能让进程加入到已经存在的<code>namespace</code>中，而<code>unshare</code>则让进程离开当前的<code>namespace</code>，加入到新建的<code>namespace</code>中。  </p>
<p><code>unshare()</code>和<code>clone()</code>的区别在于：<code>unshare()</code>是把当前进程进入到新的<code>namespace</code>；<code>clone()</code>是创建新的进程，然后让新创建的进程（子进程）加入到新的<code>namespace</code>。</p>
<h2 id="C程序中使用clone系统调用"><a href="#C程序中使用clone系统调用" class="headerlink" title="C程序中使用clone系统调用"></a>C程序中使用clone系统调用</h2><p>我们先来看看 clone 一个简单的使用例子：创建一个新的进程，并执行 /bin/bash，这样就可以接受命令，方便我们查看新进程的信息。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 设置子进程要使用的栈空间</span><br><span class="line">#define STACK_SIZE (1024*1024)</span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">#define errExit(code, msg); &#123;if(code == -1)&#123;perror(msg); exit(-1);&#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int container_func(void *arg)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Container[%d] - inside the container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 用一个新的bash来替换掉当前子进程，</span><br><span class="line">    // 这样我们就能通过 bash 查看当前子进程的情况.</span><br><span class="line">    // bash退出后，子进程执行完毕</span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line"></span><br><span class="line">    // 从这里开始的代码将不会被执行到，因为当前子进程已经被上面的bash替换掉了;</span><br><span class="line">    // 所以如果执行到这里，一定是出错了</span><br><span class="line">    printf(&quot;Container[%d] - oops!\n&quot;, pid);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Parent[%d] - create a container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 创建并启动子进程，调用该函数后，父进程将继续往后执行，也就是执行后面的waitpid</span><br><span class="line">    pid_t child_pid = clone(container_func,  // 子进程将执行container_func这个函数</span><br><span class="line">                    container_stack + sizeof(container_stack),</span><br><span class="line">                    // 这里SIGCHLD是子进程退出后返回给父进程的信号，跟namespace无关</span><br><span class="line">                    SIGCHLD,</span><br><span class="line">                    NULL);  // 传给child_func的参数</span><br><span class="line">    errExit(child_pid, &quot;clone&quot;);</span><br><span class="line"></span><br><span class="line">    waitpid(child_pid, NULL, 0); // 等待子进程结束</span><br><span class="line"></span><br><span class="line">    printf(&quot;Parent[%d] - container exited!\n&quot;, pid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这段代码不长，但是做了很多事情：</p>
<ul>
<li>通过<code>clone()</code>创建出一个子进程，并设置启动时的参数</li>
<li>在子进程中调用 execv 来执行 /bin/bash，等待用户进行交互</li>
<li>子进程退出之后，父进程也跟着退出</li>
</ul>
<p>我们可以用<code>ls -l /proc/$$/ns</code>查看当前进程所在命名空间的信息，运行程序：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">lucy@lucy-computer:~$ gcc container.c -o container</span><br><span class="line">lucy@lucy-computer:~$ ./container </span><br><span class="line">Parent[19644] - create a container!</span><br><span class="line">Container[19645] - inside the container!</span><br><span class="line">lucy@lucy-computer:~$ ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:36 uts -&gt; &apos;uts:[4026531838]&apos;</span><br><span class="line">lucy@lucy-computer:~$ exit</span><br><span class="line">exit</span><br><span class="line">Parent[19644] - container exited!</span><br><span class="line">lucy@lucy-computer:~$ ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 lucy lucy 0 11月 28 15:39 uts -&gt; &apos;uts:[4026531838]&apos;</span><br></pre></td></tr></table></figure>

<p>各类命名空间id都是一样，因为我们只是单单使用了<code>clone</code>，未设置要隔离的命名空间，现在，我们加入<code>UTS Namespace</code>隔离，<code>UTS namespace</code> 功能最简单，它只隔离了 hostname 和 NIS domain name 两个资源。<br>同一个 namespace 里面的进程看到的 hostname 和 domain name 是相同的，这两个值可以通过 <code>sethostname(2)</code> 和 <code>setdomainname(2)</code> 来进行设置，也可以通过 <code>uname(2)</code>、<code>gethostname(2)</code> 和 <code>getdomainname(2)</code> 来读取。<br><strong>注意</strong>： UTS 的名字来自于<code>uname</code>函数用到的结构体<code>struct utsname</code>，这个结构体的名字源自于<code>UNIX Time-sharing System</code>。<br>代码主要修改两个地方：clone 的参数加上了 CLONE_NEWUTS，子进程函数中使用<code>sethostname</code>来设置 hostname。  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line">#define _GNU_SOURCE</span><br><span class="line">#include &lt;sched.h&gt;</span><br><span class="line">#include &lt;sys/wait.h&gt;</span><br><span class="line">#include &lt;sys/utsname.h&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;unistd.h&gt;</span><br><span class="line">#include &lt;string.h&gt;</span><br><span class="line"></span><br><span class="line">// 设置子进程要使用的栈空间</span><br><span class="line">#define STACK_SIZE (1024*1024)</span><br><span class="line">static char container_stack[STACK_SIZE];</span><br><span class="line"></span><br><span class="line">#define errExit(code, msg); &#123;if(code == -1)&#123;perror(msg); exit(-1);&#125; &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">char* const container_args[] = &#123;</span><br><span class="line">    &quot;/bin/bash&quot;,</span><br><span class="line">    NULL</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">static int container_func(void *hostname)</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Container[%d] - inside the container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 使用 sethostname 设置子进程的 hostname 信息</span><br><span class="line">    struct utsname uts;</span><br><span class="line">    if (sethostname(hostname, strlen(hostname)) == -1) &#123;</span><br><span class="line">        errExit(-1, &quot;sethostname&quot;)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    // 使用 uname 获取子进程的机器信息，并打印 hostname 出来</span><br><span class="line">    if (uname(&amp;uts) == -1)&#123;</span><br><span class="line">        errExit(-1, &quot;uname&quot;)</span><br><span class="line">    &#125;</span><br><span class="line">    printf(&quot;Container[%d] - container uts.nodename: [%s]!\n&quot;, pid, uts.nodename);</span><br><span class="line"></span><br><span class="line">    // 用一个新的bash来替换掉当前子进程，</span><br><span class="line">    // 这样我们就能通过 bash 查看当前子进程的情况.</span><br><span class="line">    // bash退出后，子进程执行完毕</span><br><span class="line">    execv(container_args[0], container_args);</span><br><span class="line"></span><br><span class="line">    // 从这里开始的代码将不会被执行到，因为当前子进程已经被上面的bash替换掉了;</span><br><span class="line">    // 所以如果执行到这里，一定是出错了</span><br><span class="line">    printf(&quot;Container[%d] - oops!\n&quot;, pid);</span><br><span class="line">    return 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    pid_t pid = getpid();</span><br><span class="line">    printf(&quot;Parent[%d] - create a container!\n&quot;, pid);</span><br><span class="line"></span><br><span class="line">    // 把第一个参数作为子进程的 hostname，默认是 `container`</span><br><span class="line">    char *hostname;</span><br><span class="line">    if (argc &lt; 2) &#123;</span><br><span class="line">        hostname = &quot;container&quot;;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">        hostname = argv[1];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    // 创建并启动子进程，调用该函数后，父进程将继续往后执行，也就是执行后面的waitpid</span><br><span class="line">    pid_t child_pid = clone(container_func,  // 子进程将执行container_func这个函数</span><br><span class="line">                    container_stack + sizeof(container_stack),</span><br><span class="line">                    // CLONE_NEWUTS表示创建新的UTS namespace</span><br><span class="line">                    CLONE_NEWUTS | SIGCHLD,</span><br><span class="line">                    hostname);  // 传给child_func的参数</span><br><span class="line">    errExit(child_pid, &quot;clone&quot;);</span><br><span class="line"></span><br><span class="line">    waitpid(child_pid, NULL, 0); // 等待子进程结束</span><br><span class="line"></span><br><span class="line">    printf(&quot;Parent[%d] - container exited!\n&quot;, pid);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行程序，发现容器中hostname与宿主机已经不一样了，容器中<code>UTS Namespace</code>id也跟宿主机不一样了（这里需要root权限）：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">sudo su</span><br><span class="line">root@lucy-computer:/home/lucy# gcc container.c -o container</span><br><span class="line">root@lucy-computer:/home/lucy# ./container </span><br><span class="line">Parent[21091] - create a container!</span><br><span class="line">Container[21092] - inside the container!</span><br><span class="line">Container[21092] - container uts.nodename: [container]!</span><br><span class="line">root@container:/home/lucy# hostname</span><br><span class="line">container</span><br><span class="line">root@container:/home/lucy# ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 uts -&gt; &apos;uts:[4026532944]&apos;</span><br><span class="line">root@container:/home/lucy# exit</span><br><span class="line">exit</span><br><span class="line">Parent[21091] - container exited!</span><br><span class="line">root@lucy-computer:/home/lucy# ls -l /proc/$$/ns</span><br><span class="line">总用量 0</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 cgroup -&gt; &apos;cgroup:[4026531835]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 ipc -&gt; &apos;ipc:[4026531839]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 mnt -&gt; &apos;mnt:[4026531840]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 net -&gt; &apos;net:[4026531992]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 pid_for_children -&gt; &apos;pid:[4026531836]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 user -&gt; &apos;user:[4026531837]&apos;</span><br><span class="line">lrwxrwxrwx 1 root root 0 11月 28 16:00 uts -&gt; &apos;uts:[4026531838]&apos;</span><br><span class="line">root@lucy-computer:/home/lucy# hostname</span><br><span class="line">lucy-computer</span><br></pre></td></tr></table></figure>

<h3 id="Let’s-Go"><a href="#Let’s-Go" class="headerlink" title="Let’s Go"></a>Let’s Go</h3><p>C语言很底层，能控制到很多细节，但是它对于大部分人有点困难，接下来我们会有Go语言来一步步实现Docker容器。</p>
<h3 id="参考资料"><a href="#参考资料" class="headerlink" title="参考资料"></a>参考资料</h3><ul>
<li><a href="https://cizixs.com/2017/08/29/linux-namespace/" target="_blank" rel="noopener">cizixs.com/2017/08/29/linux-namespace</a></li>
<li><a href="https://www.cnblogs.com/sparkdev/p/9365405.html" target="_blank" rel="noopener">Linux Namespace : 简介</a></li>
</ul>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="reward-container">
  <div>您的支持将鼓励我继续创作！</div>
  <button onclick="document.querySelector('.post-reward').classList.toggle('active');">
    赞赏
  </button>
  <div class="post-reward">
      <div>
        <img src="/images/wechatpay.jpg" alt="Salamander 微信">
        <span>微信</span>
      </div>
      <div>
        <img src="/images/alipay.jpg" alt="Salamander 支付宝">
        <span>支付宝</span>
      </div>

  </div>
</div>

          <div class="post-tags">
              <a href="/tags/Docker/" rel="tag"># Docker</a>
              <a href="/tags/Namespace/" rel="tag"># Namespace</a>
              <a href="/tags/Cgroup/" rel="tag"># Cgroup</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2019/11/16/CefSharp_summary/" rel="prev" title="CefSharp浅尝辄止">
                  <i class="fa fa-chevron-left"></i> CefSharp浅尝辄止
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2019/12/10/min_spanning_tree/" rel="next" title="最小生成树回顾">
                  最小生成树回顾 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
  
  
  



      

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      const activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      const commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

    </div>
  </main>

  <footer class="footer">
    <div class="footer-inner">
      

      

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Salamander</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="//cdn.jsdelivr.net/npm/animejs@3.2.0/lib/anime.min.js"></script>
<script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script>

  




  <script src="/js/local-search.js"></script>












  








  

  

</body>
</html>
